[{"title":"IntelliJ IDEA 笔记","url":"/2020/02/24/note-idea/","content":"\nhttps://www.bilibili.com/video/av71609179?from=search&amp;seid=7606544420555480673\n\n\n版本ideaIU-2019.3.3 (学生License)macOS Catalina 10.15.3\n\n设置鼠标悬浮提示Preferences-&gt;Editor-&gt;General-&gt;Show quick documentation on mouse move\n自动导包Preferences-&gt;Editor-&gt;General-&gt;AutoImport-&gt;Add unambiguous imports on the flyPreferences-&gt;Editor-&gt;General-&gt;AutoImport-&gt;Optimize imports on the fly (for current project)\n方法间分隔符Preferences-&gt;Editor-&gt;General-&gt;Appearance-&gt;Show method separators\n忽略大小写提示Preferences-&gt;Editor-&gt;General-&gt;Code Completion-&gt;Match case (不勾选)\n文件多行显示栏Preferences-&gt;Editor-&gt;General-&gt;Editor Tabs-&gt;Show tabs in one row (不勾选)\n修改注释颜色Preferences-&gt;Editor-&gt;Color Scheme-&gt;Language Defaults-&gt;Comments中\n项目工程编码Preferences-&gt;Editor-&gt;File Encodings中\n自动编译Preferences-&gt;Build,Execution,Deployment-&gt;Compiler-&gt;Build project automaticallyPreferences-&gt;Build,Execution,Deployment-&gt;Compiler-&gt;Compile independent modules in parallel\n\n快捷键常用快捷键补全提示：^+/自动生成：^+Enter单行补全：Command+Shift+Enter方法参数提示：Command+P重新排版：Option+Command+LSurround With：Option+Command+T复制行或选中区域：Command+D删除行：Command+Delete\nLive Templates &amp; Postfix Completion查询实时代码模版：Command+JPreferences-&gt;Editor-&gt;LiveTemplates和Preferences-&gt;Editor-&gt;General-&gt;Postfix Completion中修改\n\n对普通Java项目打包File-&gt;Project Structure (或工具栏直接打开)Project Settings-&gt;Artifacts中加入当前项目\nBuild-&gt;Build Artifacts在工程目录中out-&gt;artifacts中创建jar包测试时，输入java -cp 包名+类名\n\nMavenIdea配置MavenPreferences-&gt;Build,Execution,Deployment-&gt;Build Tools-&gt;MavenMaven home directory中导入\nPreferences-&gt;Build,Execution,Deployment-&gt;Build Tools-&gt;Maven-&gt;Importing-&gt;Import Maven projects automatically勾上\n创建Maven项目New Project-&gt;Maven-&gt;Create from archetype勾上可以选择maven-archetype-quickstart运行默认的Hello World项目\n打包Maven项目Idea的Terminal中输入 (或系统Terminal切到工程目录下输入)\nmvn clean package\n打包完在target目录下运行输入\njava -cp target/xxx.jar 包名+类名\n排查依赖包冲突pom文件中，右键Diagram-&gt;show Dependencies结构图显示依赖关系红色虚线标明重复有时候重复不删掉也不会报错，默认使用路径短的如果报错，排除掉即可，代码中自动…\n\n项目目录&amp;文件夹类型对项目类型手动标注在目录上右键Mark Directory as-&gt;选择类型\nTest：可编译的单元测试目录Resources：资源文件目录Test Resources：单元测试资源文件目录Excluded：排除目录（相当于被废弃掉）Generated Sources：类似src（只有这种可以新建java类和包）\n\n多模块Maven项目构建多模块Maven项目新建一个Maven项目再新建Module，它也会有src、main的目录结构\n设置模块间依赖关系Project Structure-&gt;Modules-&gt;选中一个模块-&gt;Dependencies中添加，然后勾选上pom.xml中也许添加\n&lt;dependencies&gt;\t&lt;dependency&gt;\t\t&lt;groupId&gt;com.xxx&lt;/groupId&gt;\t\t&lt;artifactId&gt;xxx&lt;/artifactId&gt;\t\t&lt;version&gt;xxx&lt;/version&gt;\t&lt;/dependency&gt;&lt;/dependencies&gt;\n添加依赖后可以直接引用被依赖模块中的代码\n\nMaven Web项目创建Maven Web项目New Project-&gt;Maven-&gt;Create from archetype可以选择maven-archetype-webapp\n配置Tomcat工具栏中build(绿色锤子)旁边，Add Configuration新加Tomcat-&gt;Local （需先下载放在本地，配置路径）\nServer中可以修改默认浏览器，可以修改端口号\nDeployment中添加Artifactxxx:war exploded\n即可启动运行默认index.jsp显示Hello World!\n打包运行右侧Maven工具栏中Lifecycle-&gt;package-&gt;Run Maven Buildinstall-&gt;Run ‘xxx [install]’打包成功后，在target文件夹下\nwar包可以部署到服务器上\n也可以拷贝到本地Tomcat的webapp目录下运行Tomcat的bin目录下的startup，启动tomcat即可浏览器访问结束后shutdown关闭Tomcat\n","categories":["Note"],"tags":["tool"]},{"title":"课程总结 民事诉讼法","url":"/2020/02/22/mindmap/","content":"\nMOOC 北京交通大学 杨军 民事诉讼法\n\nP1\nP2\nP3\nP4\n","categories":["Memo"],"tags":["mindmap"]},{"title":"课程总结 信息素养与实践","url":"/2020/02/22/mindmap-paper/","content":"\n大三上的公选课\n\n\n\n","categories":["Memo"],"tags":["mindmap"]},{"title":"Spring笔记03 工厂模式","url":"/2020/02/24/note-spring-03/","content":"https://www.bilibili.com/video/av47952931p9~14\n\n程序的耦合与解耦 (以jdbc注册驱动为例)jdbc操作中，注册数据库驱动时，有2种方法\n// 方法1DriverManager.registerDriver(new com.mysql.jdbc.Driver());// 方法2Class.forName(&quot;com.mysql.jdbc.Driver&quot;);\n在pom.xml中添加了依赖的情况下都可以正常运行\n&lt;dependencies&gt;     &lt;dependency&gt;         &lt;groupId&gt;mysql&lt;/groupId&gt;         &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;         &lt;version&gt;5.1.6&lt;/version&gt;     &lt;/dependency&gt; &lt;/dependencies&gt;\n但是，如果去掉这段依赖\n方法1报Error，无法通过编译\nError:(26, 56) java: 程序包com.mysql.jdbc不存在\n而方法2报Exception，可以通过编译（无法运行）\nException in thread &quot;main&quot; java.lang.ClassNotFoundException: com.mysql.jdbc.Driver\n因为方法1依赖一个具体的驱动类，而方法2用反射，依赖的只是一个字符串但是这个字符串仍是写死在代码里的。应该写到配置文件里去，进一步减少耦合\n实际开发中应该做到：\n编译期不依赖，运行时才依赖\n解耦的思路：\n第一步：使用反射来创建对象，而避免使用new关键字\n第二步：通过读取配置文件来获取要创建的对象全限定类名\n\n工厂模式原始的分层实现方法\n\n\nClient : 模拟一个表现层，用于调用业务层\nIAccountService : 账户业务层的接口\nAccountServiceImpl : 账户的业务层实现类\nIAccountDao : 账户的持久层接口\nAccountDaoImpl : 账户的持久层实现类\n\n其中，有两个依赖关系\n\n表现层调用业务层时public class Client &#123;    public static void main(String[] args) &#123;        IAccountService as = new AccountServiceImpl();        as.saveAccount();    &#125;&#125;\n业务层调用持久层时public class AccountServiceImpl implements IAccountService &#123;\tprivate IAccountDao accountDao = new AccountDaoImpl();\tpublic void  saveAccount()&#123;        accountDao.saveAccount();    &#125;&#125;\n都用到了new，耦合度高如果此时把AccountDaoImpl的代码删了，Service就报错了。和前面jdbc中编译期的错误一样\n\n如何解除这种依赖？\nBean &amp; BeanFactoryBean —— 可重用组件eg：一个Dao可能被多个Service使用，一个Service可能被多个Servlet使用，它们是可重用的\nJavaBean —— 用java语言编写的可重用组件\nBeanFactory —— 创建Bean对象的工厂eg：创建Dao和Service对象\n要实现这个工厂，类似前面jdbc，\n1.需要一个配置文件来配置service和dao内容：唯一标识=全限定类名（key=value)配置文件可以是xml也可以是properties\n2.读取配置文件中配置的内容，通过==反射==创建对象\n工厂模式解耦在resources中新建beans.properties配置文件（此处用properties因为简单，Spring中用的是xml）\naccountService = com.itheima.service.impl.AccountServiceImplaccountDao = com.itheima.dao.impl.AccountDaoImpl\n创建BeanFactory类读取properties文件\npublic class BeanFactory &#123;    // 定义一个Properties对象    private static Properties props;    // 使用静态代码块为Properties对象赋值    static &#123;        try &#123;            // 实例化对象            props = new Properties();            // 获取properties文件的流对象            InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;);            props.load(in);        &#125;catch(Exception e)&#123;            // 抛一个Error，没有获取配置信息后面想都不要想            throw new ExceptionInInitializerError(&quot;初始化properties失败！&quot;);        &#125;    &#125;\t// 根据Bean的名称获取bean对象    public static Object getBean(String beanName)&#123;        Object bean = null;        try &#123;            String beanPath = props.getProperty(beanName);            bean = Class.forName(beanPath).newInstance();        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;        return bean;    &#125;&#125;\n\n注意：\n\n读配置文件时不要用FileInputStream，Web工程不好找路径。用类加载器。\ngetBean()返回的是Object类型\n\n把两处使用new创建对象的改为用反射创建\nClient中\n// IAccountService as = new AccountServiceImpl();IAccountService as = (IAccountService) BeanFactory.getBean(&quot;accountService&quot;);\nAccountServiceImpl中\n// private IAccountDao accountDao = new AccountDaoImpl();private IAccountDao accountDao = (IAccountDao) BeanFactory.getBean(&quot;accountDao&quot;);\nObject类强转为对应的类\n改进后程序的UML类图长这样\n\n\n此时如果把AccountServiceImpl删了，程序可以运行，抛ClassNotFoundException\n工厂模式的问题与改进如果要在Client中多次调用Service？\nfor(int i=0;i&lt;5;i++) &#123;\tIAccountService as = (IAccountService) BeanFactory.getBean(&quot;accountService&quot;);\tSystem.out.println(as);\tas.saveAccount();&#125;\n并在AccountServiceImpl中加一个成员变量i\npublic class AccountServiceImpl implements IAccountService &#123;    private IAccountDao accountDao = (IAccountDao) BeanFactory.getBean(&quot;accountDao&quot;);    private int i = 1;    public void  saveAccount()&#123;        accountDao.saveAccount();        System.out.println(i);        i++;    &#125;&#125;\n运行\n\ncom.itheima.service.impl.AccountServiceImpl@610455d6保存了账户1com.itheima.service.impl.AccountServiceImpl@511d50c0保存了账户1com.itheima.service.impl.AccountServiceImpl@60e53b93保存了账户1com.itheima.service.impl.AccountServiceImpl@5e2de80c保存了账户1com.itheima.service.impl.AccountServiceImpl@1d44bcfa保存了账户1\nProcess finished with exit code 0\n\n可以看到，AccountServiceImpl创建了5次，每次都是一个新的对象此时的对象是多例，效率没有单例高\n可以在BeanFactory中把创建出的对象都存起来\n//定义一个Map,用于存放我们要创建的对象。我们把它称之为容器private static Map&lt;String,Object&gt; beans;\n在静态代码块中，得到配置文件的输入流后，实例化这个容器。取出配置文件中所有的key-value，创建并保存它们\n// 实例化容器beans = new HashMap&lt;String,Object&gt;();// 取出配置文件中所有的KeyEnumeration keys = props.keys();// 遍历枚举while (keys.hasMoreElements())&#123;    // 取出每个Key    String key = keys.nextElement().toString();    // 根据key获取value    String beanPath = props.getProperty(key);    // 反射创建对象    Object value = Class.forName(beanPath).newInstance();    // 把key和value存入容器中    beans.put(key,value);&#125;\n获取Beans，不用newInstance()，直接从容器中取即可\npublic static Object getBean(String beanName)&#123;\treturn beans.get(beanName);&#125;\n这样修改后，调用5次Service打印的结果是\n\ncom.itheima.service.impl.AccountServiceImpl@610455d6保存了账户1com.itheima.service.impl.AccountServiceImpl@610455d6保存了账户2com.itheima.service.impl.AccountServiceImpl@610455d6保存了账户3com.itheima.service.impl.AccountServiceImpl@610455d6保存了账户4com.itheima.service.impl.AccountServiceImpl@610455d6保存了账户5\nProcess finished with exit code 0\n\n此时的AccountServiceImpl就是单例的了\n但有一个问题是，这个i在多线程时是不安全的应该把它移到方法里面，就没有这个问题了（实际使用一般也是这样）\n//    private int i = 1;    public void  saveAccount()&#123;        int i = 1;        accountDao.saveAccount();        System.out.println(i);        i++;    &#125;\n工厂模式使用套路总结1.创建BeanFactory\n// BeanFactory.javapublic class BeanFactory &#123;    //定义一个Properties对象    private static Properties props;    //定义一个Map,用于存放我们要创建的对象。称之为容器    private static Map&lt;String,Object&gt; beans;    //使用静态代码块为Properties对象赋值    static &#123;        try &#123;            // 1.实例化对象            props = new Properties();            // 2.获取properties文件的流对象            InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;);            props.load(in);            // 3.实例化容器            beans = new HashMap&lt;String,Object&gt;();            // 4.取出配置文件中所有的Key            Enumeration keys = props.keys();            // 5.遍历枚举            while (keys.hasMoreElements())&#123;                // 取出每个Key                String key = keys.nextElement().toString();                // 根据key获取value                String beanPath = props.getProperty(key);                // 反射创建对象                Object value = Class.forName(beanPath).newInstance();                // 把key和value存入容器中                beans.put(key,value);            &#125;        &#125;catch(Exception e)&#123;            throw new ExceptionInInitializerError(&quot;初始化properties失败！&quot;);        &#125;    &#125;    // 根据bean的名称获取对象    public static Object getBean(String beanName)&#123;        return beans.get(beanName);    &#125;&#125;\n\n2.配置文件\n// beans.propertiesaccountService=com.itheima.service.impl.AccountServiceImplaccountDao=com.itheima.dao.impl.AccountDaoImpl\n\n3.获取Bean\n// Client.javapublic class Client &#123;    public static void main(String[] args) &#123;    \tIAccountService as = (IAccountService) BeanFactory.getBean(&quot;accountService&quot;);    \tas.saveAccount();    &#125;&#125;\n\n","categories":["Note"],"tags":["spring"]},{"title":"Spring笔记04 应用分层","url":"/2020/02/24/note-spring-04/","content":"三层架构 (3-Tier Architecture)\n\n\n表示层 (PL, Presentation Layer 或 UI, User Interface Layer) —— 主要是与用户交互的界面，用于接收用户输入的数据和显示处理后的数据\n业务逻辑层 (BLL, Business Logic Layer) —— PL与DAL之间的桥梁，实现业务逻辑，主要包括验证、计算、规则等\n数据访问层 (DAL, Data Access Layer) —— 与数据库交互，实现对数据的CURD，将存储在数据库中的数据提交给业务层，同时将业务层处理的数据保存到数据库\n\nMVC模式 (Model-View-Controller)\n\n描述1:\n\n模型 (Model) —— 程序需要操作的数据或信息\n视图 (View) —— 提供给用户的操作界面，是程序的外壳\n控制器 (Controller) —— 负责根据用户从”视图层”输入的指令，选取”数据层”中的数据，然后对其进行相应的操作，产生最终结果\n\n描述2:\n\n模型 (Model) —— 表示应用程序和任何应由其执行的业务逻辑或操作的状态\n视图 (View) —— 负责通过用户界面展示内容\n控制器 (Controller) —— 是处理用户交互、使用模型并最终选择要呈现的视图的组件\n\n三层架构与MVC的区别与联系1. 关注点\n三层架构是为了解决整个应用程序中各个业务操作过程中的==不同阶段的代码封装==问题，使程序员更加专注的处理某阶段的业务逻辑\nMVC架构模式将应用程序分为三个主要组成部分，有助于实现关注点分离。分离关注点是开发时的指导原则，此原则主张应根据==软件执行的工作类型==将软件分离2. 切分方向\n三层架构是一种软件抽象的层次结构，是对复杂系统的一种纵向切分\nMVC更像是横向切分，每块都可以独立测试3. 依赖关系\n三层架构中，层次之间一般是向下依赖的。下层在未确定接口（契约）规范前，上层代码无法开发，下层代码接口的变化将使上层一起变化\nMVC中，三者并不存在明显的层次结构，没有明显的向下依赖的关系。相反的是View和Model往往是比较独立的，而Controller则是两者的桥梁\n\n都是为了解耦\n\nMVC、MVP、MVVM\nMVC，MVP 和 MVVM 的图示\n\n\n阿里规范\n《Java开发手册》v1.5.0 华山版\n\n图中默认上层依赖于下层，箭头关系表示可直接依赖，如:开放接口层可以依赖于 Web 层，也可以直接依赖于 Service 层，依此类推:\n\n开放接口层 : 可直接封装 Service 方法暴露成 RPC 接口;通过 Web 封装成 http 接口;进行网关安全控制、流量控制等。\n终端显示层 : 各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移动端展示等。\nWeb层 : 主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。\nService层 : 相对具体的业务逻辑服务层。\nManager层 : 通用业务处理层，它有如下特征:\n\n\n对第三方平台封装的层，预处理返回结果及转化异常信息。\n对 Service 层通用能力的下沉，如缓存方案、中间件通用处理。\n与 DAO 层交互，对多个 DAO 的组合复用。\n\n\nDAO层 : 数据访问层，与底层 MySQL、Oracle、Hbase 等进行数据交互。\n外部接口或第三方平台 : 包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口。\n\n\nref:谈谈MVC模式ASP.NET MVC与三层架构ASP.NET Core MVC 概述体系结构原则\n\n","categories":["Note"],"tags":["spring"]},{"title":"Spring笔记01 jdbc常用操作","url":"/2020/02/24/note-spring-01/","content":"\nhttps://www.bilibili.com/video/av47952931\n\n之前学数据库的时候mysql踩了好多坑，主要是版本问题不同版本语法有些不兼容记录一下Apply生成的语句备用\n\n版本:mysql-8.0.19-macos10.15-x86_64MySQL Workbench 8.0.16\n\nMySQL Workbench操作创建schemaCREATE SCHEMA `groot` ;\n\n\n创建table这是b站教程给的sql\ncreate table account(\tid int primary key auto_increment,\tname varchar(40),\tmoney float)character set utf8 collate utf8_general_ci;\n\n这是Workbench里生成的sql\nCREATE TABLE `groot`.`account` (  `id` INT NOT NULL AUTO_INCREMENT,  `name` VARCHAR(45) NULL,  `money` FLOAT NULL,  PRIMARY KEY (`id`));\n\n\n插入记录b站教程给的sql\ninsert into account(name,money) values(&#x27;aaa&#x27;,1000);insert into account(name,money) values(&#x27;bbb&#x27;,1000);insert into account(name,money) values(&#x27;ccc&#x27;,1000);\nWorkbench里生成的sql\nINSERT INTO `groot`.`account` (`name`, `money`) VALUES (&#x27;aaa&#x27;, &#x27;1000&#x27;);INSERT INTO `groot`.`account` (`name`, `money`) VALUES (&#x27;bbb&#x27;, &#x27;1000&#x27;);INSERT INTO `groot`.`account` (`name`, `money`) VALUES (&#x27;ccc&#x27;, &#x27;1000&#x27;);\n\n\n查看记录SELECT * FROM groot.account;\n\n\nIdea中连接数据库//1.注册驱动Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//2.获取连接Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/groot?useUnicode=true&amp;characterEncoding=utf8&quot;,&quot;root&quot;,&quot;iamgroot&quot;);//3.获取操作数据库的预处理对象PreparedStatement pstm = conn.prepareStatement(&quot;select * from account&quot;);//4.执行SQL，得到结果集ResultSet rs = pstm.executeQuery();//5.遍历结果集while(rs.next())&#123;    System.out.println(rs.getString(&quot;name&quot;));&#125;//6.释放资源rs.close();pstm.close();conn.close();\n","categories":["Note"],"tags":["spring"]},{"title":"Spring笔记02 Idea运行示例项目的坑","url":"/2020/02/24/note-spring-02/","content":"表建好之后，Idea里面直接打开示例工程跑不起来，mysql的依赖有问题\nException in thread &quot;main&quot; java.lang.ClassNotFoundException: com.mysql.jdbc.Driver\n对比发现Maven路径不对\n这是自己创建的可以运行的Maven项目配置\n这是导入工程的配置\n修改路径\n/usr/local/Cellar/maven/3.6.2/libexec/Users/coconutnut/.m2/settings.xml/Users/coconutnut/.m2/repository\n解决Driver问题\n\n下一个bugIdea中点运行\nMySQLNonTransientConnectionException: Client does not support authentication protocol requested by server\n\nhttps://www.cnblogs.com/inconceivable/p/9186822.html\n\n在MySQL Workbench中输入\nUSE mysql;ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;iamgroot&#x27;;FLUSH PRIVILEGES;\nIdea中提示变成了\nException in thread &quot;main&quot; java.sql.SQLException: Unknown initial character set index &#x27;255&#x27; received from server. Initial client character set can be forced via the &#x27;characterEncoding&#x27; property.\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:1055)\n\nhttps://blog.csdn.net/qq1515312832/article/details/85614733\n\n在连接数据库的url后加上编码方式\nConnection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/groot?useUnicode=true&amp;characterEncoding=utf8&quot;,&quot;root&quot;,&quot;iamgroot&quot;);\n成功\n\n总结：\n\n修改Preference-&gt;Build, Execution, Deployment-&gt;Build Tools-&gt;Maven中路径\n在连接数据库的url后加上编码方式\n\n","categories":["Note"],"tags":["spring"]},{"title":"Spring笔记05 IoC","url":"/2020/02/28/note-spring-05/","content":"https://www.bilibili.com/video/av47952931p15～34\n\nIoC的概念和作用上次工厂模式中创建对象有2种方式\n// 方式1IAccountService as = new AccountServiceImpl();// 方式2IAccountService as = (IAccountService) BeanFactory.getBean(&quot;accountService&quot;);\n方式1是主动的；方式2是被动的（根据配置创建），控制权转移给了工厂\nIoC (Inversion of Control 控制反转)把创建对象的权利交给框架其作用是降低程序的耦合但只能是降低，而不能完全消除。如果两个类之间任何关系都没有，那有一个类一定是多余的。自己写时用工厂模式实现，Spring中的Ioc如何实现？\n\nSpring中的IoC控制反转 Inversion of Control, IoC\n解决的问题：降低程序耦合（减少依赖关系）解决的方法：使用配置的方式\n1.导入依赖导入Spring依赖\n&lt;dependencies&gt;\t&lt;dependency&gt;\t\t&lt;groupId&gt;org.springframework&lt;/groupId&gt;\t\t&lt;artifactId&gt;spring-context&lt;/artifactId&gt;\t\t&lt;version&gt;5.0.2.RELEASE&lt;/version&gt;\t&lt;/dependency&gt;&lt;/dependencies&gt;\n在查看引入的依赖  包含了常用的核心组件\nCore Container简单的说就是一个Map，封装了要用的对象\n2.创建配置文件&amp;导入约束&amp;配置bean然后创建bean.xml（没有固定要求，习惯这样命名，因为是管beans的）在spring-framework-5.0.2.RELEASE-docs/spring-framework-reference文件夹中找到index.html点core，搜索xmlns（导入xml schema约束的关键字）把它复制粘贴到配置文件中\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt;\n配置bean，把对象的创建交给Spring来管理同工厂模式，需要唯一标志和对象的全限定类名（包名+类名）\n&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;accountDao&quot; class=&quot;com.itheima.dao.impl.AccountDaoImpl&quot;&gt;&lt;/bean&gt;\n剩下的解析配置文件的事就由Spring做了\n3.取出容器&amp;获取对象// Client.javapublic class Client &#123;\tpublic static void main(String[] args) &#123;        // 1.获取核心容器对象        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);        // 2.根据id获取Bean对象        // 方法一：拿到一个Object类，自己强转        IAccountService as  = (IAccountService)ac.getBean(&quot;accountService&quot;);        // 方法二：给一个类型，直接得到该类型对象        IAccountDao adao = ac.getBean(&quot;accountDao&quot;,IAccountDao.class);    &#125;&#125;\n\ntip: ApplicationContext的继承关系Idea中，在类上右键-&gt;Diagrams-&gt;Show Diagram在接口上右键-&gt;Show Implementations可以看到，ApplicationContext继承自BeanFactory，ClassPathXmlApplicationContext是它的实现类\nApplicationContext的三个常用实现类：     *      ClassPathXmlApplicationContext：它可以加载类路径下的配置文件（配置文件必须在类路径下，不在的加载不了）（更常用）     *      FileSystemXmlApplicationContext：它可以加载磁盘任意路径下的配置文件（必须有访问权限）     *      AnnotationConfigApplicationContext：它是用于读取注解创建容器的（后面讲）\ntip: ApplicationContext和BeanFactory的区别ApplicationContext\n\n构建核心容器时，创建对象采取的策略是采用立即加载的方式。即，一读取完配置文件马上就创建配置文件中配置的对象\n单例对象适用 \n\nBeanFactory\n\n构建核心容器时，创建对象采取的策略是采用延迟加载的方式。即，什么时候根据id获取对象了，什么时候才真正的创建对象\n多例对象使用\n\n\nbean的细节创建bean对象的三种方式方式一：使用默认构造函数创建在spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签时。采用的就是默认构造函数创建bean对象，此时如果类中没有默认构造函数，则对象无法创建。\n&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;\n方式二：使用普通工厂中的方法创建对象实际开发中，可能要用到别人写好的jar包中的类。（不知道有没有默认构造函数，也无法通过修改源码来提供默认构造函数）。例如：\n// 模拟一个工厂类（该类可能是存在于jar包中的，我们无法通过修改源码的方式来提供默认构造函数）public class InstanceFactory &#123;    public IAccountService getAccountService()&#123;        return new AccountServiceImpl();    &#125;&#125;\n有这么一个InstanceFactory类，需要拿到AccountServiceImpl如果像方法一那样创建对象，即\n&lt;bean id=&quot;instanceFactory&quot; class=&quot;com.itheima.factory.InstanceFactory&quot;&gt;&lt;/bean&gt;\n得到的并不是AccountServiceImpl对象，而是InstanceFactory对象\n此时应该修改创建对象的方式使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器）\n&lt;bean id=&quot;instanceFactory&quot; class=&quot;com.itheima.factory.InstanceFactory&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;accountService&quot; factory-bean=&quot;instanceFactory&quot; factory-method=&quot;getAccountService&quot;&gt;&lt;/bean&gt;\n先创建工厂，再通过工厂的方法创建所需对象\n方式三：使用工厂中的静态方法创建对象模拟一个工厂类，它有一个返回对象的静态方法\n// 模拟一个工厂类（该类可能是存在于jar包中的，我们无法通过修改源码的方式来提供默认构造函数）public class StaticFactory &#123;    public static IAccountService getAccountService()&#123;        return new AccountServiceImpl();    &#125;&#125;\n使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器)\n&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.factory.StaticFactory&quot; factory-method=&quot;getAccountService&quot;&gt;&lt;/bean&gt;\n这里的factory-method是一个静态方法\nQ：这两个工厂中不都new对象了吗？A：把这两个对象看作jar包中的类（此处只是模拟它），jar包中不是.java文件而是.class，都是无法修改的。实际开发中，有些对象就得用方法二或方法三来创建\n指定bean对象的作用范围：bean标签的scope属性取值：singleton：单例的（默认值）（常用）prototype：多例的（常用）request：作用于web应用的请求范围session：作用于web应用的会话范围global-session：作用于集群环境的会话范围（全局会话范围），当不是集群环境时，它就是session\n例子：\n&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;\n\nglobal-session的含义\nbean对象的生命周期单例对象\n\n出生：当容器创建时对象出生\n活着：只要容器还在，对象一直活着\n死亡：容器销毁，对象消亡\n\n总结：单例对象的生命周期和容器相同\n多例对象\n\n出生：当我们使用对象时spring框架为我们创建\n活着：对象只要是在使用过程中就一直活着。\n死亡：当对象长时间不用，且没有别的对象引用时，由Java的垃圾回收器回收\n\n可以通过bean标签指定在特定生命周期执行的方法\n例子：\n// beans.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\t&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;          scope=&quot;singleton&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;\n// Client.javapublic class Client &#123;    public static void main(String[] args) &#123;        // 1.获取核心容器对象        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);  // 执行完这句，单例对象就创建了        // 2.根据id获取Bean对象        IAccountService as  = (IAccountService)ac.getBean(&quot;accountService&quot;);  // 执行完这句，多例对象才创建        as.saveAccount();    &#125;    &#125;\n// AccountServiceImpl.javapublic class AccountServiceImpl implements IAccountService &#123;    public AccountServiceImpl()&#123;        System.out.println(&quot;对象创建了...&quot;);    &#125;    public void  saveAccount()&#123;        System.out.println(&quot;service中的saveAccount方法执行了...&quot;);    &#125;    public void  init()&#123;        System.out.println(&quot;对象初始化了...&quot;);    &#125;    public void  destroy()&#123;        System.out.println(&quot;对象销毁了...&quot;);    &#125;&#125;\n执行输出\n\n对象创建了…对象初始化了…service中的saveAccount方法执行了…\n\nQ：为什么没有执行销毁方法？A：main()结束之后，当前进程占用的内存全部释放（包括容器），此时并没有调用销毁方法就已经把内存释放了。这里要想调用销毁方法，可以手动关闭容器\n在main()中手动关闭容器为什么没有呢？这里ApplicationContext是个接口，调不到子类的方法\n// 1.获取核心容器对象// ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);// 2.根据id获取Bean对象IAccountService as  = (IAccountService)ac.getBean(&quot;accountService&quot;);as.saveAccount();// 3.手动关闭容器ac.close();\n这样就可以了\n\n对象创建了…对象初始化了…service中的saveAccount方法执行了…对象销毁了…\n\n但是，此时如果把对象改为多例的，其它都不变，不会执行销毁方法\n\nSpring中的依赖注入(DI)依赖注入 Dependency Injection, DI\n能注入的三类数据\n\n基本类型和String\n其他bean类型（在配置文件中或者注解配置过的bean）\n复杂类型/集合类型\n\n注入的三种方式\n\n使用构造函数提供\n使用set方法提供\n使用注解提供\n\n构造函数注入使用的标签：constructor-arg标签出现的位置：bean标签的内部标签中的属性（指定参数）：\n\ntype：指定数据类型\nindex：指定构造函数中的索引位置\nname：指定名称（常用）\n\n标签中的属性（提供赋值）：\n\nvalue：用于提供基本类型和String类型的数据\nref：用于指定其他的bean类型数据（在spring的Ioc核心容器中出现过的bean对象）\n\n优势：在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功（必须某些数据时，不会被忽略）弊端：改变了bean对象的实例化方式，创建对象时，即使以后用不到这些数据，也必须提供\n例：\nAccountServiceImpl类有3个变量，没有无参构造函数\npublic class AccountServiceImpl implements IAccountService &#123;    // 如果是经常变化的数据，并不适用于注入的方式    private String name;    private Integer age;    private Date birthday;    public AccountServiceImpl(String name,Integer age,Date birthday)&#123;        this.name = name;        this.age = age;        this.birthday = birthday;    &#125;&#125;\nbean.xml对应的bean配置\n&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;\t&lt;constructor-arg name=&quot;name&quot; value=&quot;test&quot;&gt;&lt;/constructor-arg&gt;\t&lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt;\t&lt;constructor-arg name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!-- 配置一个日期对象 --&gt;&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;\n配置中的value都是字符串，对于String、Integer类型，Spring可以自动转换但Date无法直接转换，需另外配置\nset方法注入比构造函数常用\n使用的标签：property出现的位置：bean标签的内部标签的属性：\n\nname：用于指定注入时所调用的set方法名称（不管变量名）\nvalue：用于提供基本类型和String类型的数据\nref：用于指定其他的bean类型数据\n\n优势：创建对象时没有明确的限制，可以直接使用默认构造函数弊端：如果有某个成员必须有值，但没有注入\n例：\npublic class AccountServiceImpl2 implements IAccountService &#123;    private String name;    private Integer age;    private Date birthday;    public void setName(String name) &#123;this.name = name;&#125;    public void setAge(Integer age) &#123;this.age = age;&#125;    public void setBirthday(Date birthday) &#123;this.birthday = birthday;&#125;&#125;\n&lt;bean id=&quot;accountService2&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl2&quot;&gt;\t&lt;property name=&quot;name&quot; value=&quot;TEST&quot; &gt;&lt;/property&gt;\t&lt;property name=&quot;age&quot; value=&quot;21&quot;&gt;&lt;/property&gt;\t&lt;property name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/property&gt;&lt;/bean&gt;\n复杂类型注入用于给List结构集合注入的标签：            list array set\n用于个Map结构集合注入的标签:            map  props\n! 结构相同，标签可以互换\n例：\npublic class AccountServiceImpl3 implements IAccountService &#123;\t// list结构    private String[] myStrs;    private List&lt;String&gt; myList;    private Set&lt;String&gt; mySet;    // map结构    private Map&lt;String,String&gt; myMap;    private Properties myProps;    public void setMyStrs(String[] myStrs) &#123; this.myStrs = myStrs; &#125;    public void setMyList(List&lt;String&gt; myList) &#123; this.myList = myList; &#125;    public void setMySet(Set&lt;String&gt; mySet) &#123; this.mySet = mySet; &#125;\tpublic void setMyMap(Map&lt;String, String&gt; myMap) &#123; this.myMap = myMap; &#125;    public void setMyProps(Properties myProps) &#123; this.myProps = myProps; &#125;&#125;\n&lt;bean id=&quot;accountService3&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl3&quot;&gt;\t&lt;!--用array、list、set都行--&gt;\t&lt;property name=&quot;myStrs&quot;&gt;\t\t&lt;array&gt;\t\t\t&lt;value&gt;AAA&lt;/value&gt;\t\t\t&lt;value&gt;BBB&lt;/value&gt;\t\t\t&lt;value&gt;CCC&lt;/value&gt;\t\t&lt;/array&gt;\t&lt;/property&gt;\t&lt;!--用map、prop都行--&gt;\t&lt;property name=&quot;myMap&quot;&gt;\t\t&lt;map&gt;\t\t\t&lt;entry key=&quot;testA&quot; value=&quot;aaa&quot;&gt;&lt;/entry&gt;\t\t\t&lt;entry key=&quot;testB&quot;&gt;\t\t\t\t&lt;value&gt;BBB&lt;/value&gt;\t        &lt;/entry&gt;\t\t&lt;/map&gt;\t&lt;/property&gt;&lt;/bean&gt;\n\n\n基于注解的IoC配置注解配置和xml配置要实现的功能都是一样的：降低程序耦合\n曾经XML的配置：\n&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;\tscope=&quot;&quot;  init-method=&quot;&quot; destroy-method=&quot;&quot;&gt;\t&lt;property name=&quot;&quot;  value=&quot;&quot; | ref=&quot;&quot;&gt;&lt;/property&gt;&lt;/bean&gt;\n\n使用注解时，不用上面的，但需要告诉Spring开启注解扫描\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!--告知spring在创建容器时要扫描的包，配置所需要的标签不是在beans的约束中，而是一个名称为    context名称空间和约束中--&gt;    &lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;&lt;/context:component-scan&gt;&lt;/beans&gt;\n其中context名称空间和前面一样，在文档中搜索找\n用于创建对象的注解@Component作用：用于把当前类对象存入spring容器中\n属性：value：用于指定bean的id（不写时，默认值是当前类名，且首字母小写）\n例：\n@Component(value = &quot;accountService&quot;)public class AccountServiceImpl implements IAccountService &#123;\t//...&#125;\n\n细节：当只给一个value属性赋值时，value可以不写\n@Component(&quot;accountService&quot;)public class AccountServiceImpl implements IAccountService &#123;\t//...&#125;\n\n@Controller：一般用在表现层@Service：一般用在业务层@Repository：一般用在持久层\n以上三个注解的作用和属性与@Component一模一样是Spring框架提供的明确的三层使用的注解，使三层对象更加清晰\n用于注入数据的注解@Autowired作用：自动按照类型注入。只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功。如果ioc容器中没有任何bean的类型和要注入的变量类型匹配，则报错（当有多个bean类型匹配时，用变量名和bean的id匹配，如果恰好有一个匹配，也可以成功，否则报错）\n出现位置：可以是变量上，也可以是方法上\n例：\n@Autowiredprivate IAccountDao accountDao = null;\n\n细节：在使用注解注入时，set方法就不是必须的了\n@Qualifier 作用： 在按照类中注入的基础之上再按照名称注入。在给类成员注入时不能单独使用，必须和@Autowired一起。但是在给方法参数注入时可以单独使用\n属性：value：用于指定注入bean的id\n例：\n@Autowired@Qualifier(&quot;accountDao1&quot;)private IAccountDao accountDao = null;\n\n@Resource 作用： 直接按照bean的id注入，可以独立使用\n属性：name：用于指定bean的id（注意：这里是name，不是value）\n例：\n@Resource(name = &quot;accountDao1&quot;)private IAccountDao accountDao = null;\n\n以上三个注解都只能注入其他bean类型的数据，而基本类型和String类型无法注入另外，集合类型的注入只能通过XML来实现\n@Value作用：用于注入基本类型和String类型的数据\n属性：value：用于指定数据的值可以使用Spring中SpEL（即Spring的el表达式）写法：${表达式}\n用于改变作用范围的注解@Scope作用：用于指定bean的作用范围\n属性：value：指定范围的取值（常用：singleton prototype）\n例：\n@Service(&quot;accountService&quot;)@Scope(&quot;prototype&quot;)public class AccountServiceImpl implements IAccountService &#123;\t//...&#125;\n生命周期相关的注解@PreDestroy作用：用于指定销毁方法\n@PostConstruct作用：用于指定初始化方法\n和bean标签中使用init-method和destroy-methode一样\n例：\n@Service(&quot;accountService&quot;)@Scope(&quot;singleton&quot;)public class AccountServiceImpl implements IAccountService &#123;    @Resource(name = &quot;accountDao1&quot;)    private IAccountDao accountDao = null;    @PostConstruct    public void  init()&#123;        System.out.println(&quot;初始化方法执行了&quot;);    &#125;    @PreDestroy    public void  destroy()&#123;        System.out.println(&quot;销毁方法执行了&quot;);    &#125;    public void  saveAccount()&#123;        accountDao.saveAccount();    &#125;&#125;\n\n同样，如果类是多例的，可能不会看到销毁方法执行的输出，因为它的销毁是JVM管的\n","categories":["Note"],"tags":["spring"]},{"title":"课程总结 压力与情绪管理","url":"/2020/02/22/mindmap-stress/","content":"\nMOOC 四川大学 杨鑫 压力与情绪管理\n\n","categories":["Memo"],"tags":["mindmap"]},{"title":"Spring笔记06 基于xml的IoC案例（实现CRUD）","url":"/2020/03/04/note-spring-06/","content":"\nhttps://www.bilibili.com/video/av47952931p35~37\n\n\n数据库部分mysql中建一张account表\n\nmaven工程项目结构\n\npom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.coconutnut&lt;/groupId&gt;    &lt;artifactId&gt;day02_02_account_xml&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;!--    打成jar包--&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;&lt;!--    加入依赖--&gt;    &lt;dependencies&gt;&lt;!--        spring--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;        &lt;/dependency&gt;&lt;!--        dbutils--&gt;        &lt;dependency&gt;            &lt;groupId&gt;commons-dbutils&lt;/groupId&gt;            &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt;            &lt;version&gt;1.4&lt;/version&gt;        &lt;/dependency&gt;&lt;!--        mysql驱动--&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.16&lt;/version&gt;        &lt;/dependency&gt;&lt;!--        jdbc连接池--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.mchange&lt;/groupId&gt;            &lt;artifactId&gt;c3p0&lt;/artifactId&gt;            &lt;version&gt;0.9.5.2&lt;/version&gt;        &lt;/dependency&gt;&lt;!--    junit测试--&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.10&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n实体类Account.java\npackage com.cc.domain;import java.io.Serializable;/** * 账户的实体类 */public class Account implements Serializable &#123;    private Integer id;    private String name;    private Float money;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Float getMoney() &#123;        return money;    &#125;    public void setMoney(Float money) &#123;        this.money = money;    &#125;    @Override    public String toString() &#123;        return &quot;Account&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, money=&quot; + money +                &#x27;&#125;&#x27;;    &#125;&#125;\n业务层IAccountService.java\npackage com.cc.service;import com.cc.domain.Account;import java.util.List;/** * 账户的业务层接口 */public interface IAccountService &#123;    /**     * 增     * @param account     */    void createAccount(Account account);    /**     * 删     * @param accountId     */    void deleteAccount(Integer accountId);    /**     * 改     * @param account     */    void updateAccount(Account account);    /**     * 查一个     * @param accountId     * @return     */    Account retrieveAccountById(Integer accountId);    /**     * 查所有     * @return     */    List&lt;Account&gt; retrieveAllAccounts();&#125;\nAccountServiceImpl.java\npackage com.cc.service.impl;import com.cc.dao.IAccountDao;import com.cc.domain.Account;import com.cc.service.IAccountService;import java.util.List;/** * 账户的业务层实现类 */public class AccountServiceImpl implements IAccountService &#123;    private IAccountDao accountDao;    public void setAccountDao(IAccountDao accountDao) &#123;        this.accountDao = accountDao;    &#125;    public void createAccount(Account account) &#123;        accountDao.createAccount(account);    &#125;    public void deleteAccount(Integer accountId) &#123;        accountDao.deleteAccount(accountId);    &#125;    public void updateAccount(Account account) &#123;        accountDao.updateAccount(account);    &#125;    public Account retrieveAccountById(Integer accountId) &#123;        return accountDao.retrieveAccountById(accountId);    &#125;    public List&lt;Account&gt; retrieveAllAccounts() &#123;        return accountDao.retrieveAllAccounts();    &#125;&#125;\n持久层IAccountDao.java\npackage com.cc.dao;import com.cc.domain.Account;import java.util.List;/** * 账户的持久层接口 */public interface IAccountDao &#123;    void createAccount(Account account);    void deleteAccount(Integer accountId);    void updateAccount(Account account);    Account retrieveAccountById(Integer accountId);    List&lt;Account&gt; retrieveAllAccounts();&#125;\nAccountDaoImpl.java\npackage com.cc.dao.impl;import com.cc.dao.IAccountDao;import com.cc.domain.Account;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import java.sql.SQLException;import java.util.List;/** * 账户的持久层实现类 */public class AccountDaoImpl implements IAccountDao &#123;    private QueryRunner runner;    public void setRunner(QueryRunner runner) &#123;        this.runner = runner;    &#125;    public void createAccount(Account account) &#123;        try &#123;            runner.update(&quot;insert into account(name,money) values(?,?)&quot;, account.getName(), account.getMoney());        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public void deleteAccount(Integer accountId) &#123;        try &#123;            runner.update(&quot;delete from account where id = ?&quot;, accountId);        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public void updateAccount(Account account) &#123;        try &#123;            runner.update(&quot;update account set name = ?, money = ? where id = ?&quot;, account.getName(), account.getMoney(),account.getId());        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public Account retrieveAccountById(Integer accountId) &#123;        try &#123;            return runner.query(&quot;select * from account where id = ?&quot;, new BeanHandler&lt;Account&gt;(Account.class), accountId);        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public List&lt;Account&gt; retrieveAllAccounts() &#123;        try &#123;            return runner.query(&quot;select * from account&quot;, new BeanListHandler&lt;Account&gt;(Account.class));        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\nbeans.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!--    配置Service--&gt;    &lt;bean id=&quot;accountService&quot; class=&quot;com.cc.service.impl.AccountServiceImpl&quot;&gt;&lt;!--        注入Dao--&gt;        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--    配置Dao--&gt;    &lt;bean id=&quot;accountDao&quot; class=&quot;com.cc.dao.impl.AccountDaoImpl&quot;&gt;&lt;!--        注入QueryRunner--&gt;        &lt;property name=&quot;runner&quot; ref=&quot;runner&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--    配置QueryRunner（多例）--&gt;    &lt;bean id=&quot;runner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot; scope=&quot;prototype&quot;&gt;&lt;!--        注入数据源（没有set方法，只能构造函数注入）--&gt;        &lt;constructor-arg name=&quot;ds&quot; ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;&lt;!--    配置数据源--&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;&lt;!--        注入连接数据库的信息--&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/groot?characterEncoding=utf8&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;iamgroot&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n测试方法AccountServiceTest.java\npackage com.cc.test;import com.cc.domain.Account;import com.cc.service.IAccountService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.util.List;/** * 使用Junit测试配置 */public class AccountServiceTest &#123;    @Test    public void testCreate()&#123;        // 1.获取容器        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        // 2.得到业务层对象        IAccountService as = ac.getBean(&quot;accountService&quot;,IAccountService.class);        // 3.执行方法        Account account = new Account();        account.setName(&quot;ddd&quot;);        account.setMoney(10f);        as.createAccount(account);    &#125;    @Test    public void testDelete()&#123;        // 1.获取容器        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        // 2.得到业务层对象        IAccountService as = ac.getBean(&quot;accountService&quot;,IAccountService.class);        // 3.执行方法        as.deleteAccount(2);    &#125;    @Test    public void testUpdate()&#123;        // 1.获取容器        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        // 2.得到业务层对象        IAccountService as = ac.getBean(&quot;accountService&quot;,IAccountService.class);        // 3.执行方法        Account account = as.retrieveAccountById(1);        account.setMoney(2000f);        as.updateAccount(account);    &#125;    @Test    public void testRetrieveOne()&#123;        // 1.获取容器        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        // 2.得到业务层对象        IAccountService as = ac.getBean(&quot;accountService&quot;,IAccountService.class);        // 3.执行方法        Account account = as.retrieveAccountById(1);        System.out.println(account);    &#125;    @Test    public void testRetrieveAll()&#123;        // 1.获取容器        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        // 2.得到业务层对象        IAccountService as = ac.getBean(&quot;accountService&quot;,IAccountService.class);        // 3.执行方法        List&lt;Account&gt; accounts = as.retrieveAllAccounts();        for(Account account : accounts)&#123;            System.out.println(account);        &#125;    &#125;\n\n测试testRetrieveAll()\ntestRetrieveOne()\ntestCreate()\ntestDelete()\ntestUpdate()\n\n遇到的bug执行testRetrieveAll()时\n==BUG01==\n警告: Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;accountService&apos; defined in class path resource [beans.xml]: Error setting property values; nested exception is org.springframework.beans.NotWritablePropertyException: Invalid property &apos;accountDao &apos; of bean class [com.cc.service.impl.AccountServiceImpl]: Bean property &apos;accountDao &apos; is not writable or has an invalid setter method. Did you mean &apos;accountDao&apos;?\n\norg.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;accountService&apos; defined in class path resource [beans.xml]: Error setting property values; nested exception is org.springframework.beans.NotWritablePropertyException: Invalid property &apos;accountDao &apos; of bean class [com.cc.service.impl.AccountServiceImpl]: Bean property &apos;accountDao &apos; is not writable or has an invalid setter method. Did you mean &apos;accountDao&apos;?\n\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1650)\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1357)\n...其中\nBean property &apos;accountDao &apos; is not writable or has an invalid setter method. Did you mean &apos;accountDao&apos;?发现多打了个空格\nbeans.xml中&lt;property name=&quot;accountDao &quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;改为&lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;\n改过来之后\n==BUG02==\n警告: com.mchange.v2.resourcepool.BasicResourcePool$ScatteredAcquireTask@63fd9b65 -- Acquisition Attempt Failed!!! Clearing pending acquires. While trying to acquire a needed new resource, we failed to succeed more than the maximum number of allowed acquisition attempts (30). Last acquisition attempt exception: \njava.sql.SQLException: Unknown initial character set index &apos;255&apos; received from server. Initial client character set can be forced via the &apos;characterEncoding&apos; property.\nat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:1055)\n...似乎是编码问题\nbeans.xml中&lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/groot&quot;&gt;&lt;/property&gt;改为&lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/groot?characterEncoding=utf8&quot;&gt;&lt;/property&gt;\n改了之后\n==BUG03==\n警告: com.mchange.v2.resourcepool.BasicResourcePool$ScatteredAcquireTask@4879bf70 -- Acquisition Attempt Failed!!! Clearing pending acquires. While trying to acquire a needed new resource, we failed to succeed more than the maximum number of allowed acquisition attempts (30). Last acquisition attempt exception: \njava.sql.SQLException: Unknown system variable &apos;tx_isolation&apos;\nat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:1055)查一下解决方啊\n\nhttps://blog.csdn.net/always_younger/article/details/80421783\n\n说是mysql-connector-java版本太低的原因\npom.xml中&lt;dependency&gt;\t&lt;groupId&gt;mysql&lt;/groupId&gt;\t&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\t&lt;version&gt;5.1.6&lt;/version&gt;&lt;/dependency&gt;改为&lt;dependency&gt;\t&lt;groupId&gt;mysql&lt;/groupId&gt;\t&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\t&lt;version&gt;8.0.16&lt;/version&gt;&lt;/dependency&gt;\n还有一点小问题\nLoading class `com.mysql.jdbc.Driver&apos;. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver&apos;. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.把过时的类换掉\nbeans.xml中&lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;改为&lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;&gt;&lt;/property&gt;\n就好了！\nAccount&#123;id=1, name=&apos;aaa&apos;, money=1000.0&#125;\nAccount&#123;id=2, name=&apos;bbb&apos;, money=1000.0&#125;\nAccount&#123;id=3, name=&apos;ccc&apos;, money=1000.0&#125;\n\nProcess finished with exit code 0","categories":["Note"],"tags":["spring"]},{"title":"Spring笔记07 基于注解的IoC案例（实现CRUD）","url":"/2020/03/04/note-spring-07/","content":"\nhttps://www.bilibili.com/video/av47952931?p=38\n\n\n数据库部分继续用上次的表\n\n在基于xml的案例上修改（加上整合junit的部分，具体记录在笔记8）\npom.xml加上整合junit需要的依赖spring-testjunit版本4.12及以上\nbeans.xml名称空间需要修改在Spring文档中搜索xmlns:context（基于xml时是xmlns）找名称空间配置Service和Dao的部分可以不要了加上component-scan告知Spring在创建容器时要扫描的包\n实体类、接口没有变化\n业务层实现类AccountServiceImpl加注解@Service(“accountService”)变量accountDao上加注解，由于只有一个AccountDao，可以用@Autowired对应的set方法可以删掉\n持久层实现类AccountDaoImpl加注解@Repository(“accountDao”)runner同样用@Autowired，set方法删掉\n测试类改为整合junit的写法\n\n完整代码项目结构\n\npom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.coconutnut&lt;/groupId&gt;    &lt;artifactId&gt;day02_02_account_xml&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;!--    打成jar包--&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;!--    加入依赖--&gt;    &lt;dependencies&gt;        &lt;!--        spring--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;        &lt;/dependency&gt;    \t&lt;!--    \tspring整合junit--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;            &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--        dbutils--&gt;        &lt;dependency&gt;            &lt;groupId&gt;commons-dbutils&lt;/groupId&gt;            &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt;            &lt;version&gt;1.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--        mysql驱动--&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.16&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--        jdbc连接池--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.mchange&lt;/groupId&gt;            &lt;artifactId&gt;c3p0&lt;/artifactId&gt;            &lt;version&gt;0.9.5.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--    junit测试--&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\nbeans.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;context:annotation-config/&gt;    &lt;!--    告知Spring在创建容器时要扫描的包--&gt;    &lt;context:component-scan base-package=&quot;com.cc&quot;&gt;&lt;/context:component-scan&gt;    &lt;!--    配置QueryRunner（多例）--&gt;    &lt;bean id=&quot;runner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot; scope=&quot;prototype&quot;&gt;        &lt;!--        注入数据源（没有set方法，只能构造函数注入）--&gt;        &lt;constructor-arg name=&quot;ds&quot; ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;    &lt;!--    配置数据源--&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;!--        注入连接数据库的信息--&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/groot?characterEncoding=utf8&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;iamgroot&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n实体类Account.java\npackage com.cc.domain;import java.io.Serializable;/** * 账户的实体类 */public class Account implements Serializable &#123;    private Integer id;    private String name;    private Float money;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Float getMoney() &#123;        return money;    &#125;    public void setMoney(Float money) &#123;        this.money = money;    &#125;    @Override    public String toString() &#123;        return &quot;Account&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, money=&quot; + money +                &#x27;&#125;&#x27;;    &#125;&#125;\n业务层IAccountService.java\npackage com.cc.service;import com.cc.domain.Account;import java.util.List;/** * 账户的业务层接口 */public interface IAccountService &#123;    /**     * 增     * @param account     */    void createAccount(Account account);    /**     * 删     * @param accountId     */    void deleteAccount(Integer accountId);    /**     * 改     * @param account     */    void updateAccount(Account account);    /**     * 查一个     * @param accountId     * @return     */    Account retrieveAccountById(Integer accountId);    /**     * 查所有     * @return     */    List&lt;Account&gt; retrieveAllAccounts();&#125;\nAccountServiceImpl.java\npackage com.cc.service.impl;import com.cc.dao.IAccountDao;import com.cc.domain.Account;import com.cc.service.IAccountService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** * 账户的业务层实现类 */@Service(&quot;accountService&quot;)public class AccountServiceImpl implements IAccountService &#123;    @Autowired    private IAccountDao accountDao;    public void createAccount(Account account) &#123;        accountDao.createAccount(account);    &#125;    public void deleteAccount(Integer accountId) &#123;        accountDao.deleteAccount(accountId);    &#125;    public void updateAccount(Account account) &#123;        accountDao.updateAccount(account);    &#125;    public Account retrieveAccountById(Integer accountId) &#123;        return accountDao.retrieveAccountById(accountId);    &#125;    public List&lt;Account&gt; retrieveAllAccounts() &#123;        return accountDao.retrieveAllAccounts();    &#125;&#125;\n持久层IAccountDao.java\npackage com.cc.dao;import com.cc.domain.Account;import java.util.List;/** * 账户的持久层接口 */public interface IAccountDao &#123;    void createAccount(Account account);    void deleteAccount(Integer accountId);    void updateAccount(Account account);    Account retrieveAccountById(Integer accountId);    List&lt;Account&gt; retrieveAllAccounts();&#125;\nAccountDaoImpl.java\npackage com.cc.dao.impl;import com.cc.dao.IAccountDao;import com.cc.domain.Account;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;import java.sql.SQLException;import java.util.List;/** * 账户的持久层实现类 */@Repository(&quot;accountDao&quot;)public class AccountDaoImpl implements IAccountDao &#123;    @Autowired    private QueryRunner runner;    public void createAccount(Account account) &#123;        try &#123;            runner.update(&quot;insert into account(name,money) values(?,?)&quot;, account.getName(), account.getMoney());        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public void deleteAccount(Integer accountId) &#123;        try &#123;            runner.update(&quot;delete from account where id = ?&quot;, accountId);        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public void updateAccount(Account account) &#123;        try &#123;            runner.update(&quot;update account set name = ?, money = ? where id = ?&quot;, account.getName(), account.getMoney(),account.getId());        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public Account retrieveAccountById(Integer accountId) &#123;        try &#123;            return runner.query(&quot;select * from account where id = ?&quot;, new BeanHandler&lt;Account&gt;(Account.class), accountId);        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public List&lt;Account&gt; retrieveAllAccounts() &#123;        try &#123;            return runner.query(&quot;select * from account&quot;, new BeanListHandler&lt;Account&gt;(Account.class));        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\n测试方法AccountServiceTest.java\npackage com.cc.test;import com.cc.domain.Account;import com.cc.service.IAccountService;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.util.List;/** * 使用Junit测试配置 * Spring整合Junit的配置 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:beans.xml&quot;)public class AccountServiceTest &#123;    @Autowired    private IAccountService as;    @Test    public void testCreate()&#123;        Account account = new Account();        account.setName(&quot;eee&quot;);        account.setMoney(10000f);        as.createAccount(account);    &#125;    @Test    public void testDelete()&#123;        as.deleteAccount(1);    &#125;    @Test    public void testUpdate()&#123;        Account account = as.retrieveAccountById(3);        account.setMoney(3000f);        as.updateAccount(account);    &#125;    @Test    public void testRetrieveOne()&#123;        Account account = as.retrieveAccountById(1);        System.out.println(account);    &#125;    @Test    public void testRetrieveAll()&#123;        List&lt;Account&gt; accounts = as.retrieveAllAccounts();        for(Account account : accounts)&#123;            System.out.println(account);        &#125;    &#125;&#125;\n\n测试testRetrieveAll()\ntestRetrieveOne()\ntestCreate()\ntestDelete()\ntestUpdate()\n","categories":["Note"],"tags":["spring"]},{"title":"买卖股票的最佳时机问题","url":"/2020/02/29/exercise/","content":"思路：动态规划\ndp[ i ][ j ][ k ]i - 到第 i 天j - 最多交易 j 次k - 0:当前持股 / 1:当前不持股\n状态转移方程\n// 第i天，最多交易j次，当前不持股dp[i][j][0] = MAX&#123;\tdp[i-1][j][0],                 // 本次不持-上次就不持\tdp[i-1][j-1][1] + 差价          // 本次不持-本次卖&#125;// 第i天，最多交易j次，当前持股dp[i][j][1] = MAX&#123;\tdp[i-1][j][0],                // 本次持-本次买\tdp[i-1][j][1] + 差价           // 本次持-上次就持&#125;\n\n实现\npublic int getdp(int i,int j,int k,int[][][] dp,int[] prices)&#123;\tif(dp[i][j][k]==-1)&#123;\t\tif(i&lt;1)&#123;\t\t\tdp[i][j][0]=0;\t\t\tdp[i][j][1]=0;\t\t&#125;else&#123;\t\t\t// 本次不持-上次就不持\t\t\tint dp1 = getdp(i-1,j,0,dp,prices);\t\t\t// 本次不持-本次卖\t\t\tint dp2 = j&gt;0 ? getdp(i-1,j-1,1,dp,prices)+prices[i]-prices[i-1] : 0;\t\t\tdp[i][j][0] = Math.max(dp1,dp2);           \t\t\t// 本次持-本次买\t\t\tint dp3 = getdp(i-1,j,0,dp,prices);\t\t\t// 本次持-上次就持\t\t\tint dp4 = getdp(i-1,j,1,dp,prices)+prices[i]-prices[i-1];\t\t\tdp[i][j][1] = Math.max(dp3,dp4);            &#125;        &#125;\treturn dp[i][j][k];&#125;\n\n坑：当k很大时，内存会爆，此时相当于不限制交易次数，直接用贪心解决\nclass Solution &#123;    public int maxProfit(int k, int[] prices) &#123;        if(prices.length&lt;2)&#123;            return 0;        &#125;        if(k &gt; prices.length/2)&#123;            // 相当于不限制次数，贪心            int value = 0;            for(int i=1;i&lt;prices.length;i++)&#123;                value += prices[i]&gt;prices[i-1] ? prices[i]-prices[i-1] : 0;            &#125;            return value;        &#125;        int[][][] dp = new int[prices.length][k+1][2];        for(int i=0;i&lt;prices.length;i++)&#123;            for(int j=0;j&lt;k+1;j++)&#123;                Arrays.fill(dp[i][j],-1);            &#125;        &#125;        return getdp(prices.length-1,k,0,dp,prices);    &#125;    public int getdp(int i,int j,int k,int[][][] dp,int[] prices)&#123;...&#125;&#125;\n\n\n用这一套解法干掉4题\nLeetcode 121 买卖股票的最佳时机 —— 最多交易1次令 k = 1\nLeetcode 122 买卖股票的最佳时机 II —— 不限次数直接贪心\nLeetcode 123 买卖股票的最佳时机 III —— 最多交易2次令 k = 2\nLeetcode 188 买卖股票的最佳时机 IV —— 最多交易k次\n","categories":["Note"],"tags":["algorithm"]},{"title":"Vue笔记01 @vue_cli环境搭建","url":"/2020/03/06/note-vue-01/","content":"\n在经历了这么多坑之后终于build succeeded了\n可喜可贺\n整理下成功路径\n\n\n版本：\n\nmacOS Catalina 10.15.3\nHomebrew 2.2.6\nnode v13.8.0\nnpm 6.13.7\n@vue/cli 4.2.3\n\n\n1. 安装nodebrew install node\n坑：brew巨慢无比解决：换清华镜像\n\nhttps://mirrors.tuna.tsinghua.edu.cn/help/homebrew/\n\n2. 安装@vue/clisudo npm install -g @vue/cli\n坑：没有权限解决：sudo\n\nhttps://www.jianshu.com/p/0207ee424422\n\n坑：新旧版本名字不一样解决：@vue/cli（不是vue-cli）\n\nhttps://cli.vuejs.org/zh/guide/installation.html\n\n3. 创建项目vue ui\n\n\n\n","categories":["Note"],"tags":["vue"]},{"title":"Spring笔记08 Spring整合Junit","url":"/2020/03/04/note-spring-08/","content":"\nhttps://www.bilibili.com/video/av47952931p44～45 \n\n\n用于解决之前测试时的重复代码\n原本的AccountServiceTest中，每个方法中都有步骤1和2\npublic class AccountServiceTest &#123;    @Test    public void testCreate()&#123;        // 1.获取容器        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        // 2.得到业务层对象        IAccountService as = ac.getBean(&quot;accountService&quot;,IAccountService.class);        // 3.执行方法        Account account = new Account();        account.setName(&quot;eee&quot;);        account.setMoney(10000f);        as.createAccount(account);    &#125;    @Test    public void testDelete()&#123;        // 1.获取容器        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        // 2.得到业务层对象        IAccountService as = ac.getBean(&quot;accountService&quot;,IAccountService.class);        // 3.执行方法        as.deleteAccount(1);    &#125;&#125;\n\n使用init()可以将重复代码抽出来\npublic class AccountServiceTest &#123;    private ApplicationContext ac;    private IAccountService as;    @Before    public void init()&#123;        // 1.获取容器        ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        // 2.得到业务层对象        as = ac.getBean(&quot;accountService&quot;,IAccountService.class);    &#125;    @Test    public void testCreate()&#123;        Account account = new Account();        account.setName(&quot;eee&quot;);        account.setMoney(10000f);        as.createAccount(account);    &#125;    @Test    public void testDelete()&#123;        as.deleteAccount(1);    &#125;&#125;\n\n但是并没有根本上解决问题开发和测试的代码仍在一个类中，需要进一步解耦\n如果不要init()，只在变量上加@Autowired没有用一波分析：\n解决方法：\n\npom.xml中导入spring整合junit的依赖\n&lt;dependency&gt;\t&lt;groupId&gt;org.springframework&lt;/groupId&gt;\t&lt;artifactId&gt;spring-test&lt;/artifactId&gt;\t&lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n且：使用spring 5.x时，juint需要4.12以上的版本\n\n使用junit的@RunWith注解将原有的main()替换成spring提供的\n\n用@ContextConfiguration告知spring的运行器，基于xml还是注解，并说明位置locations：指定xml文件的位置，加上classpath关键字，表示在类路径下classes：指定注释类所在的位置\n\n\n@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:beans.xml&quot;)public class AccountServiceTest &#123;    @Autowired    private IAccountService as;\t\t@Test    public void testCreate()&#123;        Account account = new Account();        account.setName(&quot;eee&quot;);        account.setMoney(10000f);        as.createAccount(account);    &#125;&#125;\n\n即可正常执行\n","categories":["Note"],"tags":["spring"]},{"title":"Spring笔记09 事务控制的问题&动态代理","url":"/2020/03/09/note-spring-09/","content":"\nhttps://www.bilibili.com/video/av47952931p46~55\n\n\nAccount案例中转账方法的事务问题\n\n事务控制应该都在业务层，之前的案例中都在持久层，需要修改写两个工具类\n2个工具类ConnectionUtils/** * 连接的工具类，它用于从数据源中获取一个连接，并且实现和线程的绑定 */public class ConnectionUtils &#123;    private ThreadLocal&lt;Connection&gt; tl = new ThreadLocal&lt;Connection&gt;();    private DataSource dataSource;    public void setDataSource(DataSource dataSource) &#123;        this.dataSource = dataSource;    &#125;    /**     * 获取当前线程上的连接     * @return     */    public Connection getThreadConnection() &#123;        try&#123;            // 1.先从ThreadLocal上获取            Connection conn = tl.get();            // 2.判断当前线程上是否有连接            if (conn == null) &#123;                // 3.从数据源中获取一个连接，并且存入ThreadLocal中                conn = dataSource.getConnection();                tl.set(conn);            &#125;            // 4.返回当前线程上的连接            return conn;        &#125;catch (Exception e)&#123;            throw new RuntimeException(e);        &#125;    &#125;    /**     * 把连接和线程解绑     */    public void removeConnection()&#123;        tl.remove();    &#125;&#125;\nTransactionManager/** * 和事务管理相关的工具类，它包含了，开启事务，提交事务，回滚事务和释放连接 */public class TransactionManager &#123;    private ConnectionUtils connectionUtils;    public void setConnectionUtils(ConnectionUtils connectionUtils) &#123;        this.connectionUtils = connectionUtils;    &#125;    /**     * 开启事务     */    public  void beginTransaction()&#123;        try &#123;            connectionUtils.getThreadConnection().setAutoCommit(false);        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;    /**     * 提交事务     */    public  void commit()&#123;        try &#123;            connectionUtils.getThreadConnection().commit();        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;    /**     * 回滚事务     */    public  void rollback()&#123;        try &#123;            connectionUtils.getThreadConnection().rollback();        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;    /**     * 释放连接     */    public  void release()&#123;        try &#123;            connectionUtils.getThreadConnection().close();// 还回连接池中            connectionUtils.removeConnection();        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;\n连接还回连接池中后，还需再把连接和线程解绑，否则下次ConnectionUtils中判断是否有连接是true，但这个连接是已经关闭的错误的连接\n注入&lt;!-- 配置Connection的工具类 ConnectionUtils --&gt;   &lt;bean id=&quot;connectionUtils&quot; class=&quot;com.itheima.utils.ConnectionUtils&quot;&gt;       &lt;!-- 注入数据源--&gt;       &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;   &lt;/bean&gt;   &lt;!-- 配置事务管理器--&gt;   &lt;bean id=&quot;txManager&quot; class=&quot;com.itheima.utils.TransactionManager&quot;&gt;       &lt;!-- 注入ConnectionUtils --&gt;       &lt;property name=&quot;connectionUtils&quot; ref=&quot;connectionUtils&quot;&gt;&lt;/property&gt;   &lt;/bean&gt;\n代码改造修改之后不需要在beans.xml中注入dataSource了\n&lt;!-- 配置Connection的工具类 ConnectionUtils --&gt;&lt;bean id=&quot;connectionUtils&quot; class=&quot;com.itheima.utils.ConnectionUtils&quot;&gt;    &lt;!-- 注入数据源--&gt;    &lt;!-- property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property--&gt;&lt;/bean&gt;\n在AccountDaoImpl中加一个ConnectionUtils\nprivate ConnectionUtils connectionUtils;public void setConnectionUtils(ConnectionUtils connectionUtils) &#123;     this.connectionUtils = connectionUtils;&#125;\n并且runner获取连接改为\nrunner.query(connectionUtils.getThreadConnection(),&quot;select * from account&quot;,new BeanListHandler&lt;Account&gt;(Account.class));\n此时，AccountServiceImpl中一个完整的事务流程是\npublic List&lt;Account&gt; findAllAccount() &#123;        try &#123;            // 1.开启事务            txManager.beginTransaction();            // 2.执行操作            List&lt;Account&gt; accounts = accountDao.findAllAccount();            // 3.提交事务            txManager.commit();            // 4.返回结果            return accounts;        &#125;catch (Exception e)&#123;            // 5.回滚操作            txManager.rollback();            throw new RuntimeException(e);        &#125;finally &#123;            // 6.释放连接            txManager.release();        &#125;&#125;\n但是每个方法都要这样写，很臃肿而且方法的依赖很严重（如果TransactionManager中beginTransaction方法名改成beginTransaction1，AccountServiceImpl中每一处用到的都要改）进一步改造：代理\n&amp; 现在的依赖有些乱七八糟，在后面Spring的事务控制中解决\n动态代理描述\n\n特点：字节码随用随创建，随用随加载作用：不修改源码的基础上对方法增强\n分类：\n\n基于接口的动态代理\n基于子类的动态代理\n\n用处如：连接池close方法关闭时不能真正关闭，还要还回池中。可以使用动态代理对其进行增强，把它还回池里解决中文乱码，request对象的方法增强，用装饰者模式可以实现，也可以用动态代理实现\n基于接口的动态代理涉及的类：Proxy提供者：JDK官方如何创建代理对象：使用Proxy类中的newProxyInstance方法创建代理对象的要求：被代理类最少实现一个接口，如果没有则不能使用\nnewProxyInstance方法的参数：\n\nClassLoader：类加载器它是用于加载代理对象字节码的。和被代理对象使用相同的类加载器。固定写法\nClass[]：字节码数组它是用于让代理对象和被代理对象有相同方法。固定写法\nInvocationHandler：用于提供增强的代码写如何代理。一般都是写一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。此接口的实现类都是谁用谁写\n\n示例\n\n/** * 对生产厂家要求的接口 */public interface IProducer &#123;    /**     * 销售     * @param money     */    public void saleProduct(float money);    /**     * 售后     * @param money     */    public void afterService(float money);&#125;\n/** * 一个生产者 */public class Producer implements IProducer&#123;    public void saleProduct(float money)&#123;        System.out.println(&quot;销售产品，并拿到钱：&quot;+money);    &#125;        public void afterService(float money)&#123;        System.out.println(&quot;提供售后服务，并拿到钱：&quot;+money);    &#125;    &#125;\n\n/** * 模拟一个消费者 */public class Client &#123;    public static void main(String[] args) &#123;        final Producer producer = new Producer();        IProducer proxyProducer = (IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(),                producer.getClass().getInterfaces(),                new InvocationHandler() &#123;                    /**                     * 作用：执行被代理对象的任何接口方法都会经过该方法（即有拦截功能）                     * 方法参数的含义                     * @param proxy   代理对象的引用                     * @param method  当前执行的方法                     * @param args    当前执行方法所需的参数                     * @return        和被代理对象方法有相同的返回值                     * @throws Throwable                     */                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                        // 接收返回值                        Object returnValue = null;                        // 1.获取方法执行的参数                        Float money = (Float)args[0];                        // 2.判断当前方法是不是销售                        if(&quot;saleProduct&quot;.equals(method.getName())) &#123;                            returnValue = method.invoke(producer, money*0.8f);                        &#125;                        return returnValue;                    &#125;                &#125;);        \tproxyProducer.saleProduct(10000f);    &#125;&#125;\n\n\n使用代理后，消费者付10000，代理提成20%，生产者拿到8000\n并没有对生产者的代码做任何修改，但是实现了增强此处即为基于接口的动态代理\n但是有一个问题如果生产者没有实现接口，就不能这样用了，会报代理异常\n基于子类的动态代理要求有第三方jar包的支持\n&lt;dependencies&gt;\t&lt;dependency&gt;\t\t&lt;groupId&gt;cglib&lt;/groupId&gt;\t\t&lt;artifactId&gt;cglib&lt;/artifactId&gt;\t\t&lt;version&gt;2.1_3&lt;/version&gt;\t&lt;/dependency&gt;&lt;/dependencies&gt;\n\n涉及的类：Enhancer提供者：第三方cglib库\n如何创建代理对象：使用Enhancer类中的create方法创建代理对象的要求：被代理类不能是最终类\ncreate方法的参数：\n\nClass：字节码用于指定被代理对象的字节码\nCallback：用于提供增强的代码写如何代理。一般是写一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的此接口的实现类都是谁用谁写一般写的都是该接口的子接口实现类：MethodInterceptor\n\n示例/** * 一个生产者 */public class Producer &#123;    /**     * 销售     * @param money     */    public void saleProduct(float money)&#123;        System.out.println(&quot;销售产品，并拿到钱：&quot;+money);    &#125;    /**     * 售后     * @param money     */    public void afterService(float money)&#123;        System.out.println(&quot;提供售后服务，并拿到钱：&quot;+money);    &#125;&#125;\npackage com.itheima.cglib;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;/** * 模拟一个消费者 */public class Client &#123;    public static void main(String[] args) &#123;        final Producer producer = new Producer();        Producer cglibProducer = (Producer)Enhancer.create(producer.getClass(), new MethodInterceptor() &#123;            /**             * 执行被代理对象的任何方法都会经过该方法             * @param proxy             * @param method             * @param args             *    以上三个参数和基于接口的动态代理中invoke方法的参数是一样的             * @param methodProxy ：当前执行方法的代理对象             * @return             * @throws Throwable             */            @Override            public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;                Object returnValue = null;                // 1.获取方法执行的参数                Float money = (Float)args[0];                // 2.判断当前方法是不是销售                if(&quot;saleProduct&quot;.equals(method.getName())) &#123;                    returnValue = method.invoke(producer, money*0.8f);                &#125;                return returnValue;            &#125;        &#125;);        cglibProducer.saleProduct(12000f);    &#125;&#125;\n使用动态代理实现事务控制/** * 用于创建Service的代理对象的工厂 */public class BeanFactory &#123;    private IAccountService accountService;    private TransactionManager txManager;        public final void setAccountService(IAccountService accountService) &#123;        this.accountService = accountService;    &#125;        public void setTxManager(TransactionManager txManager) &#123;        this.txManager = txManager;    &#125;    /**     * 获取Service代理对象     * @return     */    public IAccountService getAccountService() &#123;        return (IAccountService)Proxy.newProxyInstance(accountService.getClass().getClassLoader(),                accountService.getClass().getInterfaces(),                new InvocationHandler() &#123;                    /**                     * 添加事务的支持                     *                     * @param proxy                     * @param method                     * @param args                     * @return                     * @throws Throwable                     */                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                        if(&quot;test&quot;.equals(method.getName()))&#123;                            return method.invoke(accountService,args);                        &#125;                        Object rtValue = null;                        try &#123;                            // 1.开启事务                            txManager.beginTransaction();                            // 2.执行操作                            rtValue = method.invoke(accountService, args);                            // 3.提交事务                            txManager.commit();                            // 4.返回结果                            return rtValue;                        &#125; catch (Exception e) &#123;                            // 5.回滚操作                            txManager.rollback();                            throw new RuntimeException(e);                        &#125; finally &#123;                            // 6.释放连接                            txManager.release();                        &#125;                    &#125;                &#125;);    &#125;&#125;\n并对beans.xml做相应的修改测试中IAccountService只用Autowird不够了，还需@Qualifier(“proxyAccountService”)\n使用动态代理后，消除了重复代码，解除了方法的依赖但是配置变得繁琐了更好的方式？——&gt;AOP\n","categories":["Note"],"tags":["spring"]},{"title":"Vue笔记02 Spring Boot+Vue前后端分离开发基本流程","url":"/2020/03/06/note-vue-02/","content":"\nhttps://www.bilibili.com/video/av85793766?p=1\n\n\nVue工程创建vue ui创建工程，导入Idea(js版本太低可能有语法报错，配置中改为6即可)\n启动：npm run serve停止：ctrl+C\n引入页面&amp;配置路径router/index.js中引入.vueApp.vue中配置router\nBook.vuetemplate就是html，script就是js，style就是csstemplate中只允许有一个根节点前端可以先用假数据，写在script里面\n&lt;template&gt;    &lt;div id=&quot;showcase&quot;&gt;        &lt;table&gt;            &lt;tr&gt;                &lt;td&gt;编号&lt;/td&gt;                &lt;td&gt;名称&lt;/td&gt;                &lt;td&gt;作者&lt;/td&gt;            &lt;/tr&gt;            &lt;tr v-for=&quot;item in books&quot;&gt;                &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt;                &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt;                &lt;td&gt;&#123;&#123;item.author&#125;&#125;&lt;/td&gt;            &lt;/tr&gt;        &lt;/table&gt;        &#123;&#123;msg&#125;&#125;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name: &quot;Book&quot;,        data()&#123;            return&#123;                msg:&#x27;2019999999999999&#x27;,                books:[                    &#123;                        id: 20200001,                        name: &#x27;病毒星球&#x27;,                        author: &#x27;卡尔·齐默&#x27;                    &#125;,                    &#123;                        id:20200002,                        name: &#x27;洛基启示录&#x27;,                        author: &#x27;乔安妮·M·哈里斯&#x27;                    &#125;,                    &#123;                        id:20200003,                        name: &#x27;增强人类&#x27;,                        author: &#x27;海伦·帕帕扬尼斯&#x27;                    &#125;                ]            &#125;        &#125;    &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;\nvue可以动态加载，改完代码不需要重启，直接访问即可试了下可以正常访问～\nSpring工程创建Idea中Spring Initializr默认模版创建依赖勾上：Lombok、Spring Web、Spring Data JPA、MySQL Driver\n配置文件这里没有用application.properties，删掉新建application.yml，存放连接数据库的信息\n数据库建表用提供的book.sql建book表\nBook和book表对应，加@Entity后，根据类名和表名对应绑定再加一个@Data，是lombok的注解，自动生成get/set属性名和变量名对应，自动绑定id要加一个@Id，它是主键\n@Entity@Datapublic class Book &#123;    @Id    private Integer id;    private String name;    private String author;&#125;\nBookRepository继承JpaRepository，&lt;&gt;中第一个是实体类，第二个是主键类型接口中findAll等方法都有，直接用就行\npublic interface BookRepository extends JpaRepository&lt;Book,Integer&gt; &#123;&#125;\n\n测试BookRepository然后测试一下建立的Spring工程自带一个测试类BookstoreServerApplicationTests或者自己创建，在接口名上右键-&gt;Go To-&gt;Test-&gt;Create New Test给生成的测试类加一个@SpringBootTest，要测试的类@Autowired自动注入，写的方法加一个@Test，就可以运行了\n@SpringBootTestclass BookRepositoryTest &#123;    @Autowired    private BookRepository bookRepository;    @Test    void findAll()&#123;        System.out.println(bookRepository.findAll());    &#125;&#125;\n试一下成功且打印了sql语句，因为yml里面配了jpa: show-sql: true和格式化\n每写一个repository先测一下，保证没问题再继续写controller\nBookHandler配上对应的注解和mapping\n@RestController@RequestMapping(&quot;/book&quot;)public class BookHandler &#123;    @Autowired    private BookRepository bookRepository;    @GetMapping(&quot;/findAll&quot;)    public List&lt;Book&gt; findAll()&#123;        return bookRepository.findAll();    &#125;&#125;\n测试运行BookstoreServerApplication启动类注意此时端口是8181没有问题，后端就搞定了接下来前后端对接就行\n对接vue中ajax请求用axios组件（先在命令行把服务停掉，安装，vue add axios）装好之后自动有了src/plugins/axios.js\n刷新页面时读取数据，可以写到初始化函数中，比如这样：\n&lt;script&gt;    export default &#123;\t\tcreated() &#123;            alert(123)            axios.get(&#x27;http://localhost:8181/book/findAll/&#x27;).then(function (resp)&#123;                console.log(resp)            &#125;)        &#125;    &#125;&lt;/script&gt;\n刷新，看浏览器的控制台有个跨域问题（8181访问8080），前端后端都可以解决这里在SpringBoot中解决只需添加一个配置类，重写addCorsMappings方法即可（不用记，固定的，要用的时候复制就行）\n@Configurationpublic class CrosConfig implements WebMvcConfigurer &#123;    @Override    public void addCorsMappings(CorsRegistry registry) &#123;        registry.addMapping(&quot;/**&quot;)                .allowedOrigins(&quot;*&quot;)                .allowedMethods(&quot;GET&quot;, &quot;HEAD&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;)                .allowCredentials(true)                .maxAge(3600)                .allowedHeaders(&quot;*&quot;);    &#125;&#125;\n重启，再访问就好了然后再回调函数中把data拿到就行注意：不能直接用this，回调函数中this指的是回调，而不是外面，要先在外面拿到this\n&lt;template&gt;    &lt;div id=&quot;showcase&quot;&gt;        &lt;table&gt;            &lt;tr&gt;                &lt;td&gt;编号&lt;/td&gt;                &lt;td&gt;名称&lt;/td&gt;                &lt;td&gt;作者&lt;/td&gt;            &lt;/tr&gt;            &lt;tr v-for=&quot;item in books&quot;&gt;                &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt;                &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt;                &lt;td&gt;&#123;&#123;item.author&#125;&#125;&lt;/td&gt;            &lt;/tr&gt;        &lt;/table&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name: &quot;Book&quot;,        data()&#123;            return&#123;                books:[]            &#125;        &#125;,        created() &#123;            const _this = this            axios.get(&#x27;http://localhost:8181/book/findAll&#x27;).then(function (resp)&#123;                _this.books = resp.data            &#125;)        &#125;    &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;\n这样前后端就连上了\n总结\n写前端，用加数据测试\n写后端，保证接口能访问\n调后端（后端解决跨域问题）\n\n","categories":["Note"],"tags":["vue"]},{"title":"一些有趣的网站","url":"/2020/03/10/bookmark/","content":"配色中国色中国传统颜色，每一个都有CMYK、RGB值(包括16进制字符串形式～好用！)#5dbe8a 超爱的蔻梢绿～\nbrandcolors品牌配色，可以发现各种眼熟的颜色\n这是百度这是NASA这是谷歌这是微软那么问题来了，它们是谁？\n我是答案\nwebgradients一颗一颗超仙的渐变色，也可以全屏查看，舒适\nuigradients也是美丽的渐变色\nLOLCOLORS水滴形的配色\n色轮adobe出品，不会用，但是很好玩\nColordot这个也很有趣！挪动光标调色，点击固定\n图标thenounproject常用的图标网站\n\n\n\n\n设计dribbble\n\ncodrops发现酷炫的页面\n\n\n","categories":["Memo"]},{"title":"来到Hexo的第一天！","url":"/2020/03/10/hello-hexo/","content":"从下午开始搭建，调主题，一直到晚上搬运完了正在写的笔记，心情舒畅\n先尝试的是Jekyll，我的老天鹅啊，折腾了一整天，不是配置有问题就是资源有问题，本地好不容易成功了提交到github又崩了，build成功了css又不渲染…您是Hyde吧\n总之，现在拥有一个带侧边栏目录的小仓库了～\n开启探索进度条[|||||·············································]10%\n(deprecated)老家\n","categories":["Memo"]},{"title":"Android 10 写文件权限问题","url":"/2020/03/12/debug-android/","content":"bug描述换手机之后一个以前没毛病的写文件操作写不了了估摸着是版本问题\n解决方法AndroidManifest.xml中，application标签中加\nandroid:requestLegacyExternalStorage=&quot;true&quot;\n\n\nref:https://blog.csdn.net/weixin_40093242/article/details/104067573?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task\n\n","categories":["Debug"]},{"title":"LeetCode.337 打家劫舍","url":"/2020/03/12/exercise/","content":"题目地址\n\n暴力抢劫写出来倒是挺快，结果发现时间爆炸\nclass Solution &#123;    public int rob(TreeNode root) &#123;        return Math.max(find(root,true),find(root,false));    &#125;    public int find(TreeNode root, boolean isGap)&#123;        if(root==null)&#123;            return 0;        &#125;        int ret = 0;        if(!isGap)&#123;            // 本层抢，下层不能抢            ret+=root.val;            ret+=find(root.left,false);            ret+=find(root.right,false);        &#125;else&#123;            int next1 = Math.max(find(root.left,true),find(root.left,false));            int next2 = Math.max(find(root.right,true),find(root.right,false));            ret = next1 + next2;        &#125;                return ret;    &#125;&#125;\n\n执行用时：2817 ms内存消耗：39.3 MB\n\n这样写每次都递归找了至少2次、甚至4次子节点\n相当于把二叉树省下来的log又给翻倍乘回去了\n机智的劫匪看了题解中一次返回2种情况，修改一下\nclass Solution &#123;    public int rob(TreeNode root) &#123;        int[] ans = find(root);        return Math.max(ans[0],ans[1]);    &#125;    public int[] find(TreeNode root)&#123;        // ret0-本层不抢；ret1-本层抢        int[] ret = new int[2];        if(root==null)&#123;            return ret;        &#125;                int[] left = find(root.left);        int[] right = find(root.right);                // 下层爱抢不抢        ret[0] = Math.max(left[0],left[1]) + Math.max(right[0],right[1]);        // 下层不能抢        ret[1] = root.val + left[0] + right[0];                return ret;    &#125;&#125;\n\n执行用时：1 ms内存消耗：41.6 MB\n\n这样就只遍历了1次\n总结递归中如果要分情况讨论，一次返回多个结果，不要多次调用递归\n","categories":["Note"],"tags":["algorithm"]},{"title":"Vue笔记03 Element UI使用&动态路由导航栏","url":"/2020/03/11/note-vue-03/","content":"\nhttps://www.bilibili.com/video/av85793766p2~3\n\n安装和上次一样创建项目，在vue ui中添加Element UI插件\nIdea中导入工程\n如果插件在刚才UI中没有装成功，可以在命令行装\n使用Element UI的使用可以看官网手册\nElemnt UI 中文官网\n\n有一些常见的布局方式\n导入实例直接把官网实例复制到App.vue中（html复制到div标签之间）\n刷新网页就能看到效果\n一些标签说明el-container: 构建整个⻚面框架\nel-menu: 左侧菜单\n// :default-openeds默认展开的菜单 :default-active默认选中的菜单&lt;el-menu :default-openeds=&quot;[&#x27;1&#x27;, &#x27;3&#x27;]&quot; :default-active=&quot;1-2&quot;&gt;\n\n视频里说这个”1-2”必须写成”[1-2]”或则”‘1-2’”才能识别\n但是试了一下直接写也识别了\nel-submenu: 可展开的菜单\n// 菜单的下标，文本类型，不能是数值类型&lt;el-submenu index=&quot;1&quot;&gt;  // template:对应 el-submenu 的菜单名 i:设置菜单图标，具体在文档找\t&lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-message&quot;&gt;&lt;/i&gt;导航一&lt;/template&gt;\n\n需要的话还可以嵌套多级submenu\n通过vue router动态构建左侧菜单配置页面新建4个页面，在router中配置\nimport Page1 from &#x27;../views/Page1&#x27;import Page2 from &#x27;../views/Page2&#x27;import Page3 from &#x27;../views/Page3&#x27;import Page4 from &#x27;../views/Page4&#x27;const routes = [  &#123;    path: &#x27;/page1&#x27;,    name: &#x27;页面1&#x27;,    component: Page1  &#125;,  &#123;    path: &#x27;/page2&#x27;,    name: &#x27;页面2&#x27;,    component: Page2  &#125;,  &#123;    path: &#x27;/page3&#x27;,    name: &#x27;页面3&#x27;,    component: Page3  &#125;,  &#123;    path: &#x27;/page4&#x27;,    name: &#x27;页面4&#x27;,    component: Page4  &#125;,]\n\n但是这样还不会显示，要在App.vue中加上router对应的页面\n        ...      &lt;/el-container&gt;    &lt;/el-container&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;\n\n\n\n此时相当于App中的内容是本来就显示的，下面的view是附加上去的\n这样放显然是有问题的\n把它放到main里面\n\t\t\t\t...\t\t\t\t&lt;el-main&gt;          &lt;router-view&gt;&lt;/router-view&gt;        &lt;/el-main&gt;      &lt;/el-container&gt;    &lt;/el-container&gt;  &lt;/div&gt;&lt;/template&gt;\n\n\n\n这样就放进去了，下一步把它们连上\n遍历router需要修改router的层级结构\nconst routes = [  &#123;    path: &#x27;/&#x27;,    name: &#x27;导航1&#x27;,    component:App,    children:[      &#123;        path: &#x27;/page1&#x27;,        name: &#x27;页面1&#x27;,        component: Page1      &#125;,      &#123;        path: &#x27;/page2&#x27;,        name: &#x27;页面2&#x27;,        component: Page2      &#125;,    ]  &#125;,  &#123;    path:&#x27;/navigation&#x27;,    name: &#x27;导航2&#x27;,    component:App,    children:[      &#123;        path: &#x27;/page3&#x27;,        name: &#x27;页面3&#x27;,        component: Page3      &#125;,      &#123;        path: &#x27;/page4&#x27;,        name: &#x27;页面4&#x27;,        component: Page4      &#125;,    ]  &#125;,]\n\n然后在App.vue中读取\n&lt;el-aside width=&quot;200px&quot; style=&quot;background-color: rgb(238, 241, 246)&quot;&gt;   &lt;el-menu&gt;       &lt;el-submenu v-for=&quot;item in $router.options.routes&quot;&gt;          &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt;&#123;&#123;item.name&#125;&#125;&lt;/template&gt;       &lt;/el-submenu&gt;   &lt;/el-menu&gt;&lt;/el-aside&gt;\n\n就显示出来了\n\n\n\n一个小bug\n页面一开始是空白的，发现是App没有引入，router中要加\nimport App from &#x27;vue-router&#x27;\n\n\n把内层的元素也读出来\n现在点一个导航时，两个会一起展开、合上，因为没有加index\n再加上index属性（通过item的下标，item在前，index在后），需要字符串属性，拼一个’’\n&lt;el-aside width=&quot;200px&quot; style=&quot;background-color: rgb(238, 241, 246)&quot;&gt;        &lt;el-menu&gt;          &lt;el-submenu v-for=&quot;(item,index) in $router.options.routes&quot; :index=&quot;index+&#x27;&#x27;&quot;&gt;            &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt;&#123;&#123;index&#125;&#125;-&#123;&#123;item.name&#125;&#125;&lt;/template&gt;            &lt;el-menu-item v-for=&quot;(item2,index2) in item.children&quot; :index=&quot;index+&#x27;-&#x27;+index2&quot;&gt;&#123;&#123;item2.name&#125;&#125;&lt;/el-menu-item&gt;          &lt;/el-submenu&gt;        &lt;/el-menu&gt;&lt;/el-aside&gt;\n\n就可以定位到每一个了\n\n\nmenu与router绑定把App中的内容放到Index页面中\n1、给 el-menu 标签添加 router 属性\n2、在⻚面中添加 router-view 标签（它是一个容器，可以动态渲染选择的router）\n3、el-menu-item 标签的 index 值就是要跳转的 router\n默认页面，在router中写redirect\n并初始化选中，如果选择则加is-active状态。用route.path获取当前路径\n\n\n总结文件结构\n\nApp.vue&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;&lt;!--    这个router对应的即为/，也就是Index页面--&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;\n\nIndex.vue&lt;template&gt;    &lt;el-container style=&quot;height: 500px; border: 1px solid #eee&quot;&gt;        &lt;el-aside width=&quot;200px&quot; style=&quot;background-color: rgb(238, 241, 246)&quot;&gt;&lt;!--            这里添加router标签，el-menu-item的index就会被作为router路径--&gt;            &lt;el-menu router :default-openeds=&quot;[&#x27;0&#x27;,&#x27;1&#x27;]&quot;&gt;                &lt;el-submenu v-for=&quot;(item,index) in $router.options.routes&quot; :index=&quot;index+&#x27;&#x27;&quot;&gt;                    &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt;&#123;&#123;index&#125;&#125;-&#123;&#123;item.name&#125;&#125;&lt;/template&gt;&lt;!--                    条件判断当前路径是否等于index，更改选中状态，主要是在初始化时增加默认的选中状态--&gt;                    &lt;el-menu-item v-for=&quot;item2 in item.children&quot; :index=&quot;item2.path&quot; :class=&quot;$route.path==item2.path ? &#x27;is-active&#x27; : &#x27;&#x27;&quot;&gt;&#123;&#123;item2.path&#125;&#125;-&#123;&#123;item2.name&#125;&#125;&lt;/el-menu-item&gt;                &lt;/el-submenu&gt;            &lt;/el-menu&gt;        &lt;/el-aside&gt;        &lt;el-main&gt;&lt;!--            上面又index确定的router被显示在这里，也就是main区域中--&gt;            &lt;router-view&gt;&lt;/router-view&gt;        &lt;/el-main&gt;    &lt;/el-container&gt;&lt;/template&gt;\n\nindex.jsconst routes = [  &#123;    path: &#x27;/&#x27;,    name: &#x27;导航1&#x27;,    component:Index,    redirect:&#x27;page1&#x27;,    children:[      &#123;        path: &#x27;/page1&#x27;,        name: &#x27;页面1&#x27;,        component: Page1      &#125;,      &#123;        path: &#x27;/page2&#x27;,        name: &#x27;页面2&#x27;,        component: Page2      &#125;,    ]  &#125;,  &#123;    path:&#x27;/navigation&#x27;,    name: &#x27;导航2&#x27;,    component:Index,    children:[      &#123;        path: &#x27;/page3&#x27;,        name: &#x27;页面3&#x27;,        component: Page3      &#125;,      &#123;        path: &#x27;/page4&#x27;,        name: &#x27;页面4&#x27;,        component: Page4      &#125;,    ]  &#125;,]\n\n注意区别：router/route/routes\n","categories":["Note"],"tags":["vue"]},{"title":"Spring笔记10 AOP","url":"/2020/03/12/note-spring-10/","content":"\nhttps://www.bilibili.com/video/av47952931p56~65\n\n\nAOP概述Aspect Oriented Programming 面向切面编程\n\n扩展功能不通过修改源代码实现\n\nAOP采取横向抽取机制，取代了传统的纵向继承体系重复性代码\n\n底层使用动态代理方法实现\n\n有接口时，使用jdk动态代理，创建和接口实现平级的代理对象\n无接口时，使用cglib动态代理，创建类的子类的代理对象\n\n\n\n作用及优势作用：\n\n在程序运行期间，不修改源码对已有方法进行增强\n\n优势：\n\n减少重复代码\n提高开发效率\n维护方便\n\nSpring中的AOP相关术语Joinpoint 连接点类中可以被增强的方法\nPointcut 切入点类中实际增强的方法\nAdvice 通知/增强切入点上扩展的功能\n\n前置增强：在方法之前执行\n后置增强：在方法正常执行之后执行\n最终增强：在最后执行，无论是否有异常\n环绕增强：在之前和之后执行\n异常增强：方法出现异常时执行\n\nIntroduction 引介一种特殊的增强，在不修改类代码的前提下，可以在运行期间为类动态地添加一些方法或Field\nTarget 目标对象要增强的类\nWeaving 织入把增强应用到目标对象的过程\nProxy 代理一个类被AOP织入增强后，就产生一个结果代理类\nAspect 切面切入点 + 通知/引介\nSpring基于XML的AOP配置配置步骤\n配置增强Bean\n\n使用aop:config标签表明开始AOP的配置\n\n使用aop:aspect标签表明配置切面\nid属性：是给切面提供一个唯一标识ref属性：是指定通知类bean的Id\n\n在aop:aspect标签的内部使用对应标签来配置通知的类型\naop:before：表示配置前置通知（实例中让printLog方法在切入点方法前执行）method属性：用于指定类中哪个方法是前置通知pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强\n\n\n切入点表达式的写法：\t关键字：execution(表达式)\t表达式：\t\t访问修饰符  返回值  包名.包名.包名...类名.方法名(参数列表)\t\t\t标准的表达式写法：\t\tpublic void com.itheima.service.impl.AccountServiceImpl.saveAccount()\t访问修饰符可以省略\t\tvoid com.itheima.service.impl.AccountServiceImpl.saveAccount()\t返回值可以使用通配符，表示任意返回值\t\t* com.itheima.service.impl.AccountServiceImpl.saveAccount()\t包名可以使用通配符，表示任意包。但是有几级包，就需要写几个*.\t\t* *.*.*.*.AccountServiceImpl.saveAccount())\t包名可以使用..表示当前包及其子包\t\t* *..AccountServiceImpl.saveAccount()\t类名和方法名都可以使用*来实现通配\t\t* *..*.*()\t参数列表：\t\t可以直接写数据类型：\t\t\t基本类型直接写名称           int\t\t\t引用类型写包名.类名的方式   java.lang.String\t\t\t可以使用通配符表示任意类型，但是必须有参数\t\t\t可以使用..表示有无参数均可，有参数可以是任意类型\t全通配写法：\t\t* *..*.*(..)\t实际开发中切入点表达式的通常写法：\t\t切到业务层实现类下的所有方法\t\t\t* com.itheima.service.impl.*.*(..)\n\n示例xml配置在Spring Framework Documentation的Core中搜索xmlns:aop，导入约束\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!-- 配置srping的Ioc,把service对象配置进来--&gt;    &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;       &lt;!-- 配置Logger类 --&gt;    &lt;bean id=&quot;logger&quot; class=&quot;com.itheima.utils.Logger&quot;&gt;&lt;/bean&gt;    &lt;!--配置AOP--&gt;    &lt;aop:config&gt;        &lt;!--配置切面 --&gt;        &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt;            &lt;!-- 配置通知的类型，并且建立通知方法和切入点方法的关联--&gt;            &lt;aop:before method=&quot;printLog&quot; pointcut=&quot;execution(* com.itheima.service.impl.*.*(..))&quot;&gt;&lt;/aop:before&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;&lt;/beans&gt;\n\n业务层/** * 账户的业务层接口 */public interface IAccountService &#123;    // 模拟保存账户 无返回值无参   void saveAccount();    // 模拟更新账户 无返回值有参   void updateAccount(int i);    // 删除账户 有返回值无参   int  deleteAccount();&#125;\n\n/** * 账户的业务层实现类 */public class AccountServiceImpl implements IAccountService&#123;        public void saveAccount() &#123;        System.out.println(&quot;执行了保存&quot;);    &#125;    public void updateAccount(int i) &#123;        System.out.println(&quot;执行了更新&quot;+i);    &#125;    public int deleteAccount() &#123;        System.out.println(&quot;执行了删除&quot;);        return 0;    &#125;&#125;\n\n通知/** * 用于记录日志的工具类，它里面提供了公共的代码 */public class Logger &#123;    // 用于打印日志：计划让其在切入点方法执行之前执行    public  void printLog()&#123;        System.out.println(&quot;Logger类中的pringLog方法开始记录日志了。。。&quot;);    &#125;&#125;\n\n测试/** * 测试AOP的配置 */public class AOPTest &#123;    public static void main(String[] args) &#123;        //1.获取容器        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);        //2.获取对象        IAccountService as = (IAccountService)ac.getBean(&quot;accountService&quot;);        //3.执行方法        as.saveAccount();        as.updateAccount(1);        as.deleteAccount();    &#125;&#125;\n\n\n\n配置切入点表达式id属性用于指定表达式的唯一标识\nexpression属性用于指定表达式内容\n该标签写在aop:aspect标签内部只能当前切面使用\n还可以写在aop:aspect外面，此时就变成了所有切面可用\n注意：必须放在切面之前，否则会报错（还不提醒怎么错的）\n4种常用通知类型继续在刚才的实例上加其它通知类型\n使用切入点表达式简化配置\n&lt;!--配置AOP--&gt;&lt;aop:config&gt;    &lt;!-- 配置切入点表达式 --&gt;    &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.itheima.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;    &lt;!--配置切面 --&gt;    &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt;        &lt;!-- 配置前置通知：在切入点方法执行之前执行--&gt;        &lt;aop:before method=&quot;beforePrintLog&quot; pointcut-ref=&quot;pt1&quot; &gt;&lt;/aop:before&gt;        &lt;!-- 配置后置通知：在切入点方法正常执行之后值。它和异常通知永远只能执行一个--&gt;        &lt;aop:after-returning method=&quot;afterReturningPrintLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after-returning&gt;        &lt;!-- 配置异常通知：在切入点方法执行产生异常之后执行。它和后置通知永远只能执行一个--&gt;        &lt;aop:after-throwing method=&quot;afterThrowingPrintLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after-throwing&gt;        &lt;!-- 配置最终通知：无论切入点方法是否正常执行它都会在其后面执行--&gt;        &lt;aop:after method=&quot;afterPrintLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;\n\n切入点方法无异常时输出\n前置通知Logger类中的beforePrintLog方法开始记录日志了...执行了保存后置通知Logger类中的afterReturningPrintLog方法开始记录日志了...最终通知Logger类中的afterPrintLog方法开始记录日志了...\n\n切入点方法有异常时输出\n前置通知Logger类中的beforePrintLog方法开始记录日志了...执行了保存异常通知Logger类中的afterThrowingPrintLog方法开始记录日志了...最终通知Logger类中的afterPrintLog方法开始记录日志了...Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero...\n\n后置和异常只会执行其中一个\n环绕通知下面这样配置环绕通知是不行的\npublic  void aroundPringLog()&#123;       System.out.println(&quot;Logger类中的afterThrowingPrintLog方法开始记录日志了...&quot;);   &#125;\n\n这样配置后，切入点方法不执行了，只执行通知方法\n分析：对比动态代理中，发现其中的环绕通知有明确的切入点调用，而这样没有\n解决：使用Spring的ProceedingJoinPoint接口。该接口有一个proceed()方法，在程序执行时，Spring会提供该接口的实现类供我们使用\n这样可以控制增强方法何时执行，前置、后置、异常、最终都可以实现\npublic class Logger &#123;\t public Object aroundPringLog(ProceedingJoinPoint pjp)&#123;        Object rtValue = null;        try&#123;            Object[] args = pjp.getArgs();// 得到方法执行所需的参数            System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了...前置&quot;);            rtValue = pjp.proceed(args);// 明确调用业务层方法（切入点方法）            System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了...后置&quot;);            return rtValue;        &#125;catch (Throwable t)&#123;            System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了...异常&quot;);            throw new RuntimeException(t);        &#125;finally &#123;            System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了...最终&quot;);        &#125;    &#125;&#125;\n\n&lt;!-- 配置环绕通知--&gt;           &lt;aop:around method=&quot;aroundPringLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:around&gt;\n\nSpring基于注解的AOP配置示例xml配置约束比基于xml的多了context\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- 配置spring创建容器时要扫描的包--&gt;    &lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;&lt;/context:component-scan&gt;    &lt;!-- 配置spring开启注解AOP的支持 --&gt;    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt;\n\nLogger配置（4种常用类型）！[建议别用，有bug]@Component(&quot;logger&quot;)@Aspect // 表示当前类是一个切面类public class Logger &#123;    // 配置切入点表达式    @Pointcut(&quot;execution(* com.itheima.service.impl.*.*(..))&quot;)    private void pt1()&#123;&#125;    // 注意要加()    @Before(&quot;pt1()&quot;)    public  void beforePrintLog()&#123;        System.out.println(&quot;前置通知Logger类中的beforePrintLog方法开始记录日志了...&quot;);    &#125;    @AfterReturning(&quot;pt1()&quot;)    public  void afterReturningPrintLog()&#123;        System.out.println(&quot;后置通知Logger类中的afterReturningPrintLog方法开始记录日志了...&quot;);    &#125;    @AfterThrowing(&quot;pt1()&quot;)    public  void afterThrowingPrintLog()&#123;        System.out.println(&quot;异常通知Logger类中的afterThrowingPrintLog方法开始记录日志了...&quot;);    &#125;    @After(&quot;pt1()&quot;)    public  void afterPrintLog()&#123;        System.out.println(&quot;最终通知Logger类中的afterPrintLog方法开始记录日志了...&quot;);    &#125;&#125;\n\n运行输出：\n前置通知Logger类中的beforePrintLog方法开始记录日志了...执行了保存最终通知Logger类中的afterPrintLog方法开始记录日志了...后置通知Logger类中的afterReturningPrintLog方法开始记录日志了...\n\n发现最终在后置之前执行了（异常也一样）\n没有办法，因为Spring基于注解的AOP中，调用顺序确实有问题，实际开发中应该慎重\nLogger配置（环绕通知）@Component(&quot;logger&quot;)@Aspect // 表示当前类是一个切面类public class Logger &#123;    // 配置切入点表达式    @Pointcut(&quot;execution(* com.itheima.service.impl.*.*(..))&quot;)    private void pt1()&#123;&#125;    @Around(&quot;pt1()&quot;)    public Object aroundPringLog(ProceedingJoinPoint pjp)&#123;        Object rtValue = null;        try&#123;            Object[] args = pjp.getArgs();// 得到方法执行所需的参数            System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了...前置&quot;);            rtValue = pjp.proceed(args);// 明确调用业务层方法（切入点方法）            System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了...后置&quot;);            return rtValue;        &#125;catch (Throwable t)&#123;            System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了...异常&quot;);            throw new RuntimeException(t);        &#125;finally &#123;            System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了...最终&quot;);        &#125;    &#125;&#125;\n\n此时就没有顺序问题了\nLogger类中的aroundPringLog方法开始记录日志了...前置执行了保存Logger类中的aroundPringLog方法开始记录日志了...后置Logger类中的aroundPringLog方法开始记录日志了...最终\n\n","categories":["Note"],"tags":["spring"]},{"title":"maxOS截图设置","url":"/2020/03/11/mac-screencapture/","content":"问题：以前插入截图得先改文件名，要时间戳不含中文，而且png特别大，最好转成jpg，很麻烦\n目标：文件名时间戳不含中文 &amp; jpg格式\n\n一通操作改格式defaults write com.apple.screencapture type jpg\n\n改名defaults write com.apple.screencapture name screencapture\n\n改时间戳格式系统偏好设置-&gt;语言与地区-&gt;高级-&gt;时间\n正午前和中午后框中：上午/下午改成AM/PM \n完工Before:\n截屏2020-03-11上午9.50.34\n\nAfter:\nscreencapture2020-03-11AM10.05.30\n\n\n\n\n命令备忘修改格式defaults write com.apple.screencapture type jpg\n\n修改文件名defaults write com.apple.screencapture name XXX\n\n时间戳移除时间戳defaults write com.apple.screencapture &quot;include-date&quot; 0\n\n加时间戳defaults write com.apple.screencapture &quot;include-date&quot; 1\n\n其它帮助screencapture -h\n\n\n\n\nref:\nhttps://zhuanlan.zhihu.com/p/73725126\nhttps://www.maketecheasier.com/remove-time-stamp-screenshot-mac/\n\n","categories":["Note"],"tags":["tool"]},{"title":"各种各样的动态规划小结","url":"/2020/03/14/dynamic-programming/","content":"填充dp数组的方式目前碰到的题目中，一般填充dp要么是按照顺序一个一个填，要么是先全初始化为-1，缺哪个补哪个\n以最长上升子序列为例\n按顺序扫描class Solution &#123;        public int lengthOfLIS(int[] nums) &#123;        if(nums.length==0)&#123;            return 0;        &#125;        int[] dp = new int[nums.length];        int max = 0;        for(int i=0;i&lt;nums.length;i++)&#123;            dp[i] = 1;            if(i&gt;0)&#123;                for(int k=0;k&lt;i;k++)&#123;                    if(nums[i]&gt;nums[k])&#123;                        dp[i] = Math.max(dp[i],dp[k]+1);                    &#125;                &#125;            &#125;            max = Math.max(max,dp[i]);        &#125;        return max;    &#125;&#125;\n\n按需要计算class Solution &#123;    private Integer[] dp;    private int[] nums;    public int lengthOfLIS(int[] nums) &#123;        if(nums.length==0)&#123;            return 0;        &#125;        this.nums = nums;        dp = new Integer[nums.length];        Arrays.fill(dp,-1);        int max = 0;        for(int i=0;i&lt;nums.length;i++)&#123;            max = Math.max(max,getDp(i));        &#125;        return max;    &#125;    public int getDp(int i)&#123;        if(dp[i]==-1)&#123;            dp[i] = 1;            if(i&gt;0)&#123;                for(int k=0;k&lt;i;k++)&#123;                    if(nums[i]&gt;nums[k])&#123;                        dp[i] = Math.max(dp[i],getDp(k)+1);                    &#125;                &#125;            &#125;        &#125;        return dp[i];    &#125;&#125;\n\n一些想法在这个例子中，由于dp的每个元素都需要填充（然后找最大值），而且可以方便的按照顺序遍历，所以方法一显得简单一些\n但是有的题目中顺序不是很好找，比如有的二维dp数组中，要填充的是三角形区域，有的是从左往右扫，有的是从上往下扫，其它一些奇怪的dp几乎找不到顺序\n而且很多题目中并不需要把整个dp都填满，只需要得到特定一个元素即为答案，其实没必要按顺序把所有的元素都算出来\n// getDp真是非常套路public int getDp(int i)&#123;  if(dp[i]==-1)&#123;    // 没算过就算    // 算的过程中继续getDp(k)  &#125;    // 算过了直接返回  return dp[i];&#125;\n\n所以感觉，很容易找到顺序、或者必须填满的可以用方法一，其它的直接getDp()省脑细胞\n一维 例1 最长上升子序列 (LeetCode 300)link\n\n描述给定一个无序的整数数组，找到其中最长上升子序列的长度\n状态表示dp[i] 表示第i个元素（包含i）之前最大上升子序列的长度\n\n状态转移方程dp[i] = max&#123; dp[k] + 1&#125;其中 0&lt;=k&lt;i 且 nums[i]&gt;nums[k]\n\n实现见：填充dp数组的方式\n二维例1 最长公共子序列问题（算法设计技巧与分析 沙特版 p130）描述找两个字符串的最长公共子序列长度\n如A=zxyxyz B=xyyzx 则最长公共子序列为xyyz\n状态表示令 A = a1a2…an，B = b1b2…bnL[i , j] 表示 a1a2…ai 和 b1b2…bj 的最长公共子序列的长度\n\n状态转移方程当 A[i] == B[i]，L[i , j] = L[i-1 , j-1] + 1当 A[i] != B[i]，L[i , j] = max&#123; L[i-1 , j] , L[i , j-1] &#125;\n\neg:A = horse，B = rosi为2，j为2时，o == o，L[ ho , ro ] = L[ h , r ] + 1i为3，j为3时，r != s，L[ hor , ros ] = max{ L[ ho , ros ] , L[ hor , ro ] }\n实现public static int LCS(String word1, String word2) &#123;\t  int[][] dp = new int[word1.length()+1][word2.length()+1];    \tfor(int i=1;i&lt;word1.length()+1;i++) &#123;\t\tfor(int j=1;j&lt;word2.length()+1;j++) &#123;\t\t\tif(word1.charAt(i-1)==word2.charAt(j-1)) &#123;\t\t\t\tdp[i][j] = dp[i-1][j-1] + 1;\t\t\t&#125;else &#123;\t\t\t\tdp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\t\t\t&#125;\t\t&#125;\t&#125;  \treturn dp[word1.length()][word2.length()];&#125;\n\n例2 编辑距离 (LeetCode 72)link\n\n描述给定两个单词 word1 和 word2，计算将 word1 转换成 word2 所使用的最少操作数\n操作包括：\n\n插入一个字符\n删除一个字符\n替换一个字符\n\n状态表示令 A = a1a2…an，B = b1b2…bnL[i , j] 表示 a1a2…ai 和 b1b2…bj 的最短编辑距离\n\n和公共子序列一样\n状态转移方程当 A[i] == B[i]，L[i , j] = L[i-1 , j-1]当 A[i] != B[i]，L[i , j] = min&#123; L[i-1 , j-1] , L[i-1 , j] , L[i , j-1] &#125; + 1其中，L[i-1 , j-1]代表替换操作，L[i-1 , j]代表删除操作，L[i , j-1]代表插入操作\n\neg:A = horse，B = rosi为2，j为2时，o == o，L[ ho , ro ] = L[ h , r ]，无需继续编辑i为3，j为3时，r != s，L[ hor , ros ] = min{ L[ ho , ro ] , L[ ho , ros ] , L[ hor , ro ] } + 1L[ ho , ro ] + 1 代表，在ho已经编辑成ro之后，将r替换成sL[ ho , ros ] + 1 代表，在ho已经编辑成ros之后，将r删除L[ hor , ro ] + 1 代表，在hor已经编辑成ro之后，插入s\n实现class Solution &#123;    public static int minDistance(String word1, String word2) &#123;\t        int[][] dp = new int[word1.length()+1][word2.length()+1];            for(int i=1;i&lt;word1.length()+1;i++) &#123;    \t    dp[i][0] = i;        &#125;        for(int i=1;i&lt;word2.length()+1;i++) &#123;    \t    dp[0][i] = i;        &#125;        \tfor(int i=1;i&lt;word1.length()+1;i++) &#123;\t    \tfor(int j=1;j&lt;word2.length()+1;j++) &#123;\t\t    \tif(word1.charAt(i-1)==word2.charAt(j-1)) &#123;\t\t\t    \tdp[i][j] = dp[i-1][j-1];    \t\t\t&#125;else &#123;\t    \t\t\tint min = Math.min(dp[i-1][j], dp[i][j-1]);\t\t    \t\tmin = Math.min(min, dp[i-1][j-1]);\t\t\t    \tdp[i][j] = min+1;\t\t\t    &#125;    \t\t&#125;\t    &#125;\t\t\t    return dp[word1.length()][word2.length()];    &#125;&#125;\n\n注意这题dp第0行和第0列初始化为0,1,2,3…\n例3 回文子串 (LeetCode 647)link\n\n描述统计给定字符串中回文子串的个数\n如”aaa”中有”a”, “a”, “a”, “aa”, “aa”, “aaa”共6个\n状态表示dp[i][j] 表示字符串的第i到j位(含)是否为回文串\n\n状态转移方程见注释\n实现class Solution &#123;    Integer[][] dp;    public int countSubstrings(String s) &#123;        if(s.length()==0)&#123;            return 0;        &#125;                dp = new Integer[s.length()][s.length()];        for(int i=0;i&lt;s.length();i++)&#123;            Arrays.fill(dp[i],-1);        &#125;                int cnt = 0;        for(int i=0;i&lt;s.length();i++)&#123;            for(int j=i;j&lt;s.length();j++)&#123;                if(getDp(i,j,s)==1)&#123;                    cnt++;                &#125;            &#125;        &#125;        return cnt;    &#125;    public int getDp(int i,int j,String s)&#123;        if(dp[i][j]==-1)&#123;            if(i==j)&#123;                // &quot;a&quot;是                dp[i][j] = 1;            &#125;else if(s.charAt(i)!=s.charAt(j))&#123;                // &quot;ab&quot;、&quot;a***b&quot;不是                dp[i][j] = 0;            &#125;else&#123;                if(j-i==1)&#123;                    // &quot;aa&quot;是                    dp[i][j] = 1;                &#125;else&#123;                    // &quot;a****a&quot;                    if(getDp(i+1,j-1,s)==1)&#123;                        // 中间是则是                        dp[i][j] = 1;                    &#125;else&#123;                        dp[i][j] = 0;                    &#125;                &#125;            &#125;        &#125;        return dp[i][j];    &#125;&#125;\n\n三维例1 二指输入的的最小距离 (LeetCode 1320)link\n\n描述\n\n二指输入法键盘上，每个字母可用坐标表示，如P(2,3)\n给定一个待输入字符串，计算仅用两根手指，输入该字符串的最小移动距离（起始位置任意，代价位0）\n距离按 |x1-x2| + |y1-y2| 计算\n状态表示dp[i][l][r] 表示输入完第i个字母后，左手位置为l，右手位置为rl、r对应字母编号，如A-0,B-1\n\n状态转移方程记第i个字母位cur，第i-1个字母为pre1.左手移动到cur处\t- 移动前左手在pre处，则左手必然从pre移到cur，右手可以在任意位置m\t   dp[i][cur][m] = dp[i-1][pre][m] + dis(pre,cur);\t- 移动前右手在pre处(即m==pre)，则左手可以从任意位置n移到cur\t   dp[i][cur][m] = dp[i-1][n][m] + dis(n,cur);故 dp[i][cur][m] = min&#123; dp[i-1][pre][m] , dp[i-1][n][pre] &#125;其中m取值0~26，n取值0~262.右手移动到cur处\t- 移动前右手在pre处，则右手必然从pre移到cur，左手可以在任意位置m\t   dp[i][m][cur] = dp[i-1][m][pre] + dis(pre,cur);\t- 移动前左手在pre处(即m==pre)，则右手可以从任意位置n移到cur\t   dp[i][m][cur] = dp[i-1][m][n] + dis(n,cur);同上，dp[i][cur][m] = min&#123; dp[i-1][pre][m] , dp[i-1][n][pre] &#125;\n\n实现class Solution &#123;    public int minimumDistance(String word) &#123;        int[] words = new int[word.length()];        for(int i=0;i&lt;word.length();i++)&#123;            words[i] = word.charAt(i) - &#x27;A&#x27;;        &#125;        int[][][] dp = new int[words.length][26][26];        for(int i=0;i&lt;26;i++)&#123;            // 左手开始            dp[0][words[0]][i] = 0;            // 右手开始            dp[0][i][words[0]] = 0;        &#125;        for(int i=1;i&lt;words.length;i++)&#123;            int cur = words[i];            int pre = words[i-1];            int dis = calDis(cur,pre);            // 至少有一只手在cur，另一只手可以在任意位置            for(int m=0;m&lt;26;m++)&#123;                // 右手不动，左手从pre移到cur（上一个字符是左手按的）                dp[i][cur][m] = dp[i-1][pre][m] + dis;                // 左手不动，右手从pre移到cur（上一个字符是右手按的）                dp[i][m][cur] = dp[i-1][m][pre] + dis;                if(m==pre)&#123;                    // 移动前另一只手刚好在pre处                    for(int n=0;n&lt;26;n++)&#123;                        int dis2 = calDis(n,cur);                        // 右手不动，左手从任意位置移到cur（上一个字符是右手按的）                        dp[i][cur][m] = Math.min(dp[i][cur][m],dp[i-1][n][m]+dis2);                        // 左手不动，右手从任意位置移到cur（上一个字符是左手按的）                        dp[i][m][cur] = Math.min(dp[i][m][cur],dp[i-1][m][n]+dis2);                    &#125;                &#125;            &#125;        &#125;        int min = Integer.MAX_VALUE;        int last = words[words.length-1];        for(int m=0;m&lt;26;m++)&#123;            min = Math.min(min,dp[words.length-1][last][m]);            min = Math.min(min,dp[words.length-1][m][last]);        &#125;        return min;    &#125;    public int calDis(int a, int b)&#123;        int x1 = a / 6, y1 = a % 6;        int x2 = b / 6, y2 = b % 6;        return (int)(Math.abs(x1 - x2)) + (int)(Math.abs(y1 - y2));    &#125;&#125;\n\n优化为二维由于两只手是完全对称的，不需要知道具体哪只手在cur处，只要有一只在就行了\n状态表示dp[i][rest] 表示一只手在cur，另一只手在rest处时的最小移动距离\n\n状态转移方程一只手从pre移动到cur，另一只手随便在哪dp[i][anywhere] = dp[i-1][anywhere] + dis(pre,cur)若另一只手恰好在pre处，这只手可以从任何地方移动到curdp[i][pre] = dp[i-1][anywhere] + dis(anywhere,cur)\n\n实现class Solution &#123;    public int minimumDistance(String word) &#123;        int[] words = new int[word.length()];        for(int i=0;i&lt;word.length();i++)&#123;            words[i] = word.charAt(i) - &#x27;A&#x27;;        &#125;        int[][] dp = new int[words.length][26];        for(int i=1;i&lt;words.length;i++)&#123;            int cur = words[i];            int pre = words[i-1];            int dis = calDis(cur,pre);            for(int m=0;m&lt;26;m++)&#123;                // 一只手从pre移动到cur，另一只手随便在哪                dp[i][m] = dp[i-1][m] + dis;                if(m==pre)&#123;                    // 另一只手恰好在pre处，这只手可以从任何地方移动到cur                    for(int n=0;n&lt;26;n++)&#123;                        dp[i][m] = Math.min(dp[i][m],dp[i-1][n]+calDis(n,cur));                    &#125;                &#125;            &#125;        &#125;        int min = Integer.MAX_VALUE;        for(int m=0;m&lt;26;m++)&#123;            min = Math.min(min,dp[words.length-1][m]);        &#125;        return min;    &#125;    public int calDis(int a, int b)&#123;        int x1 = a / 6, y1 = a % 6;        int x2 = b / 6, y2 = b % 6;        return (int)(Math.abs(x1 - x2)) + (int)(Math.abs(y1 - y2));    &#125;&#125;\n\n优化前 执行用时：19 ms 内存消耗：42.6 MB\n优化后 执行用时：7 ms 内存消耗：38.1 MB\n也不多的样子…但是思路简单多了\n状态压缩将状态用二进制串表示，二进制串以int形式作为下标\n例1 参加考试的最大学生数 (LeetCode 1349)link\n\n描述\n\n\n教室里有的座位是坏的\n学生可以看到左、右、左上、右上方向的试卷\n\n计算该考场可以容纳的一起参加考试且无法作弊的最大学生人数\n状态压缩用一个二进制串表示一行中每个位置有没有人坐\n如 0011 表示 无无有有，记为3\n状态表示dp[row][pre] 表示当row-1行的坐法为pre时，第row行及后面所有行最多坐多少人\n\n其中，pre初始化的大小为 1 &lt;&lt; 列数\n如 有6列，最多 2 ^ 6 种坐法，即 1 &lt;&lt; 6\n状态转移方程dp[row][pre] = max&#123; dp[row+1][cur] + Integer.bitCount(cur) &#125;其中cur是row行所有可行状态\n\n每次需先判断坐法为 cur 是否可行\n结果dp[0][0] 即为 第-1行没人坐时，第1行及后面所有行最多坐的人数\n\n实现class Solution &#123;    private char[][] seats;    private Integer[][] dp;    public int maxStudents(char[][] seats) &#123;        this.seats = seats;        dp = new Integer[seats.length][1 &lt;&lt; seats[0].length];        int ret = getDp(0,0);        return ret;    &#125;    public int getDp(int row,int pre)&#123;        if(row == seats.length)&#123;            return 0;        &#125;        if(dp[row][pre] == null)&#123;            int res = 0;            // 遍历row行所有坐法            for(int i=0;i&lt;dp[0].length;i++)&#123;                // 检查是否符合要求                if(isValid(row,pre,i))&#123;                    int backNum = getDp(row+1,i);     // 后排能坐多少                    int curNum = Integer.bitCount(i); // 本排能坐多少                    res = Math.max(res,backNum+curNum);                &#125;            &#125;            dp[row][pre] = res;        &#125;        return dp[row][pre];    &#125;  \t// 判断当第row-1行坐法为pre时，row行坐法为cur是否可行    private boolean isValid(int row, int pre, int cur) &#123; //... &#125;&#125;\n\n","categories":["Note"],"tags":["algorithm"]},{"title":"Vue笔记04 分页","url":"/2020/03/16/note-vue-04/","content":"\nhttps://www.bilibili.com/video/av85793766?p=4\n\n表格与分页在上一次的基础上添加表格和分页，在官网拷过来，放在Page1\n注意不能直接并列放在template下，由于只能有一个根节点，外面要套一个div\n表格数据加载&lt;el-table-column    fixed    prop=&quot;id&quot;    label=&quot;编号&quot;    width=&quot;150&quot;&gt;&lt;/el-table-column&gt;\n\ntableData: [&#123;     id: &#x27;01&#x27;,     name: &#x27;书籍1&#x27;,     author: &#x27;作者1&#x27;,&#125;\n\n根据prop的值和数据对应\n分页&lt;el-pagination     background     layout=&quot;prev, pager, next&quot;     :total=&quot;1000&quot;&gt;&lt;/el-pagination&gt;\n\ntotal是总记录数，默认每页10条，此时就有1000/10=100页\n绑定点击事件用@current-change=”page”\n&lt;el-pagination               background               layout=&quot;prev, pager, next&quot;               :total=&quot;100&quot;               @current-change=&quot;clickPage&quot;&gt;&lt;/el-pagination&gt;\n\nScript中加\n&lt;script&gt;    export default &#123;        methods: &#123;            clickPage()&#123;                alert(1)            &#125;,        &#125;,&#125;\n\n即可看到效果\n点击翻页把传过来的对象打印看看，发现就是页面的index\n绑测试的数据试试，后面在连后台\nclickPage(index)&#123;  switch(index)&#123;    case 1:      this.tableData = [&#123;        id: &#x27;01&#x27;,        name: &#x27;书籍1&#x27;,        author: &#x27;作者1&#x27;,      &#125;, &#123;        id: &#x27;02&#x27;,        name: &#x27;书籍2&#x27;,        author: &#x27;作者2&#x27;,      &#125;, &#123;        id: &#x27;03&#x27;,        name: &#x27;书籍3&#x27;,        author: &#x27;作者3&#x27;,      &#125;]      break;    case 2:      this.tableData = [&#123;        id: &#x27;04&#x27;,        name: &#x27;书籍4&#x27;,        author: &#x27;作者4&#x27;,      &#125;, &#123;        id: &#x27;05&#x27;,        name: &#x27;书籍5&#x27;,        author: &#x27;作者5&#x27;,      &#125;, &#123;        id: &#x27;06&#x27;,        name: &#x27;书籍6&#x27;,        author: &#x27;作者6&#x27;,      &#125;]      break;  &#125;&#125;,\n\n可以正常切换\n后端添加分页操作Spring Boot的Repository把分页也解决了\n测试\n@SpringBootTestclass BookstoreServerApplicationTests &#123;    @Autowired    BookRepository repository;    @Test    void contextLoads() &#123;        PageRequest pageRequest = PageRequest.of(3,3);        Page&lt;Book&gt; page = repository.findAll(pageRequest);        System.out.println(page);    &#125;&#125;\n\n\n\n需要的东西都取出来了\n直接调方法实现接口就可以了\n在controller中，接收参数，调findAll，返回Page\n@GetMapping(&quot;/findAll/&#123;page&#125;/&#123;size&#125;&quot;)    public Page&lt;Book&gt; findAll(@PathVariable(&quot;page&quot;) Integer page,@PathVariable(&quot;size&quot;) Integer size)&#123;        PageRequest pageRequest = PageRequest.of(page,size);        return bookRepository.findAll(pageRequest);&#125;\n\n\n\n对接装插件\nvue add axios\n\naxio.get().then()\nget里是请求，then里是回调函数\ncreated()&#123;\taxios.get(&#x27;http://localhost:8181/book/findAll/0/6&#x27;).then(function(resp)&#123;\t\tconsole.log(resp)\t&#125;)&#125;\n\n\n\n看到数据得到了\nPage中data.content部分就是书籍数据，赋值即可\ndata() &#123;  return &#123;    pageSize:&#x27;6&#x27;,    total:&#x27;&#x27;,    tableData:&#x27;&#x27;  &#125;&#125;,created()&#123;  const _this = this  axios.get(&#x27;http://localhost:8181/book/findAll/0/6&#x27;).then(function(resp)&#123;    _this.tableData = resp.data.content    _this.pageSize = resp.data.size    _this.total = resp.data.totalElements  &#125;)&#125;\n\n&lt;el-pagination               background               layout=&quot;prev, pager, next&quot;               :page-size=&quot;pageSize&quot;               :total=&quot;total&quot;               @current-change=&quot;clickPage&quot;&gt;&lt;/el-pagination&gt;\n\n并且修改点击事件绑定的函数\nclickPage(index)&#123;  const _this = this  axios.get(&#x27;http://localhost:8181/book/findAll/&#x27;+(index-1)+&#x27;/6&#x27;).then(function(resp)&#123;    _this.tableData = resp.data.content    _this.pageSize = resp.data.size    _this.total = resp.data.totalElements  &#125;)&#125;,\n\n就可以点击翻页了\n\n\n\n\n","categories":["Note"],"tags":["vue"]},{"title":"Vue笔记06 修改和删除","url":"/2020/03/17/note-vue-06/","content":"\nhttps://www.bilibili.com/video/av85793766?p=6\n\n跳转到修改页面&lt;template slot-scope=&quot;scope&quot;&gt;  &lt;el-button @click=&quot;edit(scope.row)&quot; type=&quot;text&quot; size=&quot;small&quot;&gt;修改&lt;/el-button&gt;  &lt;el-button type=&quot;text&quot; size=&quot;small&quot;&gt;删除&lt;/el-button&gt;&lt;/template&gt;\n\n@click中绑定点击事件\n这里跳转用this而不需要_this，因为不在回调函数中\nedit(row) &#123;\tthis.$router.push(&#x27;/book-update&#x27;)&#125;,\n\n\nDEBUG\n这里跳转过去之后，整页都是修改页面，左侧菜单没有了\n和源码对比，发现左侧菜单的代码放在App.vue而不是Index.vue 我失忆了？\n不过也就可以解释了，加载管理、新增和修改替换的是main里的Index部分，不管怎么替换菜单都还在\n+------------------------------------+ | App                                |  | +------+-------------------------+ | | | menu | main                    | |  | |      | +---------------------+ | |  | |      | | Index               | | | | |      | +---------------------+ | |  | +------+-------------------------+ | +------------------------------------+ \n\n而我的把menu写在Index里面，管理和新增替换的是Index里的main区域，menu还在，而修改直接把Index换掉了\n+------------------------------------+ | App                                |  | +--------------------------------+ | | | Index                          | |  | | +------+---------------------+ | |  | | | menu | main                | | | | | +------+---------------------+ | |  | +--------------------------------+ | +------------------------------------+ \n\n改过来之后页面就正常了\n\n修改页面先把新增界面表单复制过去\n在created方法中调后台数据，显示到页面\n首先需要获取当前的id，BookManage页面在router中带参数穿过去\nedit(row) &#123;  // this.$router.push(&#x27;/book-update&#x27;)  this.$router.push(&#123;    path: &#x27;/book-update&#x27;,    query: &#123;    \tid: row.id  \t&#125;\t&#125;)&#125;,\n\nBookUpdate页面中接收\nmethods: &#123;  submitForm(formName) &#123;    //...  &#125;,    resetForm(formName) &#123;      //...    &#125;&#125;,created()&#123;    // 是route不是router!    alert(this.$route.query.id)&#125;\n\n这里created()在methods外面\n获取待修改修改图书信息后端Repository的findById()返回的是Option类，相当于把Book又包了一层，再用get()得到Book对象\n@Testvoid findById()&#123;  Book book = repository.findById(1).get();  System.out.println(book);&#125;\n\n先测试一下，接口没有问题，再写对外提供的方法\n@GetMapping(&quot;/findById/&#123;id&#125;&quot;)public Book findById(@PathVariable(&quot;id&quot;) Integer id)&#123;  return bookRepository.findById(id).get();&#125;\n\n对接获取数据并绑定到表单上\ncreated()&#123;  const _this = this  axios.get(&#x27;http://localhost:8181/book/findById/&#x27;+this.$route.query.id).then(function(resp)&#123;    _this.ruleForm = resp.data  &#125;)&#125;\n\n表单加一个id属性\n &lt;el-form-item label=&quot;编号&quot;&gt;   &lt;el-input v-model=&quot;ruleForm.id&quot; readonly&gt;&lt;/el-input&gt;&lt;/el-form-item&gt;\n\n不可修改，加readonly，不需要校验，删prop=”id”\n下面ruleForm也要加对应的id\n修改图书后端写一个修改方法\nrepository没有update方法，save可以用于修改\n@PutMapping(&quot;/update&quot;)public String update(@RequestBody Book book)&#123;  Book result = bookRepository.save(book);  if(result != null)&#123;    return &quot;success&quot;;  &#125;else&#123;    return &quot;error&quot;;  &#125;&#125;\n\n内容和save是一样的，但是为了符合RESTful风格，新写一个PutMapping的\n前端submitForm里面稍微修改一下，post改成put，url改一下，message改成修改成功\naxios.put(&#x27;http://localhost:8181/book/update&#x27;,this.ruleForm).then(function(resp)&#123;  if(resp.data == &#x27;success&#x27;)&#123;    _this.$message(&#123;      message: &#x27;《&#x27;+_this.ruleForm.name+&#x27;》&#x27;+&#x27;修改成功&#x27;,      type: &#x27;success&#x27;    &#125;)    _this.$router.push(&#x27;/book-manage&#x27;)  &#125;&#125;)\n\n删除图书后端\n@DeleteMapping(&quot;/deleteById/&#123;id&#125;&quot;)public void deleteById(@PathVariable(&quot;id&quot;) Integer id)&#123;  bookRepository.deleteById(id);&#125;\n\nbutton绑一个事件\n&lt;el-button @click=&quot;deleteBook(scope.row)&quot; type=&quot;text&quot; size=&quot;small&quot;&gt;删除&lt;/el-button&gt;\n\n不能叫delete，和关键字冲突\ndeleteBook(row) &#123;  const _this = this  axios.delete(&#x27;http://localhost:8181/book/deleteById/&#x27;+row.id).then(function(resp)&#123;    // 这里没有管返回信息，也可以判断状态，200就是成功    _this.$alert(&#x27;《&#x27;+row.name+&#x27;》删除成功！&#x27;, &#x27;消息&#x27;, &#123;      confirmButtonText: &#x27;确定&#x27;,      callback: action =&gt; &#123;        // 刷新        window.location.reload()      &#125;    &#125;)  &#125;)&#125;,\n\n完整的增删改查就实现了～\n修改菜单由于加了一个路由，而菜单是根据路由动态加载的，会把配置的路由全部遍历出来，于是菜单左侧就多了一个\n可以添加一个属性来判断，show是true就遍历，false就不遍历\nconst routes = [  &#123;    path: &#x27;/&#x27;,    name: &#x27;图书管理&#x27;,    show: true,    component:Index,    redirect:&#x27;book-manage&#x27;,    children:[      &#123;        path: &#x27;/book-manage&#x27;,        name: &#x27;查询图书&#x27;,        component: BookManage      &#125;,      &#123;        path: &#x27;/add-book&#x27;,        name: &#x27;添加图书&#x27;,        component: AddBook      &#125;,    ]  &#125;,  &#123;    path: &#x27;/book-update&#x27;,    name: &#x27;修改&#x27;,    show: false,    component: BookUpdate  &#125;,]\n\nApp.vue中通过v-if=”item.show”判断\n&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;el-container style=&quot;height: 500px; border: 1px solid #eee&quot;&gt;      &lt;el-aside width=&quot;200px&quot; style=&quot;background-color: rgb(238, 241, 246)&quot;&gt;        &lt;!--            这里添加router标签，el-menu-item的index就会被作为router路径--&gt;        &lt;el-menu router :default-openeds=&quot;[&#x27;0&#x27;,&#x27;1&#x27;]&quot;&gt;          &lt;!--          show属性为true则遍历--&gt;          &lt;el-submenu v-for=&quot;(item,index) in $router.options.routes&quot; :index=&quot;index+&#x27;&#x27;&quot; v-if=&quot;item.show&quot;&gt;            &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt;&#123;&#123;item.name&#125;&#125;&lt;/template&gt;            &lt;!--                    条件判断当前路径是否等于index，更改选中状态，主要是在初始化时增加默认的选中状态--&gt;            &lt;el-menu-item v-for=&quot;item2 in item.children&quot; :index=&quot;item2.path&quot; :class=&quot;$route.path==item2.path ? &#x27;is-active&#x27; : &#x27;&#x27;&quot;&gt;&#123;&#123;item2.name&#125;&#125;&lt;/el-menu-item&gt;          &lt;/el-submenu&gt;        &lt;/el-menu&gt;      &lt;/el-aside&gt;      &lt;el-main&gt;        &lt;!--            上面又index确定的router被显示在这里，也就是main区域中--&gt;        &lt;router-view&gt;&lt;/router-view&gt;      &lt;/el-main&gt;    &lt;/el-container&gt;  &lt;/div&gt;&lt;/template&gt;\n\n完工！\n","categories":["Note"],"tags":["vue"]},{"title":"Vue笔记05 表单","url":"/2020/03/16/note-vue-05/","content":"\nhttps://www.bilibili.com/video/av85793766?p=5\n\n新增书籍页面继续实现对图书完整的增删改查\n官网找一个form表单\n数据是双向绑定的，:model和v-model用来绑定对象\n可以添加校验规则，通过rules绑定。校验规则中，触发事件blur指失去焦点时触发校验\n&lt;template&gt;&lt;el-form :model=&quot;ruleForm&quot; :rules=&quot;rules&quot; ref=&quot;ruleForm&quot; label-width=&quot;100px&quot; class=&quot;demo-ruleForm&quot;&gt;    &lt;el-form-item label=&quot;书名&quot; prop=&quot;name&quot;&gt;        &lt;el-input v-model=&quot;ruleForm.name&quot;&gt;&lt;/el-input&gt;    &lt;/el-form-item&gt;    &lt;el-form-item label=&quot;作者&quot; prop=&quot;author&quot;&gt;        &lt;el-input v-model=&quot;ruleForm.author&quot;&gt;&lt;/el-input&gt;    &lt;/el-form-item&gt;    &lt;el-form-item&gt;        &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm(&#x27;ruleForm&#x27;)&quot;&gt;立即创建&lt;/el-button&gt;        &lt;el-button @click=&quot;resetForm(&#x27;ruleForm&#x27;)&quot;&gt;重置&lt;/el-button&gt;    &lt;/el-form-item&gt;&lt;/el-form&gt;&lt;/template&gt;\n\n&lt;script&gt;    export default &#123;        data() &#123;            return &#123;                ruleForm: &#123;                    name: &#x27;&#x27;,                    author: &#x27;&#x27;,                &#125;,                rules: &#123;                    name: [                        &#123; required: true, message: &#x27;请输入书名&#x27;, trigger: &#x27;blur&#x27; &#125;,                    ],                    author: [                        &#123; required: true, message: &#x27;请输入作者&#x27;, trigger: &#x27;blur&#x27; &#125;,                    ],                &#125;            &#125;;        &#125;,        methods: &#123;            submitForm(formName) &#123;                this.$refs[formName].validate((valid) =&gt; &#123;                    if (valid) &#123;                        alert(&#x27;submit!&#x27;);                    &#125; else &#123;                        console.log(&#x27;error submit!!&#x27;);                        return false;                    &#125;                &#125;);            &#125;,            resetForm(formName) &#123;                this.$refs[formName].resetFields();            &#125;        &#125;    &#125;&lt;/script&gt;\n\n后端Book的id要加自增注解，否则会出问题\n@Entity@Datapublic class Book &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)  // id自增    private Integer id;    private String name;    private String author;&#125;\n\ncontroller中加\n@PostMapping(&quot;/save&quot;)// @RequestBody把json格式转成java对象public String save(@RequestBody Book book)&#123;  Book result = bookRepository.save(book);  if(result != null)&#123;    return &quot;sucess&quot;;  &#125;else&#123;    return &quot;error&quot;;  &#125;&#125;\n\n对接传Book对象，直接追加就行了，不需要拼接\n提示信息可以再去官网找一个合适的拿来用\n添加成功后跳转到查询页面，用router.push\nsubmitForm(formName) &#123;  const _this = this  this.$refs[formName].validate((valid) =&gt; &#123;    if (valid) &#123;      axios.post(&#x27;http://localhost:8181/book/save&#x27;,this.ruleForm).then(function(resp)&#123;        if(resp.data == &#x27;success&#x27;)&#123;          _this.$message(&#123;            message: &#x27;《&#x27;+_this.ruleForm.name+&#x27;》&#x27;+&#x27;添加成功&#x27;,            type: &#x27;success&#x27;          &#125;)          _this.$router.push(&#x27;/book-manage&#x27;)        &#125;      &#125;)    &#125;  &#125;);&#125;,\n\n发现一个小问题\n这样弹出顶部提示之后直接切换页面，左侧的选中状态有问题，原页面和新页面都选中了\n但是用需要点击确定的提示框之后切回去，选中状态就没有问题\n_this.$alert(&#x27;添加成功&#x27;,&#x27;MSG&#x27;,&#123;  confirmButtonTest: &#x27;OK&#x27;,  callback: action =&gt; &#123;    this.$message(&#123;      type: &#x27;info&#x27;,      message: `action: $&#123;action&#125;`    &#125;);  &#125;&#125;);_this.$router.push(&#x27;/book-manage&#x27;)\n\n","categories":["Note"],"tags":["vue"]},{"title":"记录几个让我心动的设计","url":"/2020/03/18/aha/","content":"Trello的列表完成最后一个时会扭动～还有不同的摇摆方式！\n\n\n啊Trello我的❤️！\n\n企鹅岛里的企鹅会把花田里的花叼出来种～\n天呐我需要一个高清的录屏app -MARK-","categories":["Memo"]},{"title":"Spring笔记12 基于XML和注解的事务控制","url":"/2020/03/19/note-spring-12/","content":"\nhttps://www.bilibili.com/video/av47952931p72-74\n\n基于XML的事务控制2个工具类：ConnectionUtils 和 TransactionManager\n见 Spring笔记09 事务控制的问题&amp;动态代理\n主要配置\n&lt;!-- 配置Connection的工具类 ConnectionUtils --&gt;&lt;bean id=&quot;connectionUtils&quot; class=&quot;com.itheima.utils.ConnectionUtils&quot;&gt;  &lt;!-- 注入数据源--&gt;  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置事务管理器--&gt;&lt;bean id=&quot;txManager&quot; class=&quot;com.itheima.utils.TransactionManager&quot;&gt;  &lt;!-- 注入ConnectionUtils --&gt;  &lt;property name=&quot;connectionUtils&quot; ref=&quot;connectionUtils&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--配置aop--&gt;&lt;aop:config&gt;  &lt;!--配置通用切入点表达式--&gt;  &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.itheima.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;  &lt;aop:aspect id=&quot;txAdvice&quot; ref=&quot;txManager&quot;&gt;    &lt;!--配置前置通知：开启事务--&gt;    &lt;aop:before method=&quot;beginTransaction&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:before&gt;    &lt;!--配置后置通知：提交事务--&gt;    &lt;aop:after-returning method=&quot;commit&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after-returning&gt;    &lt;!--配置异常通知：回滚事务--&gt;    &lt;aop:after-throwing method=&quot;rollback&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after-throwing&gt;    &lt;!--配置最终通知：释放连接--&gt;    &lt;aop:after method=&quot;release&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after&gt;  &lt;/aop:aspect&gt;&lt;/aop:config&gt;\n\n基于注解的AOP配置xml中要开启对注解的支持\n@Service(&quot;accountService&quot;)public class AccountServiceImpl implements IAccountService&#123;    @Autowired    private IAccountDao accountDao;    \t// ...  &#125;\n\n@Repository(&quot;accountDao&quot;)public class AccountDaoImpl implements IAccountDao &#123;    @Autowired    private QueryRunner runner;    @Autowired    private ConnectionUtils connectionUtils;      // ...  &#125;\n\n@Component(&quot;connectionUtils&quot;)public class ConnectionUtils &#123;    @Autowired    private DataSource dataSource;        // ...  &#125;\n\n@Component(&quot;txManager&quot;)@Aspectpublic class TransactionManager &#123;    @Autowired    private ConnectionUtils connectionUtils;    @Pointcut(&quot;execution(* com.itheima.service.impl.*.*(..))&quot;)    private void pt1()&#123;&#125;    \t@Around(&quot;pt1()&quot;)    public Object aroundAdvice(ProceedingJoinPoint pjp)&#123;        Object rtValue = null;        try &#123;            // 1.获取参数            Object[] args = pjp.getArgs();            // 2.开启事务            this.beginTransaction();            // 3.执行方法            rtValue = pjp.proceed(args);            // 4.提交事务            this.commit();            // 返回结果            return  rtValue;        &#125;catch (Throwable e)&#123;            // 5.回滚事务            this.rollback();            throw new RuntimeException(e);        &#125;finally &#123;            // 6.释放资源            this.release();        &#125;    &#125;  &#125;\n\n如果分别在开启事务、提交事务、回滚事务、释放连接的函数上分别加@Before(“pt1()”)、@AfterReturning(“pt1()”)、@AfterThrowing(“pt1()”)、@After(“pt1()”)\n理论上没毛病。但是！Spring实际的执行顺序是有问题的（同 见笔记9）\n最终通知在后置通知之前执行了，于是根本没有提交就释放了，连接已经变成了新的连接\n所以不要分别用。用一个环绕通知，里面try-catch，自己控制顺序\n","categories":["Note"],"tags":["spring"]},{"title":"Vue笔记07 总结","url":"/2020/03/17/note-vue-07/","content":"这个教程6p学完了～总结一下这个图书增删改查的demo\n\nhttps://www.bilibili.com/video/av85793766\n\n\n工程创建略数据库部分略\n后端项目结构\n\n\nBook 实体类\nBookRepository 继承JpaRepository，提供数据库增删改查接口\nBookHandler 相应请求\nBookRepositoryTest 测试BookRepository的方法\n\nBookpackage com.coconutnut.bookstore_server.entity;import lombok.Data;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;@Entity // 根据类名和表名对应绑定@Data   // 自动生成get/setpublic class Book &#123;    @Id // 主键    @GeneratedValue(strategy = GenerationType.IDENTITY) // id自增    private Integer id;    private String name;    private String author;&#125;\n\nBookRepositorypackage com.coconutnut.bookstore_server.repository;import com.coconutnut.bookstore_server.entity.Book;import org.springframework.data.jpa.repository.JpaRepository;// &lt;&gt;中第一个是实体类，第二个是主键类型public interface BookRepository extends JpaRepository&lt;Book,Integer&gt; &#123; &#125;\n\nJpaRepository中有常用的增删改查方法，可以直接调用\n&amp; 通常流程：先在Test中测试方法，没问题在Controller中写对外接口，浏览器看一下返回值对不对，最后写前端\nSpring工程自带一个测试类BookstoreServerApplicationTests自己创建可在接口名上右键-&gt;Go To-&gt;Test-&gt;Create New Test生成的测试类加@SpringBootTest，要测试的类@Autowired自动注入，写的方法加@Test即可\nBookHandlerpackage com.coconutnut.bookstore_server.controller;import com.coconutnut.bookstore_server.entity.Book;import com.coconutnut.bookstore_server.repository.BookRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.web.bind.annotation.*;import java.util.List;@RestController@RequestMapping(&quot;/book&quot;)public class BookHandler &#123;    @Autowired    private BookRepository bookRepository;    // 查所有书    @GetMapping(&quot;/findAll&quot;)    public List&lt;Book&gt; findAll()&#123;        return bookRepository.findAll();    &#125;    // 查一页    @GetMapping(&quot;/findAll/&#123;page&#125;/&#123;size&#125;&quot;)    // @PathVariable获取参数    public Page&lt;Book&gt; findAll(@PathVariable(&quot;page&quot;) Integer page,@PathVariable(&quot;size&quot;) Integer size)&#123;        PageRequest pageRequest = PageRequest.of(page,size);        return bookRepository.findAll(pageRequest);    &#125;    // 新增    @PostMapping(&quot;/save&quot;)    // @RequestBody把json格式转成java对象    public String save(@RequestBody Book book)&#123;        Book result = bookRepository.save(book);        if(result != null)&#123;            return &quot;success&quot;;        &#125;else&#123;            return &quot;error&quot;;        &#125;    &#125;    // 查一个    @GetMapping(&quot;/findById/&#123;id&#125;&quot;)    public Book findById(@PathVariable(&quot;id&quot;) Integer id)&#123;        return bookRepository.findById(id).get();    &#125;    // 修改    @PutMapping(&quot;/update&quot;)    public String update(@RequestBody Book book)&#123;        Book result = bookRepository.save(book);        if(result != null)&#123;            return &quot;success&quot;;        &#125;else&#123;            return &quot;error&quot;;        &#125;    &#125;    // 删除    @DeleteMapping(&quot;/deleteById/&#123;id&#125;&quot;)    public void deleteById(@PathVariable(&quot;id&quot;) Integer id)&#123;        bookRepository.deleteById(id);    &#125;&#125;\n\n前端项目结构\n\n\nIndex.js 配路由\nApp.vue 常驻的页面\n其它vue 嵌入的页面\n\nindex.js配置页面的从属关系与路径\nimport Vue from &#x27;vue&#x27;import VueRouter from &#x27;vue-router&#x27;import Index from &quot;../views/Index&quot;;import BookManage from &#x27;../views/BookManage&#x27;import AddBook from &#x27;../views/AddBook&#x27;import BookUpdate from &#x27;../views/BookUpdate&#x27;Vue.use(VueRouter)const routes = [  &#123;    path: &#x27;/&#x27;,    name: &#x27;图书管理&#x27;,    show: true,    component:Index,    redirect:&#x27;book-manage&#x27;,    children:[      &#123;        path: &#x27;/book-manage&#x27;,        name: &#x27;查询图书&#x27;,        component: BookManage      &#125;,      &#123;        path: &#x27;/add-book&#x27;,        name: &#x27;添加图书&#x27;,        component: AddBook      &#125;,    ]  &#125;,  &#123;    path: &#x27;/book-update&#x27;,    name: &#x27;修改&#x27;,    show: false,    component: BookUpdate  &#125;,]const router = new VueRouter(&#123;  mode: &#x27;history&#x27;,  base: process.env.BASE_URL,  routes&#125;)export default router\n\n页面嵌套与跳转App.vue中template结构\n&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;el-container&gt;      &lt;el-aside&gt;        &lt;el-menu&gt;          &lt;!-- ... --&gt;        &lt;/el-menu&gt;      &lt;/el-aside&gt;      &lt;el-main&gt;        &lt;router-view&gt;&lt;/router-view&gt;      &lt;/el-main&gt;    &lt;/el-container&gt;  &lt;/div&gt;&lt;/template&gt;\n\n+------------------------------------+ | App                                |  | +------+-------------------------+ | | | menu | main                    | |  | |      | +---------------------+ | |  | |      | | router-view         | | | | |      | +---------------------+ | |  | +------+-------------------------+ | +------------------------------------+\n\n左侧aside区域中放menu，右侧main中由router动态加载\nIndex.vue中template结构\n&lt;template&gt;    &lt;router-view&gt;&lt;/router-view&gt;&lt;/template&gt;\n\nIndex.vue中其它都是默认的\n根据index.js中的配置，’/‘就加载Index.vue到App.vue的router-view区域，再’/book-manage’加载Index.vue的router-view区域。而Index重定向到book-manage，于是’http:localhost:4000/‘默认就显示了book-manage\n而’/book-update’加载Update.vue到App.vue的router-view区域\n故显示所有子页面的时候都可以看到菜单\n根据routes配置动态加载菜单栏 -&gt; App.vue&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;el-container style=&quot;height: 500px; border: 1px solid #eee&quot;&gt;      &lt;el-aside width=&quot;200px&quot; style=&quot;background-color: rgb(238, 241, 246)&quot;&gt;        &lt;!--            这里添加router标签，el-menu-item的index就会被作为router路径--&gt;        &lt;el-menu router :default-openeds=&quot;[&#x27;0&#x27;,&#x27;1&#x27;]&quot;&gt;          &lt;!--          show属性为true则遍历--&gt;          &lt;el-submenu v-for=&quot;(item,index) in $router.options.routes&quot; :index=&quot;index+&#x27;&#x27;&quot; v-if=&quot;item.show&quot;&gt;            &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt;&#123;&#123;item.name&#125;&#125;&lt;/template&gt;            &lt;!--                    条件判断当前路径是否等于index，更改选中状态，主要是在初始化时增加默认的选中状态--&gt;            &lt;el-menu-item v-for=&quot;item2 in item.children&quot; :index=&quot;item2.path&quot; :class=&quot;$route.path==item2.path ? &#x27;is-active&#x27; : &#x27;&#x27;&quot;&gt;&#123;&#123;item2.name&#125;&#125;&lt;/el-menu-item&gt;          &lt;/el-submenu&gt;        &lt;/el-menu&gt;      &lt;/el-aside&gt;      &lt;el-main&gt;        &lt;!--            上面又index确定的router被显示在这里，也就是main区域中--&gt;        &lt;router-view&gt;&lt;/router-view&gt;      &lt;/el-main&gt;    &lt;/el-container&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;app&#x27;,&#125;&lt;/script&gt;&lt;style&gt;#app &#123;  font-family: &#x27;Avenir&#x27;, Helvetica, Arial, sans-serif;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  text-align: center;  color: #2c3e50;  margin-top: 60px;&#125;&lt;/style&gt;\n\n表单显示所有书籍、翻页、删除 -&gt; BookManage.vue&lt;template&gt;    &lt;div&gt;    &lt;el-table            :data=&quot;tableData&quot;            border            style=&quot;width: 100%&quot;&gt;        &lt;el-table-column                fixed                prop=&quot;id&quot;                label=&quot;编号&quot;                width=&quot;150&quot;&gt;        &lt;/el-table-column&gt;        &lt;el-table-column                prop=&quot;name&quot;                label=&quot;书名&quot;                width=&quot;150&quot;&gt;        &lt;/el-table-column&gt;        &lt;el-table-column                prop=&quot;author&quot;                label=&quot;作者&quot;                width=&quot;150&quot;&gt;        &lt;/el-table-column&gt;        &lt;el-table-column&gt;&lt;!--                fixed=&quot;right&quot;--&gt;                label=&quot;操作&quot;                width=&quot;100&quot;&gt;            &lt;template slot-scope=&quot;scope&quot;&gt;                &lt;el-button @click=&quot;edit(scope.row)&quot; type=&quot;text&quot; size=&quot;small&quot;&gt;修改&lt;/el-button&gt;                &lt;el-button @click=&quot;deleteBook(scope.row)&quot; type=&quot;text&quot; size=&quot;small&quot;&gt;删除&lt;/el-button&gt;            &lt;/template&gt;        &lt;/el-table-column&gt;    &lt;/el-table&gt;    &lt;el-pagination            background            layout=&quot;prev, pager, next&quot;            :page-size=&quot;pageSize&quot;            :total=&quot;total&quot;            @current-change=&quot;clickPage&quot;&gt;    &lt;/el-pagination&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        methods: &#123;            // 删除            deleteBook(row) &#123;                const _this = this                axios.delete(&#x27;http://localhost:8181/book/deleteById/&#x27;+row.id).then(function(resp)&#123;                    // 这里没有管返回信息，也可以判断状态，200就是成功                    _this.$alert(&#x27;《&#x27;+row.name+&#x27;》删除成功！&#x27;, &#x27;消息&#x27;, &#123;                        confirmButtonText: &#x27;确定&#x27;,                        callback: action =&gt; &#123;                            // 刷新                            window.location.reload()                        &#125;                    &#125;)                &#125;)            &#125;,            // 跳转到编辑            edit(row) &#123;                // this.$router.push(&#x27;/book-update&#x27;)                this.$router.push(&#123;                    path: &#x27;/book-update&#x27;,                    query: &#123;                        id: row.id                    &#125;                &#125;)            &#125;,            // 翻页            clickPage(index)&#123;                const _this = this                axios.get(&#x27;http://localhost:8181/book/findAll/&#x27;+(index-1)+&#x27;/6&#x27;).then(function(resp)&#123;                    _this.tableData = resp.data.content                    _this.pageSize = resp.data.size                    _this.total = resp.data.totalElements                &#125;)            &#125;,        &#125;,        data() &#123;            return &#123;                pageSize:&#x27;6&#x27;,                total:&#x27;&#x27;,                tableData:&#x27;&#x27;            &#125;        &#125;,        // 加载书籍信息到表单        created()&#123;            const _this = this            axios.get(&#x27;http://localhost:8181/book/findAll/0/6&#x27;).then(function(resp)&#123;                _this.tableData = resp.data.content                _this.pageSize = resp.data.size                _this.total = resp.data.totalElements            &#125;)        &#125;    &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;\n\n新增 -&gt; AddBook.vue&lt;template&gt;&lt;!--    model设置数据绑定，rules设置校验规则，ref是名字，在提交时使用--&gt;&lt;el-form style=&quot;width: 60%&quot; :model=&quot;ruleForm&quot; :rules=&quot;rules&quot; ref=&quot;ruleForm&quot; label-width=&quot;100px&quot; class=&quot;demo-ruleForm&quot;&gt;    &lt;el-form-item label=&quot;书名&quot; prop=&quot;name&quot;&gt;        &lt;el-input v-model=&quot;ruleForm.name&quot;&gt;&lt;/el-input&gt;    &lt;/el-form-item&gt;    &lt;el-form-item label=&quot;作者&quot; prop=&quot;author&quot;&gt;        &lt;el-input v-model=&quot;ruleForm.author&quot;&gt;&lt;/el-input&gt;    &lt;/el-form-item&gt;    &lt;el-form-item&gt;        &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm(&#x27;ruleForm&#x27;)&quot;&gt;立即创建&lt;/el-button&gt;        &lt;el-button @click=&quot;resetForm(&#x27;ruleForm&#x27;)&quot;&gt;重置&lt;/el-button&gt;    &lt;/el-form-item&gt;&lt;/el-form&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        data() &#123;            return &#123;                ruleForm: &#123;                    name: &#x27;&#x27;,                    author: &#x27;&#x27;,                &#125;,                rules: &#123;                    name: [                        &#123; required: true, message: &#x27;请输入书名&#x27;, trigger: &#x27;blur&#x27; &#125;,                    ],                    author: [                        &#123; required: true, message: &#x27;请输入作者&#x27;, trigger: &#x27;blur&#x27; &#125;,                    ],                &#125;            &#125;;        &#125;,        methods: &#123;            // 提交表单            submitForm(formName) &#123;                const _this = this                this.$refs[formName].validate((valid) =&gt; &#123;                    if (valid) &#123;                        axios.post(&#x27;http://localhost:8181/book/save&#x27;,this.ruleForm).then(function(resp)&#123;                            if(resp.data == &#x27;success&#x27;)&#123;                                _this.$message(&#123;                                    message: &#x27;《&#x27;+_this.ruleForm.name+&#x27;》&#x27;+&#x27;添加成功&#x27;,                                    type: &#x27;success&#x27;                                &#125;)                                _this.$router.push(&#x27;/book-manage&#x27;)                            &#125;                        &#125;)                    &#125;                &#125;);            &#125;,            // 重置表单            resetForm(formName) &#123;                this.$refs[formName].resetFields();            &#125;        &#125;    &#125;&lt;/script&gt;\n\n修改 -&gt;  BookUpdate.vue&lt;template&gt;    &lt;!--    model设置数据绑定，rules设置校验规则，ref是名字，在提交时使用--&gt;    &lt;el-form style=&quot;width: 60%&quot; :model=&quot;ruleForm&quot; :rules=&quot;rules&quot; ref=&quot;ruleForm&quot; label-width=&quot;100px&quot; class=&quot;demo-ruleForm&quot;&gt;        &lt;el-form-item label=&quot;编号&quot;&gt;            &lt;el-input v-model=&quot;ruleForm.id&quot; readonly&gt;&lt;/el-input&gt;        &lt;/el-form-item&gt;        &lt;el-form-item label=&quot;书名&quot; prop=&quot;name&quot;&gt;            &lt;el-input v-model=&quot;ruleForm.name&quot;&gt;&lt;/el-input&gt;        &lt;/el-form-item&gt;        &lt;el-form-item label=&quot;作者&quot; prop=&quot;author&quot;&gt;            &lt;el-input v-model=&quot;ruleForm.author&quot;&gt;&lt;/el-input&gt;        &lt;/el-form-item&gt;        &lt;el-form-item&gt;            &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm(&#x27;ruleForm&#x27;)&quot;&gt;修改&lt;/el-button&gt;            &lt;el-button @click=&quot;submitForm(&#x27;ruleForm&#x27;)&quot;&gt;重置&lt;/el-button&gt;        &lt;/el-form-item&gt;    &lt;/el-form&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        data() &#123;            return &#123;                ruleForm: &#123;                    id: &#x27;&#x27;,                    name: &#x27;&#x27;,                    author: &#x27;&#x27;,                &#125;,                rules: &#123;                    name: [                        &#123; required: true, message: &#x27;请输入书名&#x27;, trigger: &#x27;blur&#x27; &#125;,                    ],                    author: [                        &#123; required: true, message: &#x27;请输入作者&#x27;, trigger: &#x27;blur&#x27; &#125;,                    ],                &#125;            &#125;;        &#125;,        methods: &#123;            // 提交表单            submitForm(formName) &#123;                const _this = this                this.$refs[formName].validate((valid) =&gt; &#123;                    if (valid) &#123;                        axios.put(&#x27;http://localhost:8181/book/update&#x27;,this.ruleForm).then(function(resp)&#123;                            if(resp.data == &#x27;success&#x27;)&#123;                                _this.$message(&#123;                                    message: &#x27;《&#x27;+_this.ruleForm.name+&#x27;》&#x27;+&#x27;修改成功&#x27;,                                    type: &#x27;success&#x27;                                &#125;)                                _this.$router.push(&#x27;/book-manage&#x27;)                            &#125;                        &#125;)                    &#125;                &#125;);            &#125;,            resetForm(formName) &#123;                this.$refs[formName].resetFields();            &#125;        &#125;,        // 填入初始信息        created()&#123;            // 是route不是router!            // alert(this.$route.query.id)            const _this = this            axios.get(&#x27;http://localhost:8181/book/findById/&#x27;+this.$route.query.id).then(function(resp)&#123;                _this.ruleForm = resp.data            &#125;)        &#125;    &#125;&lt;/script&gt;\n\n一点想法Spring Boot + Vue 真是好方便\n后端基本不用写什么，要用的方法都有\n前端要什么模版直接在element ui里找来用\n跟着敲这个demo的时候碰到的坑基本都是和路由有关的，router转来转去有点晕\n但是 总之\n我真的从来没有在哪个教程听见这么多“就行了”、“自动”、“不用管了”…极度舒适！有架子不用徒手爬墙真好\n","categories":["Note"],"tags":["vue"]},{"title":"Spring笔记11 Spring中的JdbcTemplate","url":"/2020/03/19/note-spring-11/","content":"\nhttps://www.bilibili.com/video/av47952931\np67~71\n\n持久层总图\n\n\nSpring中的JdbcTemplate\n作用：和数据库交互，实现对表的CRUD操作\nJdbcTemplate与DbUtilsDbUtils是Apache提供的一个对JDBC进行简单封装的开源工具类库，主要有\n\norg.apache.commons.dbutils.QueryRunner — 核心类，执行SQL查询以处理结果集（线程安全）\norg.apache.commons.dbutils.ResultSetHandler — 结果集封装器\norg.apache.commons.dbutils.DbUtils — 提供如加载驱动、关闭连接、事务提交、回滚等常规工作的工具类\n\nJdbcTemplate是Spring提供的一个对象，是对原始Jdbc API对象的简单封装，基本方法：\n\nexecute方法\nupdate与batchUpdate方法\nquery与queryXXX方法\ncall方法\n\nDbUtils导的依赖：\n&lt;!--        dbutils--&gt;&lt;dependency&gt;  &lt;groupId&gt;commons-dbutils&lt;/groupId&gt;  &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt;  &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;&lt;!--        mysql驱动--&gt;&lt;dependency&gt;  &lt;groupId&gt;mysql&lt;/groupId&gt;  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  &lt;version&gt;8.0.16&lt;/version&gt;&lt;/dependency&gt;&lt;!--        jdbc连接池--&gt;&lt;dependency&gt;  &lt;groupId&gt;com.mchange&lt;/groupId&gt;  &lt;artifactId&gt;c3p0&lt;/artifactId&gt;  &lt;version&gt;0.9.5.2&lt;/version&gt;&lt;/dependency&gt;\n\nJdbcTemplate导的依赖：\n&lt;!--        JdbcTemplate--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;  &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--        和事务相关--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;  &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--        mysql驱动--&gt;&lt;dependency&gt;  &lt;groupId&gt;mysql&lt;/groupId&gt;  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  &lt;version&gt;5.1.6&lt;/version&gt;&lt;/dependency&gt;\n\n表的实体类实现Serializable接口\n/** * 账户的实体类 */public class Account implements Serializable &#123;    private Integer id;    private String name;    private Float money;    // get set toString    // ...&#125;\n\nJdbcTemplate的最基本用法public class JdbcTemplateDemo1 &#123;      public static void main(String[] args) &#123;        // 准备数据源：spring的内置数据源        DriverManagerDataSource ds = new DriverManagerDataSource();        ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);        ds.setUrl(&quot;jdbc:mysql://localhost:3306/groot?characterEncoding=utf8&quot;);        ds.setUsername(&quot;root&quot;);        ds.setPassword(&quot;iamgroot&quot;);        // 1.创建JdbcTemplate对象        JdbcTemplate jt = new JdbcTemplate();        // 给jt设置数据源        jt.setDataSource(ds);        // 2.执行操作        jt.execute(&quot;insert into account(name,money) values(&#x27;ccc&#x27;,1000)&quot;);    &#125;  &#125;\n\n执行，没有问题\n\n\n但是这样写数据库的配置都写死了，而且用了很多set、new\n都可以通过IoC配置\nIoC配置这里dataSource暂时先用Spring内置的（id=”dataSource”）\npublic class JdbcTemplateDemo2 &#123;    public static void main(String[] args) &#123;        // 1.获取容器        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);        // 2.获取对象        JdbcTemplate jt = ac.getBean(&quot;jdbcTemplate&quot;,JdbcTemplate.class);        // 3.执行操作        jt.execute(&quot;insert into account(name,money)values(&#x27;ddd&#x27;,2222)&quot;);    &#125;    &#125;\n\n也没问题\n\n\n使用JdbcTemplate实现基本的CRUD增删改都是update方法\n// 保存jt.update(&quot;insert into account(name,money)values(?,?)&quot;,&quot;eee&quot;,3333f);// 更新jt.update(&quot;update account set name=?,money=? where id=?&quot;,&quot;test&quot;,4567,7);// 删除jt.update(&quot;delete from account where id=?&quot;,8);\n\n查询是query\nquery有很多很多很多重载的方法，找的时候关注两个点：我们有什么（参数）、我们要什么（返回值）\n比如有sql语句、参数，要返回一个List，筛选出来基本就剩2个了，它们一个要传Object[] args，一个是Object… args，是针对不同版本的（前者所有版本可用，后者jdk5之后支持可变参数可用）\n第一个方法：\n// 查询所有List&lt;Account&gt; accounts = jt.query(&quot;select * from account where money &gt; ?&quot;,new AccountRowMapper(),1000f);\n\n需要写一个AccountRowMapper类\n/** * 定义Account的封装策略 */class AccountRowMapper implements RowMapper&lt;Account&gt; &#123;    /**     * 把结果集中的数据封装到Account中，然后由spring把每个Account加到集合中     * @param rs     * @param rowNum     * @return     * @throws SQLException     */    public Account mapRow(ResultSet rs, int rowNum) throws SQLException &#123;        Account account = new Account();        account.setId(rs.getInt(&quot;id&quot;));        account.setName(rs.getString(&quot;name&quot;));        account.setMoney(rs.getFloat(&quot;money&quot;));        return account;    &#125;&#125;\n\n此时问题来了，对比dbutils中的QueryRunner\n\n\n不同的只有ResultSetHandler和AccountRowMapper，从封装的角度作用是一样的\n以前是用的dbutils提供的beanListHandler实现的\n难道机智的Spring没有这个实现吗还要自己写？\n显然必须有 -&gt; BeanPropertyRowMapper\n// 查询所有// List&lt;Account&gt; accounts = jt.query(&quot;select * from account where money &gt; ?&quot;,new AccountRowMapper(),1000f);List&lt;Account&gt; accounts = jt.query(&quot;select * from account where money &gt; ?&quot;,new BeanPropertyRowMapper&lt;Account&gt;(Account.class),1000f);for(Account account : accounts)&#123;  System.out.println(account);&#125;\n\n能查所有了，查一个也差不多（实际使用BeanPropertyRowMapper比较多）\n// 查询一个List&lt;Account&gt; accounts = jt.query(&quot;select * from account where id = ?&quot;,new BeanPropertyRowMapper&lt;Account&gt;(Account.class),3);System.out.println(accounts.isEmpty()? &quot;没有内容&quot; :accounts.get(0));\n\n还有聚合\n// 查询返回一行一列（使用聚合函数，但不加group by子句）Long count = jt.queryForObject(&quot;select count(*) from account where money &gt; ?&quot;,Long.class,1000f);System.out.println(count);\n\n第二个参数用来指定返回类型（前提是能转，为防溢出一般用Long接收）\nJdbcTemplate在Dao中的使用写一个IAccountDao接口，实现类中用上面的方法完成功能即可\nJdbcDaoSupport的使用有一个问题是，如果实际开发中有多个Dao，每个实现类中都要获取JdbcTemplate\nprivate JdbcTemplate jdbcTemplate;public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;  this.jdbcTemplate = jdbcTemplate;&#125;\n\n这段代码会重复很多次\n可以写一个JdbcDaoSupport类用于抽取这段重复代码\n其它DaoImp继承这个类，get其中的jdbcTemplate，dataSource也在其中设置好\n/** * 此类用于抽取dao中的重复代码 */public class JdbcDaoSupport &#123;    private JdbcTemplate jdbcTemplate;    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;        this.jdbcTemplate = jdbcTemplate;    &#125;    public JdbcTemplate getJdbcTemplate() &#123;        return jdbcTemplate;    &#125;    public void setDataSource(DataSource dataSource) &#123;        if(jdbcTemplate == null)&#123;            jdbcTemplate = createJdbcTemplate(dataSource);        &#125;    &#125;    private JdbcTemplate createJdbcTemplate(DataSource dataSource)&#123;        return new JdbcTemplate(dataSource);    &#125;&#125;\n\n显然，setDataSource的时候JdbcTemplate也有了\n于是配置的时候就不用配JdbcTemplate了\n&lt;!-- 配置账户的持久层--&gt;&lt;bean id=&quot;accountDao&quot; class=&quot;com.itheima.dao.impl.AccountDaoImpl&quot;&gt;  &lt;!--        &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;&gt;&lt;/property&gt;--&gt;  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--配置JdbcTemplate--&gt;&lt;!--    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;--&gt;&lt;!--        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;--&gt;&lt;!--    &lt;/bean&gt;--&gt;\n\n那么问题又来了\n自己都能写出来的东西Spring显然必须有\n把这个自己写的JdbcDaoSupport注释掉，还能跑，为啥呢\nimport org.springframework.jdbc.core.support.JdbcDaoSupport;\n\n自动导入了Spring的JdbcDaoSupport\n打开这个类看一下，就有JdbcTemplate，有setDataSource方法，有上面一堆\n所以不需要自己写，继承就完事\n继承它的目的就是在有多个Dao时去除重复代码\n但是由于源码不能动，就不好通过注解配置了，自己写和直接继承的区别就在于这里，需要权衡\n","categories":["Note"],"tags":["spring"]},{"title":"Spring笔记14 Spring5的新特性","url":"/2020/03/20/note-spring-14/","content":"\nhttps://www.bilibili.com/video/av47952931?p=82\n\n基于jdk1.8，tomcat版本要求8.5以上\n利用jdk8版本更新的内容基于jdk8的反射增强 一个测试\n三种操作：\n1.创建新对象并赋值\n2.创建一个对象赋值多次\n3.通过反射创建对象并赋值\n分别执行10亿次，比较用时(ms)\njdk8：8、31、2417\njdk7：6212、3025、290400\n@NonNull 和@Nullable 的使用用 @Nullable 和 @NotNull 注解来表明可为空的参数和以及返回值\n这样就够在编译的时候处理空值而不是在运行时抛出 NullPointerExceptions\n日志记录方面封装 Commons Logging 桥接模块（叫做 spring-jcl）\n核心容器的更新支持候选组件索引作为类路径扫描的替代方案\n从索引读取实体而不是扫描类路径对于小于 200 个类的小型项目没有明显差异\n对于大型项目，应用程序的启动时间将被大大缩减\nJetBrains Kotlin 语言支持响应式编程风格响应式堆栈 WEB 框架\n这个堆栈完全的响应式且非阻塞，适合于事件循环风格的处理，可以进行少量线程的扩展\n（有一个响应式编程实战示例，建议学完Spring Boot之后搭建  -MARK- ）\nJunit5 支持","categories":["Note"],"tags":["spring"]},{"title":"Spring笔记13 Spring中的事务控制","url":"/2020/03/19/note-spring-13/","content":"\nhttps://www.bilibili.com/video/av47952931p75-78\n\n几个点：\n\nJavaEE体系进行分层开发，事务处理位于业务层\nSpring提供事务控制的接口，在spring-tx-5.0.2.RELEASE.jar中\nSpring的事务控制基于AOP。它既可以用配置方式实现，也可以用编程方式实现（重点是配置实现）\n\nSpring中事务控制的APIPlatformTransactionManager该接口提供事务操作的方法：\n\n获取状态 getTransaction()\n提交 commit()\n回滚 rollback()\n\n常用实现类：\n\norg.springframework.jdbc.datasource.DataSourceTransactionManager \norg.springframework.orm.hibernate5.HibernateTransactionManager \n\nTransactionDefinition该接口是事务的定义信息对象，可以获取事务对象名称、隔离级别、传播行为、超时时间、是否只读\nSpring默认使用数据库的隔离级别\n传播行为指什么情况下必须有事务、什么情况可有可无\nTransactionStatus该接口提供事务的运行状态，可以刷新事务、获取是否存在存储点（可以理解为按步提交，回滚可以回滚到当前点，不用全部回滚）、是否完成、是否为新的事务、是否回滚、设置回滚\nSpring的事务控制代码准备pom.xml中需要导入aspectj的依赖，因为事务控制基于AOP\n准备数据库表和实体类（还是账户）\n实现三个方法：根据Id查询账户、根据名称查询账户、转账\n编写Dao层和业务层接口和实现类\n基于XML的声明式事务控制配置步骤\n1、配置事务管理器\n2、配置事务的通知\n此时需要导入事务的约束（文档首页点Data Access，搜xmlns:tx，同时也会导入AOP的约束）\n使用tx:advice标签配置事务通知属性：id：事务通知的唯一标识   transaction-manager：给事务通知提供一个事务管理器引用\n3、配置AOP中的通用切入点表达式\n4、建立事务通知和切入点表达式的对应关系\n5、配置事务的属性（在事务的通知tx:advice标签的内部）\n&lt;!-- 配置事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置事务的通知--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;  &lt;!-- 配置事务的属性                isolation：用于指定事务的隔离级别。默认值是DEFAULT，表示使用数据库的默认隔离级别。                propagation：用于指定事务的传播行为。默认值是REQUIRED，表示一定会有事务，增删改的选择。查询方法可以选择SUPPORTS。                read-only：用于指定事务是否只读。只有查询方法才能设置为true。默认值是false，表示读写。                timeout：用于指定事务的超时时间，默认值是-1，表示永不超时。如果指定了数值，以秒为单位。                rollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不回滚。没有默认值。表示任何异常都回滚。                no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时事务回滚。没有默认值。表示任何异常都回滚。        --&gt;  &lt;tx:attributes&gt;    &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot;/&gt;    &lt;!-- 后面写查询方法都以find开头 这样两行配置就够了--&gt;    &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;&gt;&lt;/tx:method&gt;  &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 配置aop--&gt;&lt;aop:config&gt;  &lt;!-- 配置切入点表达式--&gt;  &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.itheima.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;  &lt;!--建立切入点表达式和事务通知的对应关系 --&gt;  &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:advisor&gt;&lt;/aop:config&gt;\n\n这样service.impl下的实现类就都配置好事务控制了\n基于注解的声明式事务控制导名称空间时要多一个context，以及对应的约束\n业务层\n@Service(&quot;accountService&quot;)@Transactional(propagation= Propagation.SUPPORTS,readOnly=true) // 只读型事务的配置public class AccountServiceImpl implements IAccountService&#123;    @Autowired    private IAccountDao accountDao;    public Account findAccountById(Integer accountId) &#123;        return accountDao.findAccountById(accountId);    &#125;    // 需要的是读写型事务配置    @Transactional(propagation= Propagation.REQUIRED,readOnly=false)    public void transfer(String sourceName, String targetName, Float money) &#123;            // 2.1根据名称查询转出账户            Account source = accountDao.findAccountByName(sourceName);            // 2.2根据名称查询转入账户            Account target = accountDao.findAccountByName(targetName);            // 2.3转出账户减钱            source.setMoney(source.getMoney()-money);            // 2.4转入账户加钱            target.setMoney(target.getMoney()+money);            // 2.5更新转出账户            accountDao.updateAccount(source);            int i=1/0;            // 2.6更新转入账户            accountDao.updateAccount(target);    &#125;&#125;\n\nDao层\n@Repository(&quot;accountDao&quot;)public class AccountDaoImpl implements IAccountDao &#123;    @Autowired    private JdbcTemplate jdbcTemplate;        // ...&#125;\n\n此时不能再继承JdbcDaoSupport了（因为没法给jdbcTemplate加注解），必须自己定义一个jdbcTemplate，并在xml中配置（并注入dataSource，还要配置Spring在创建容器时需要扫描的包）\n&lt;!-- 配置spring创建容器时要扫描的包--&gt;&lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;&lt;/context:component-scan&gt;&lt;!-- 配置JdbcTemplate--&gt;&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置数据源--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;  &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;  &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/eesy&quot;&gt;&lt;/property&gt;  &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;  &lt;property name=&quot;password&quot; value=&quot;1234&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- spring中基于注解 的声明式事务控制配置步骤            1、配置事务管理器            2、开启spring对注解事务的支持            3、在需要事务支持的地方使用@Transactional注解         --&gt;&lt;!-- 配置事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 开启spring对注解事务的支持--&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt;\n\n属性在@Transactional中配置\n一个问题是，如果有十个事务，一半只读一半读写，就都得单独配置属性\n而用xml配置时一次就解决了\n","categories":["Note"],"tags":["spring"]},{"title":"Spring笔记15 总结","url":"/2020/03/20/note-spring-15/","content":"","categories":["Note"],"tags":["mindmap","spring"]},{"title":"学习Spring的一点感想","url":"/2020/03/19/note-spring/","content":"Spring学到这里，记录一点点感想\n\n这个教程一个经常的操作就是\n噼里啪啦噼里啪啦写了一大堆，然后灵魂质问：你都能写出来的东西Spring会没有吗？\n🥶🥶🥶\nfine\n不过这种过程解释了这些设计的用意，也难怪评论很多都说这个教程是看过最好的\n然鹅，用Spring Boot的时候现在的这一堆也不用写啊！\n最初接触java web这一大趴的时候特别迷惑，Tomcat、Spring、Spring MVC、Spring Boot…一😳脸😳懵😳逼\n看到大多的建议是从Spring开始，不然Spring Boot能用但是不懂为什么\n于是学了一些Spring（估计是一个四小时版本），用的时候为了方便还是直接上了Spring Boot\n现在重新学一遍，没之前那么😳😳😳了，教程里说到Spring可以简化手撕代码的时候，也知道Spring Boot还能再简化一些\n对它们的理解也慢慢清晰了一点点，感觉就是一个不断封装、约定&gt;配置的简化过程，和计算机中许许多多的进化过程一样，都是一层一层的抽(tou)象(lan)\n\n\n\n\n说起来，春天到了呢\n今天湖北已经0新增了，希望能赶快开门…\n🦢\n","categories":["Memo"],"tags":["spring"]},{"title":"MyBatis笔记02 实现CRUD","url":"/2020/03/27/note-mybatis-02/","content":"\nhttps://www.bilibili.com/video/av47952553p21～27, 44\n\n用户的持久层接口public interface IUserDao &#123;    // 增    void saveUser(User user);    // 删    void deleteUser(Integer userId);    // 改    void updateUser(User user);    // 查    List&lt;User&gt; findAll();    User findById(Integer userId);    List&lt;User&gt; findByName(String username);    int findTotal();&#125;\n\n配置与测试（以查所有为例）查询操作的映射&lt;!-- 查询所有 --&gt;&lt;select id=&quot;findAll&quot; resultType=&quot;com.itheima.domain.User&quot;&gt;  select * from user;&lt;/select&gt;\n\n测试public class MybatisTest &#123;    private InputStream in;    private SqlSession sqlSession;    private IUserDao userDao;    @Before // 用于在测试方法执行之前执行    public void init() throws Exception&#123;        // 1.读取配置文件，生成字节输入流        in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);        // 2.获取SqlSessionFactory        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);        // 3.获取SqlSession对象        sqlSession = factory.openSession();        // 4.获取dao的代理对象        userDao = sqlSession.getMapper(IUserDao.class);    &#125;    @After // 用于在测试方法执行之后执行    public void destroy() throws Exception&#123;        // 5.提交事务        sqlSession.commit();        // 6.释放资源        sqlSession.close();        in.close();    &#125;    /**     * 测试查询所有     */    @Test    public void testFindAll()&#123;        List&lt;User&gt; users = userDao.findAll();        for(User user : users)&#123;            System.out.println(user);        &#125;    &#125;&#125;\n\nCRUD增&lt;!-- 保存用户 --&gt;&lt;insert id=&quot;saveUser&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt;  &lt;!-- 配置插入操作后，获取插入数据的id --&gt;  &lt;selectKey keyProperty=&quot;userId&quot; keyColumn=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt;    select last_insert_id();  &lt;/selectKey&gt;  insert into user(username,address,sex,birthday)values(#&#123;userName&#125;,#&#123;userAddress&#125;,#&#123;userSex&#125;,#&#123;userBirthday&#125;);&lt;/insert&gt;\n\nUser user = new User();user.setUserName(&quot;AAA&quot;);user.setUserAddress(&quot;北京市顺义区&quot;);user.setUserSex(&quot;男&quot;);user.setUserBirthday(new Date());userDao.saveUser(user);\n\n可以在新增用户后获取id\n在saveUser前后打印user，可以发现id从null变为值\n删&lt;!-- 删除用户--&gt;&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;java.lang.Integer&quot;&gt;  delete from user where id = #&#123;uid&#125;&lt;/delete&gt;\n\n这里uid，传基本类型或基本类型包装类时，占位符可以随便写\nuserDao.deleteUser(48);\n\n改&lt;!-- 更新用户 --&gt;&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt;  update user set username=#&#123;userName&#125;,address=#&#123;userAddress&#125;,sex=#&#123;userAex&#125;,birthday=#&#123;userBirthday&#125; where id=#&#123;userId&#125;&lt;/update&gt;\n\nUser user = new User();user.setUserId(50);user.setUserName(&quot;BBB&quot;);user.setUserAddress(&quot;北京市顺义区&quot;);user.setUserSex(&quot;女&quot;);user.setUserBirthday(new Date());userDao.updateUser(user);\n\n查&lt;!-- 根据id查询用户 --&gt;&lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;com.itheima.domain.User&quot;&gt;  select * from user where id = #&#123;uid&#125;&lt;/select&gt;&lt;!-- 根据名称模糊查询 --&gt;&lt;select id=&quot;findByName&quot; parameterType=&quot;string&quot; resultType=&quot;com.itheima.domain.User&quot;&gt;  select * from user where username like #&#123;name&#125;&lt;/select&gt;&lt;!-- 获取用户的总记录条数 --&gt;&lt;select id=&quot;findTotal&quot; resultType=&quot;int&quot;&gt;  select count(id) from user;&lt;/select&gt;\n\n@Testpublic void testFindOne()&#123;  User  user = userDao.findById(50);&#125;@Testpublic void testFindByName()&#123;  List&lt;User&gt; users = userDao.findByName(&quot;%王%&quot;);&#125;@Testpublic void testFindTotal()&#123;  int count = userDao.findTotal();&#125;\n\n根据名称查询时，可以有两种方式\n\nselect * from user where username like #{name}\n\nselect * from user where username like ‘%${value}%’\n\n\n前者用的是PrepareStatement的参数占位符（更好），而后者用的是字符串拼接\n事务MyBatis通过sqlsession对象的commit和rollback方法实现事务的提交和回滚\n最终用到的都是connection.commit()和connection.rollback()\n自动提交\n创建SqlSession时可以设置自动提交\n\n\nsqlSession = factory.openSession(true);\n\n这样后面就不用手动提交了\n// sqlSession.commit();\n\n但是实际上能这样用不多\n如转账操作，还是需要手动控制提交时间\n","categories":["Note"],"tags":["mybatis"]},{"title":"MyBatis笔记01 入门","url":"/2020/03/26/note-mybatis-01/","content":"\nhttps://www.bilibili.com/video/av47952553p1~10\n\n框架概述什么是框架：整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法\n目的：封装细节，提高开发效率 -&gt; 关注功能实现\n不同的框架各司其职，解决某一层或某一类问题\n\n\n持久层技术有jdbc、Spring的JdbcTemplate、Apache的DBUtils\n但是它们都不是框架，jdbc是规范，JdbcTemplate和DButils是工具类（只有简单的封装而没有完整的解决方案）\nMyBatis框架概述基于 java 的持久层框架\n内部封装了 jdbc操作的细节，使开发者只需要关注 sql 语句本身，而无需关注注册驱动、创建连接等繁杂过程\n使用ORM（Object Relational Mapping）思想实现结果集的封装\n通过xml或注解的方式配置statement\n环境搭建&amp;入门案例项目结构\n\nIdea中创建目录和包是不一样的\n创建包时com.itheima.dao是三级结构\n创建目录时com.itheima.dao是一级目录\nresource中创建directory要一级一级的创建，因为MyBatis的映射配置文件位置必须和dao接口的包结构相同\n再进行相应的配置，就无须再写dao的实现类了，剩下的由MyBatis实现\n（MyBatis支持自己写实现类，但是没什么意义）\n1.准备数据库User表\n2.Idea创建Maven工程，导坐标&lt;dependencies&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.4.5&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;5.1.6&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;log4j&lt;/groupId&gt;    &lt;artifactId&gt;log4j&lt;/artifactId&gt;    &lt;version&gt;1.2.12&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;    &lt;version&gt;4.10&lt;/version&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;\n\n3. 实体类和Dao接口实体类User，属性和数据库表中字段一一对应，实现Serializable，生成get、set方法\n用户的持久层接口IUserDao，一个方法：List findAll();\n4. 配置文件主配置文件 SqlMapConfig.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!-- mybatis的主配置文件 --&gt;&lt;configuration&gt;    &lt;!-- 配置环境 --&gt;    &lt;environments default=&quot;mysql&quot;&gt;        &lt;!-- 配置mysql的环境--&gt;        &lt;environment id=&quot;mysql&quot;&gt;            &lt;!-- 配置事务的类型--&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;            &lt;!-- 配置数据源（连接池） --&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;!-- 配置连接数据库的4个基本信息 --&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/eesy_mybatis&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt;    &lt;mappers&gt;        &lt;mapper resource=&quot;com/itheima/dao/IUserDao.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration\n\n映射配置文件 IUserDao.xmlMyBatis中持久层的操作接口名和映射文件也叫Mapper\n命名IUserDao或者IUserMapper都可以\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.dao.IUserDao&quot;&gt;    &lt;!--配置查询所有--&gt;    &lt;select id=&quot;findAll&quot; resultType=&quot;com.itheima.domain.User&quot;&gt;        select * from user    &lt;/select&gt;&lt;/mapper&gt;\n\nnamespace必须是dao接口的权限定类名\nid要写dao接口的方法名\nresultType写返回类型（封装成什么对象）\nsql语句写不写分号均可\n5.测试// 1.读取配置文件InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);// 2.创建SqlSessionFactory工厂SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();SqlSessionFactory factory = builder.build(in);// 3.使用工厂生产SqlSession对象SqlSession session = factory.openSession();// 4.使用SqlSession创建Dao接口的代理对象IUserDao userDao = session.getMapper(IUserDao.class);// 5.使用代理对象执行方法List&lt;User&gt; users = userDao.findAll();for(User user : users)&#123;  System.out.println(user);&#125;// 6.释放资源session.close();in.close();\n\n涉及构建者模式&amp;工厂模式&amp;动态代理\n\n\n注解方式主配置文件还要有，修改一下mapper即可，映射配置文件可以不要了\n&lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件        如果是用注解来配置的话，此处应该使用class属性指定被注解的dao全限定类名    --&gt;&lt;mappers&gt;  &lt;mapper class=&quot;com.itheima.dao.IUserDao&quot;/&gt;&lt;/mappers&gt;\n\nIUserDao加@Select\npublic interface IUserDao &#123;    @Select(&quot;select * from user&quot;)    List&lt;User&gt; findAll();  &#125;\n\n","categories":["Note"],"tags":["mybatis"]},{"title":"MyBatis笔记03 参数与结果封装","url":"/2020/03/27/note-mybatis-03/","content":"\nhttps://www.bilibili.com/video/av47952553p28～29\n\n参数输入类型可以是：\n\n简单类型\n\npojo对象\n使用OGNL表达式解析对象字段的值，#{}或${}括号中的值为pojo属性名称\n\npojo包装对象\n把实体类包装起来，进行条件查询\n\n\nOGNL表达式Object Graphic Navigation Language\n通过对象的取值方法来获取数据，省略get\n如获取用户名，类中的写法：user.getUsername()\nOGNL表达式写法：user.username\nMyBatis中，由于parameterType中已经提供了属性所属的类，可以直接写username，不需要写对象名\n条件查询例通过QueryVo设置查询条件\npublic class QueryVo &#123;    private User user;    public User getUser() &#123;        return user;    &#125;    public void setUser(User user) &#123;        this.user = user;    &#125;&#125;\n\n此时用username就需要加对象名\n&lt;!-- 根据queryVo的条件查询用户 --&gt;&lt;select id=&quot;findUserByVo&quot; parameterType=&quot;com.itheima.domain.QueryVo&quot; resultMap=&quot;userMap&quot;&gt;  select * from user where username like #&#123;user.username&#125;&lt;/select&gt;\n\n@Testpublic void testFindByVo()&#123;  QueryVo vo = new QueryVo();  User user = new User();  user.setUserName(&quot;%王%&quot;);  vo.setUser(user);  List&lt;User&gt; users = userDao.findUserByVo(vo);&#125;\n\n结果封装resultType可以是：\n\n简单类型\npojo对象\npojo列表\n\n名称对应如果本来属性名全是小写，数据库中也全是小写，可以正常执行\n把属性名从全小写改成山峰，如userid改成userId，username改成userName，运行查所有\n可能只有userName的值查出来了\n因为windows系统下mysql不区分大小写\n但是linux系统下区分\n解决方法\n\n取别名\n\nselect id as userId,username as userName,address as userAddress,sex as userSex,birthday as userBirthday from user\n\n在sql语句层面解决问题，执行效率高\n\nMyBatis配置\n\n&lt;!-- 配置 查询结果的列名和实体类的属性名的对应关系 --&gt;&lt;resultMap id=&quot;userMap&quot; type=&quot;uSeR&quot;&gt;  &lt;!-- 主键字段的对应 --&gt;  &lt;id property=&quot;userId&quot; column=&quot;id&quot;&gt;&lt;/id&gt;  &lt;!--非主键字段的对应--&gt;  &lt;result property=&quot;userName&quot; column=&quot;username&quot;&gt;&lt;/result&gt;  &lt;result property=&quot;userAddress&quot; column=&quot;address&quot;&gt;&lt;/result&gt;  &lt;result property=&quot;userSex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;  &lt;result property=&quot;userBirthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt;&lt;/resultMap&gt;\n\n此时resultType要改成resultMap，说明使用userMap解析结果封装\n&lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt;  &lt;!--select id as userId,username as userName,address as userAddress,sex as userSex,birthday as userBirthday from user;--&gt;  select * from user;&lt;/select&gt;\n\n开发效率高些\n","categories":["Note"],"tags":["mybatis"]},{"title":"MyBatis笔记04 配置文件","url":"/2020/03/27/note-mybatis-04/","content":"\nhttps://www.bilibili.com/video/av47952553p37~38\n\nproperties可以在标签内部配置连接数据库的信息，也可以通过属性引用外部配置文件信息\n内部配置直接写在主配置文件中\n&lt;properties&gt;  &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;  &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/eesy_mybatis&quot;&gt;&lt;/property&gt;  &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;  &lt;property name=&quot;password&quot; value=&quot;1234&quot;&gt;&lt;/property&gt;&lt;/properties&gt;\n\n使用\n&lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;&gt;&lt;/property&gt;\n\n外部文件引用外部文件\nclasspath 下定义 db.properties 文件\njdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/eesyjdbc.username=rootjdbc.password=1234\n\n要求按url的写法写地址\n&lt;properties url=&quot;file:///D:/IdeaProjects/day02_eesy_01mybatisCRUD/src/main/resources/jdbcConfig.properties&quot;&gt;&lt;/properties&gt;\n\n使用\n&lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt;\n\n使用typeAliases配置类型别名只能配置domain中类的别名\ntype：指定的是实体类全限定类名\nalias：属性指定别名\n&lt;typeAliases&gt;  &lt;!-- 单个别名定义 --&gt;  &lt;typeAlias type=&quot;com.itheima.domain.User&quot; alias=&quot;user&quot;&gt;&lt;/typeAlias&gt;--&gt;  &lt;!-- 用于指定要配置别名的包，当指定之后，该包下的实体类都会注册别名，并且类名就是别名，不再区分大小写--&gt;  &lt;package name=&quot;com.itheima.domain&quot;&gt;&lt;/package&gt;&lt;/typeAliases&gt;\n\n指定了别名就不再区分大小写，user、USER、uSeR都可以\nmappersresource用于指定相对于类路径的资源位置\n&lt;mapper resource=&quot;com/itheima/dao/IUserDao.xml&quot; /&gt;\n\nclass指定接口类路径\n要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中\n&lt;mapper class=&quot;com.itheima.dao.UserDao&quot;/&gt;\n\n更简单的方式是使用package\n&lt;mappers&gt;  &lt;!--&lt;mapper resource=&quot;com/itheima/dao/IUserDao.xml&quot;&gt;&lt;/mapper&gt;--&gt;  &lt;!-- package标签是用于指定dao接口所在的包,当指定了之后就不需要再写mapper以及resource或者class了 --&gt;  &lt;package name=&quot;com.itheima.dao&quot;&gt;&lt;/package&gt;&lt;/mappers&gt;\n\n","categories":["Note"],"tags":["mybatis"]},{"title":"MyBatis笔记05 连接池","url":"/2020/03/30/note-mybatis-05/","content":"\nhttps://www.bilibili.com/video/av47952553p39~43\n\n连接池是一个存储连接的容器\n用于降低获取连接的开销\n必须线程安全\n先进先出\nMyBatis中的连接池MyBatis连接池提供3种方式的配置\n配置的位置：主配置文件SqlMapConfig.xml中dataSource标签，type属性表示采用何种连接池\ntype属性的取值：\n\nPOOLED - 采用传统的javax.sql.DataSource规范中的连接池\n\nUNPOOLED - 采用传统的获取连接的方式，虽然也实现了javax.sql.DataSource接口，但没有使用池的思想（没有容器，每次用都重新获取一个连接）\n\nJNDI - 采用服务器提供的JNDI技术实现，来获取DataSource对象，不同的服务器能拿到的DataSource不同（如果不是web或maven的war工程，不能使用）\ntomcat服务器采用dbcp连接池\n\n\nPOOLED和UNPOOLED对比&lt;!--配置连接池--&gt;&lt;dataSource type=&quot;POOLED&quot;&gt;  &lt;!-- ... --&gt;&lt;/dataSource&gt;\n\n\n\n&lt;!--配置连接池--&gt;&lt;dataSource type=&quot;UNPOOLED&quot;&gt;  &lt;!-- ... --&gt;&lt;/dataSource&gt;\n\n\n\nUNPOOLED源码分析Command + O 搜索 PooledDataSource 和 UnpooledDataSource，可以发现都实现了DataSource接口\n\n\n而这个DataSource实现javax.sql，即为jdbc规范中的连接池定义\n其中一定会有getConnection()\n\n\n找一下UnpooledDataSource中的getConnection()\n\n\n调了doGetConnection()\n\n\n最后获取连接的语句就是\nConnection connection = DriverManager.getConnection(url, properties);\n\n而initializeDriver()中就是反射注册驱动\n\n\n所以，UNPOOLED使用时，会注册驱动、获取连接、返回连接\nPOOLED源码分析也找到getConnection()\n\n\n调了popConnection()\n\n\n如果没有连接，在synchronized块中进行后续操作\n锁的是这个state\n\n\n继续，如果idleConnections非空\n\n\n而idleConnections就是一个ArrayList\n\n\n即，当它非空，取出第一个\n如果为空，连接数量小于最大值，创建连接\n\n\n如果已经到最大值了，取出一个最老的连接，尝试处理之后继续用\n总的流程：\n\n\nPOOLED是MyBatis自己实现的一套连接池，根据javax.sql.DataSource规范\n","categories":["Note"],"tags":["mybatis"]},{"title":"MyBatis笔记06 动态sql语句","url":"/2020/03/30/note-mybatis-06/","content":"\nhttps://www.bilibili.com/video/av47952553p45~47\n\nif标签根据传入参数条件查询\n条件可能是用户名、性别、地址，或者都有、都没有\n// IUserDao.javaList&lt;User&gt; findUserByCondition(User user);\n\n与要用and，不能用&amp;&amp;\nsql语句上的内容无关大小写\n&lt;select id=&quot;findUserByCondition&quot; resultMap=&quot;userMap&quot; parameterType=&quot;user&quot;&gt;  select * from user where 1=1  &lt;if test=&quot;userName != null&quot;&gt;    and username = #&#123;userName&#125;  &lt;/if&gt;  &lt;if test=&quot;userSex != null&quot;&gt;    and sex = #&#123;userSex&#125;  &lt;/if&gt;&lt;/select&gt;\n\n测试\n@Testpublic void testFindByCondition()&#123;  User u = new User();  u.setUserName(&quot;老王&quot;);  u.setUserSex(&quot;女&quot;);  List&lt;User&gt; users = userDao.findUserByCondition(u);&#125;\n\n不写 where 1=1 ？\n改进 -&gt; where标签\nwhere标签&lt;select id=&quot;findUserByCondition&quot; resultMap=&quot;userMap&quot; parameterType=&quot;user&quot;&gt;  select * from user  &lt;where&gt;    &lt;if test=&quot;userName != null&quot;&gt;      and username = #&#123;userName&#125;    &lt;/if&gt;    &lt;if test=&quot;userSex != null&quot;&gt;      and sex = #&#123;userSex&#125;    &lt;/if&gt;  &lt;/where&gt;&lt;/select&gt;\n\nforeach标签根据queryvo中的Id集合实现查询用户列表\nQueryVo.java\npublic class QueryVo &#123;    private User user;    private List&lt;Integer&gt; ids;    // get set ...  &#125;\n\nIUserDao.java\nList&lt;User&gt; findUserInIds(QueryVo vo);\n\nIUserDao.xml\n&lt;select id=&quot;findUserInIds&quot; resultMap=&quot;userMap&quot; parameterType=&quot;queryvo&quot;&gt;  select * from user  &lt;where&gt;    &lt;if test=&quot;ids != null and ids.size()&gt;0&quot;&gt;      &lt;foreach collection=&quot;ids&quot; open=&quot;and id in (&quot; close=&quot;)&quot; item=&quot;uid&quot; separator=&quot;,&quot;&gt;        #&#123;uid&#125;      &lt;/foreach&gt;    &lt;/if&gt;  &lt;/where&gt;&lt;/select&gt;\n\n#{uid}是由上面item=”uid”决定的\n测试\n@Testpublic void testFindInIds()&#123;  QueryVo vo = new QueryVo();  List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();  list.add(41);  list.add(42);  list.add(46);  vo.setIds(list);  List&lt;User&gt; users = userDao.findUserInIds(vo);&#125;\n\nsql标签抽取重复的sql语句\n（本来写不写;都可以，但是抽取sql语句时，为了防止后续的拼接出问题，最好不要写;）\n&lt;sql id=&quot;defaultUser&quot;&gt;  select * from user&lt;/sql&gt;\n\n就可以把\n&lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt;  select * from user&lt;/select&gt;\n\n改成\n&lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt;  &lt;include refid=&quot;defaultUser&quot;&gt;&lt;/include&gt;&lt;/select&gt;\n\n","categories":["Note"],"tags":["mybatis"]},{"title":"MyBatis笔记07 多表查询","url":"/2020/03/31/note-mybatis-07/","content":"\nhttps://www.bilibili.com/video/av47952553p48~56\n\n表之间的几种关系：一对一、一对多、多对一、多对多\nMyBatis把多对一看成一对一\n示例：用户和账户一个用户可以有多个账户\n一个账户只能属于一个用户\n步骤：\n\n两张表（账户表 外键）\n\n两个实体类（体现一对多的关系）\n\n两个配置文件\n\n实现配置\n查用户的所有账户\n查账户的用户信息\n\n\n两张表user表\n\n\n\nid\nusername\naddress\nsex\nbirthday\n\n\n\n\n\n\n\n\n\n\naccount表\n\n\n\nid\nuid\nmoney\n\n\n\n1\n46\n1000\n\n\n2\n45\n1000\n\n\n3\n46\n2000\n\n\n外键uid，引用user表的id\n两个实体类Userpublic class User implements Serializable &#123;    private Integer id;    private String username;    private String address;    private String sex;    private Date birthday;    // 一对多关系映射：主表实体应该包含从表实体的集合引用    private List&lt;Account&gt; accounts;    \t// get set ...&#125;\n\npublic interface IUserDao &#123;  \t// 查询所有用户，同时获取到用户下所有账户的信息    List&lt;User&gt; findAll();    \t// 根据id查询用户信息    User findById(Integer userId);&#125;\n\nAccountpublic class Account implements Serializable &#123;    private Integer id;    private Integer uid;    private Double money;    // 从表实体应该包含一个主表实体的对象引用    private User user;\t\t  \t// get set ...&#125;\n\npublic interface IAccountDao &#123;    \t// 查询所有账户，同时还要获取到当前账户的所属用户信息    List&lt;Account&gt; findAll();    \t// 查询所有账户，并且带有用户名称和地址信息    List&lt;AccountUser&gt; findAllAccount();  &#125;\n\n一对一查询查询所有账户，和账户对应的用户信息\n方法一新建一个AccountUser类，保存用户信息\npublic class AccountUser extends Account &#123;    private String username;    private String address;  \t// get set ...  &#125;\n\nIAccountDao.xml中\n&lt;select id=&quot;findAllAccount&quot; resultType=&quot;accountuser&quot;&gt;  select a.*,u.username,u.address from account a , user u where u.id = a.uid;&lt;/select&gt;\n\n这种写一个子类的方式实际用得不多\n方法二更常用 -&gt; Account中User对象引用\n配置IAccountDao.xml时使用association标签\n&lt;!-- 定义封装account和user的resultMap --&gt;&lt;resultMap id=&quot;accountUserMap&quot; type=&quot;account&quot;&gt;  &lt;id property=&quot;id&quot; column=&quot;aid&quot;&gt;&lt;/id&gt;  &lt;result property=&quot;uid&quot; column=&quot;uid&quot;&gt;&lt;/result&gt;  &lt;result property=&quot;money&quot; column=&quot;money&quot;&gt;&lt;/result&gt;  &lt;!-- 一对一的关系映射：配置封装user的内容--&gt;  &lt;association property=&quot;user&quot; column=&quot;uid&quot; javaType=&quot;user&quot;&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;    &lt;result column=&quot;username&quot; property=&quot;username&quot;&gt;&lt;/result&gt;    &lt;result column=&quot;address&quot; property=&quot;address&quot;&gt;&lt;/result&gt;    &lt;result column=&quot;sex&quot; property=&quot;sex&quot;&gt;&lt;/result&gt;    &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt;  &lt;/association&gt;&lt;/resultMap&gt;&lt;!-- 查询所有 --&gt;&lt;select id=&quot;findAll&quot; resultMap=&quot;accountUserMap&quot;&gt;  select u.*,a.id as aid,a.uid,a.money from account a , user u where u.id = a.uid;&lt;/select&gt;\n\n一对多查询查询所有用户，和用户下所有账户的信息\nIUserDao.xml中\n&lt;!-- 定义User的resultMap--&gt;&lt;resultMap id=&quot;userAccountMap&quot; type=&quot;user&quot;&gt;  &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;  &lt;result property=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/result&gt;  &lt;result property=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/result&gt;  &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;  &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt;  &lt;!-- 配置user对象中accounts集合的映射 --&gt;  &lt;collection property=&quot;accounts&quot; ofType=&quot;account&quot;&gt;    &lt;id column=&quot;aid&quot; property=&quot;id&quot;&gt;&lt;/id&gt;    &lt;result column=&quot;uid&quot; property=&quot;uid&quot;&gt;&lt;/result&gt;    &lt;result column=&quot;money&quot; property=&quot;money&quot;&gt;&lt;/result&gt;  &lt;/collection&gt;&lt;/resultMap&gt;&lt;!-- 查询所有 --&gt;&lt;select id=&quot;findAll&quot; resultMap=&quot;userAccountMap&quot;&gt;  select * from user u left outer join account a on u.id = a.uid&lt;/select&gt;\n\n不能再用inner join（,），改成left outer join\n多对多查询（用户-角色）步骤：\n\n三张表（用户表 角色表 还需使用中间表）\n\n两个实体类（体现多对多的关系）\n\n两个配置文件\n\n实现配置\n查询用户&amp;用户的角色信息\n查询角色&amp;角色的用户信息\n\n\n三张表用户表\n\n\n\nid\nusername\naddress\nsex\nbirthday\n\n\n\n\n\n\n\n\n\n\n角色表\n\n\n\nid\nrole_name\nrole_desc\n\n\n\n1\n院长\n管理整个学院\n\n\n2\n总裁\n管理整个公司\n\n\n3\n校长\n管理整个学校\n\n\n中间表\n\n\n\nuid\nrid\n\n\n\n41\n1\n\n\n45\n1\n\n\n41\n2\n\n\n两个实体类Userpublic class User implements Serializable &#123;    private Integer id;    private String username;    private String address;    private String sex;    private Date birthday;    //多对多的关系映射：一个用户可以具备多个角色    private List&lt;Role&gt; roles;    \t// get set ...&#125;\n\npublic interface IUserDao &#123;    // 查询所有用户，同时获取到用户下所有账户的信息    List&lt;User&gt; findAll();\t\t// 根据id查询用户信息    User findById(Integer userId);&#125;\n\nRolepublic class Role implements Serializable &#123;    private Integer roleId;    private String roleName;    private String roleDesc;    //多对多的关系映射：一个角色可以赋予多个用户    private List&lt;User&gt; users;  \t// get set ...  &#125;\n\npublic interface IRoleDao &#123;    // 查询所有角色    List&lt;Role&gt; findAll();  &#125;\n\n两个配置文件User&lt;!-- 定义User的resultMap--&gt;&lt;resultMap id=&quot;userMap&quot; type=&quot;user&quot;&gt;  &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;  &lt;result property=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/result&gt;  &lt;result property=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/result&gt;  &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;  &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt;  &lt;!-- 配置角色集合的映射 --&gt;  &lt;collection property=&quot;roles&quot; ofType=&quot;role&quot;&gt;    &lt;id property=&quot;roleId&quot; column=&quot;rid&quot;&gt;&lt;/id&gt;    &lt;result property=&quot;roleName&quot; column=&quot;role_name&quot;&gt;&lt;/result&gt;    &lt;result property=&quot;roleDesc&quot; column=&quot;role_desc&quot;&gt;&lt;/result&gt;  &lt;/collection&gt;&lt;/resultMap&gt;&lt;!-- 查询所有 --&gt;&lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt;  select u.*,r.id as rid,r.role_name,r.role_desc from user u  left outer join user_role ur  on u.id = ur.uid  left outer join role r on r.id = ur.rid&lt;/select&gt;&lt;!-- 根据id查询用户 --&gt;&lt;select id=&quot;findById&quot; parameterType=&quot;INT&quot; resultType=&quot;user&quot;&gt;  select * from user where id = #&#123;uid&#125;&lt;/select&gt;\n\nRole&lt;!--定义role表的ResultMap--&gt;&lt;resultMap id=&quot;roleMap&quot; type=&quot;role&quot;&gt;  &lt;id property=&quot;roleId&quot; column=&quot;rid&quot;&gt;&lt;/id&gt;  &lt;result property=&quot;roleName&quot; column=&quot;role_name&quot;&gt;&lt;/result&gt;  &lt;result property=&quot;roleDesc&quot; column=&quot;role_desc&quot;&gt;&lt;/result&gt;  &lt;collection property=&quot;users&quot; ofType=&quot;user&quot;&gt;    &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt;    &lt;result column=&quot;username&quot; property=&quot;username&quot;&gt;&lt;/result&gt;    &lt;result column=&quot;address&quot; property=&quot;address&quot;&gt;&lt;/result&gt;    &lt;result column=&quot;sex&quot; property=&quot;sex&quot;&gt;&lt;/result&gt;    &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt;  &lt;/collection&gt;&lt;/resultMap&gt;&lt;!--查询所有--&gt;&lt;select id=&quot;findAll&quot; resultMap=&quot;roleMap&quot;&gt;  select u.*,r.id as rid,r.role_name,r.role_desc from role r  left outer join user_role ur  on r.id = ur.rid  left outer join user u on u.id = ur.uid&lt;/select&gt;\n\n长语句换行的时候注意加空格，防止r left变成rleft\n","categories":["Note"],"tags":["mybatis"]},{"title":"MyBatis笔记09 注解开发","url":"/2020/04/02/note-mybatis-09/","content":"\nhttps://www.bilibili.com/video/BV1Db411s7F5\nP68~75\n\n环境搭建导坐标&lt;dependencies&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.4.5&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;5.1.6&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;log4j&lt;/groupId&gt;    &lt;artifactId&gt;log4j&lt;/artifactId&gt;    &lt;version&gt;1.2.12&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;    &lt;version&gt;4.10&lt;/version&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;\n\n准备实体类和接口public class User implements Serializable&#123;    private Integer id;    private String username;    private String address;    private String sex;    private Date birthday;    \t// get set ...&#125;\n\npublic interface IUserDao &#123;    // ...  &#125;\n\n配置文件映射配置文件可以不要了，但主配置文件不能省略\n（如果使用注解开发，但相应路径下存在对应的xml，不管用不用都会报错）\nSqlMapConfig.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!-- 引入外部配置文件--&gt;    &lt;properties resource=&quot;jdbcConfig.properties&quot;&gt;&lt;/properties&gt;    &lt;!--配置别名--&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;com.itheima.domain&quot;&gt;&lt;/package&gt;    &lt;/typeAliases&gt;    &lt;!-- 配置环境--&gt;    &lt;environments default=&quot;mysql&quot;&gt;        &lt;environment id=&quot;mysql&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt;                &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt;                &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt;                &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;!-- 指定带有注解的dao接口所在位置 --&gt;    &lt;mappers&gt;       &lt;package name=&quot;com.itheima.dao&quot;&gt;&lt;/package&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\n\njdbcConfig.properties中配置数据库连接信息\njdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/eesy_mybatisjdbc.username=rootjdbc.password=1234\n\n单表CRUD在mybatis中针对CRUD共有四个注解：@Select @Insert @Update @Delete\npublic interface IUserDao &#123;  \t// 增  \t@Insert(&quot;insert into user(username,address,sex,birthday)values(#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;)&quot;)    void saveUser(User user);    \t// 删  \t@Delete(&quot;delete from user where id=#&#123;id&#125; &quot;)    void deleteUser(Integer userId);    \t// 改  \t@Update(&quot;update user set username=#&#123;username&#125;,sex=#&#123;sex&#125;,birthday=#&#123;birthday&#125;,address=#&#123;address&#125; where id=#&#123;id&#125;&quot;)    void updateUser(User user);      // 查    @Select(&quot;select * from user&quot;)    List&lt;User&gt; findAll();    \t@Select(&quot;select * from user  where id=#&#123;id&#125; &quot;)    User findById(Integer userId);    \t// 方法一：这里#&#123;username&#125;没有%，查询时要传入如“%王%”  \t@Select(&quot;select * from user where username like #&#123;username&#125; &quot;)  \t// 方法二：$&#123;&#125;中固定写value，传参时不用写%  \t@Select(&quot;select * from user where username like &#x27;%$&#123;value&#125;%&#x27; &quot;)    List&lt;User&gt; findUserByName(String username);  \t// 区别和之前一样，一个是字符串拼接，一个是参数占位符    \t@Select(&quot;select count(*) from user &quot;)    int findTotalUser();  &#125;\n\n测试public class AnnotationCRUDTest &#123;    private InputStream in;    private SqlSessionFactory factory;    private SqlSession session;    private IUserDao userDao;    @Before    public  void init()throws Exception&#123;        // 1.获取字节输入流        in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);        // 2.根据字节输入流构建SqlSessionFactory        factory = new SqlSessionFactoryBuilder().build(in);        // 3.根据SqlSessionFactory生产一个SqlSession        session = factory.openSession();        // 4.使用SqlSession获取Dao的代理对象        userDao = session.getMapper(IUserDao.class);    &#125;    @After    public  void destroy()throws  Exception&#123;        // 提交        session.commit();        // 释放资源        session.close();        in.close();    &#125;    @Test    public void testSave()&#123;        User user = new User();        user.setUsername(&quot;mybatis annotation&quot;);        user.setAddress(&quot;北京市昌平区&quot;);        userDao.saveUser(user);    &#125;    \t// ...&#125;\n\n实体类属性和数据库不对应问题实体类中名称和表中对不上时（userName &amp; username）\npublic class User implements Serializable&#123;    private Integer userId;    private String userName;    private String userAddress;    private String userSex;    private Date userBirthday;&#125;\n\n可以使用别名，但是所有位置都要使用别名，比较麻烦\n可以使用@Results注解\npublic interface IUserDao &#123;    @Select(&quot;select * from user&quot;)    @Results(id=&quot;userMap&quot;,value=&#123;            @Result(id=true,column = &quot;id&quot;,property = &quot;userId&quot;),            @Result(column = &quot;username&quot;,property = &quot;userName&quot;),            @Result(column = &quot;address&quot;,property = &quot;userAddress&quot;),            @Result(column = &quot;sex&quot;,property = &quot;userSex&quot;),            @Result(column = &quot;birthday&quot;,property = &quot;userBirthday&quot;)    &#125;)    List&lt;User&gt; findAll();    \t@Select(&quot;select * from user  where id=#&#123;id&#125; &quot;)    @ResultMap(&quot;userMap&quot;)    User findById(Integer userId);&#125;\n\n主键：id=true\n其它位置用@ResultMap引用\n标准写法@ResultMap(value={“userMap”})\n由于只有一个属性，value可以省略；数组中只有一个元素，{}可以省略\n于是可以直接写@ResultMap(“userMap”)\n多表查询实体类和接口再建一个账户\npublic class Account implements Serializable &#123;    private Integer id;    private Integer uid;    private Double money;    \t//多对一（mybatis中称为一对一）的映射：一个账户只能属于一个用户    private User user;    \t// get set ...&#125;\n\n修改用户实体类\npublic class User implements Serializable&#123;    private Integer userId;    private String userName;    private String userAddress;    private String userSex;    private Date userBirthday;    //一对多关系映射：一个用户对应多个账户    private List&lt;Account&gt; accounts;    \t// get set ...  &#125;\n\n一对一查询查账户以及所属的用户\nIAccountDao中\n \t@Select(&quot;select * from account&quot;)\t@Results(id=&quot;accountMap&quot;,value = &#123;  @Result(id=true,column = &quot;id&quot;,property = &quot;id&quot;),  @Result(column = &quot;uid&quot;,property = &quot;uid&quot;),  @Result(column = &quot;money&quot;,property = &quot;money&quot;),  @Result(property = &quot;user&quot;,column = &quot;uid&quot;,one=@One(select=&quot;com.itheima.dao.IUserDao.findById&quot;,fetchType= FetchType.EAGER))&#125;)List&lt;Account&gt; findAll();\n\n这里不使用left outer join，使用@One\nselect要找到能实现功能的方法，即IUserDao中findById，来查询账户所属的用户\nFetchType可以配置延迟加载（LAZY），或立即加载（EAGER）\n实际开发时对一一般选择立即加载，对多一般选择延迟加载\n一对多查询查一个用户，和该用户对应的多个账户\nIUserDao中\n@Select(&quot;select * from user&quot;)@Results(id=&quot;userMap&quot;,value=&#123;  @Result(id=true,column = &quot;id&quot;,property = &quot;userId&quot;),  @Result(column = &quot;username&quot;,property = &quot;userName&quot;),  @Result(column = &quot;address&quot;,property = &quot;userAddress&quot;),  @Result(column = &quot;sex&quot;,property = &quot;userSex&quot;),  @Result(column = &quot;birthday&quot;,property = &quot;userBirthday&quot;),  @Result(property = &quot;accounts&quot;,column = &quot;id&quot;,          many = @Many(select = &quot;com.itheima.dao.IAccountDao.findAccountByUid&quot;,                       fetchType = FetchType.LAZY))&#125;)List&lt;User&gt; findAll();\n\n用@Many\nIAccountDao中加一个方法\n@Select(&quot;select * from account where uid = #&#123;userId&#125;&quot;)List&lt;Account&gt; findAccountByUid(Integer userId);\n\n缓存配置不管用xml还是注解，一级缓存默认都是开的\n打开二级注解，全局配置默认也是打开\n对于单个类，使用@CacheNamespace（默认是false）\n@CacheNamespace(blocking = true)public interface IUserDao &#123;  // ...&#125;\n\n即可开启二级缓存\n","categories":["Note"],"tags":["mybatis"]},{"title":"MyBatis笔记08 延迟加载与缓存","url":"/2020/04/02/note-mybatis-08/","content":"\nhttps://www.bilibili.com/video/BV1Db411s7F5\nP60~67\n\n延迟加载延迟加载：在真正使用数据时才发起查询，不用的时候不查询，按需加载（懒加载）\n立即加载：不管用不用，只要一调用方法，马上发起查询\n一般一对多、多对多采用延迟加载；多对一、一对一采用立即加载\n查官网文档\n找到延迟加载的全局开关\n在全局配置文件中\n&lt;!--配置参数--&gt;&lt;settings&gt;  &lt;!--开启Mybatis支持延迟加载--&gt;  &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;  &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;&gt;&lt;/setting&gt;&lt;/settings&gt;\n\n一对一实现延迟加载仍然是IAccountDao的findAll方法\n&lt;!-- 定义封装account和user的resultMap --&gt;&lt;resultMap id=&quot;accountUserMap&quot; type=&quot;account&quot;&gt;  &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;  &lt;result property=&quot;uid&quot; column=&quot;uid&quot;&gt;&lt;/result&gt;  &lt;result property=&quot;money&quot; column=&quot;money&quot;&gt;&lt;/result&gt;  &lt;!-- 一对一的关系映射：配置封装user的内容        select属性指定的内容：查询用户的唯一标识：        column属性指定的内容：用户根据id查询时，所需要的参数的值        --&gt;  &lt;association property=&quot;user&quot; column=&quot;uid&quot; javaType=&quot;user&quot; select=&quot;com.itheima.dao.IUserDao.findById&quot;&gt;&lt;/association&gt;&lt;/resultMap&gt;&lt;!-- 查询所有 --&gt;&lt;select id=&quot;findAll&quot; resultMap=&quot;accountUserMap&quot;&gt;  select * from account&lt;/select&gt;\n\nIUserDao.xml中需要配\n&lt;!-- 根据id查询用户 --&gt;&lt;select id=&quot;findById&quot; parameterType=&quot;INT&quot; resultType=&quot;user&quot;&gt;  select * from user where id = #&#123;uid&#125;&lt;/select&gt;\n\n测试时\n@Testpublic void testFindAll()&#123;  List&lt;Account&gt; accounts = accountDao.findAll();  //        for(Account account : accounts)&#123;  //            System.out.println(&quot;--------每个account的信息------------&quot;);  //            System.out.println(account);  //            System.out.println(account.getUser());  //        &#125;&#125;\n\n当把打印用户信息注释掉，调用只findAll()时不会加载每个用户信息\n只有实际用到User的时候才会执行查询用户的操作\n一对多实现延迟加载IUserDao.xml中\n不再使用left outer join\n&lt;!-- 定义User的resultMap--&gt;&lt;resultMap id=&quot;userAccountMap&quot; type=&quot;user&quot;&gt;  &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;  &lt;result property=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/result&gt;  &lt;result property=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/result&gt;  &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;  &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt;  &lt;!-- 配置user对象中accounts集合的映射 --&gt;  &lt;collection property=&quot;accounts&quot; ofType=&quot;account&quot; select=&quot;com.itheima.dao.IAccountDao.findAccountByUid&quot; column=&quot;id&quot;&gt;&lt;/collection&gt;&lt;/resultMap&gt;&lt;!-- 查询所有 --&gt;&lt;select id=&quot;findAll&quot; resultMap=&quot;userAccountMap&quot;&gt;  select * from user&lt;/select&gt;\n\nIAccountDao.xml中需要\n&lt;!-- 根据用户id查询账户列表 --&gt;&lt;select id=&quot;findAccountByUid&quot; resultType=&quot;account&quot;&gt;  select * from account where uid = #&#123;uid&#125;&lt;/select&gt;\n\n实际上都是在要用的时候才去调另一个类中具体的查询方法\n缓存适用于缓存的数据：经常查询且不常修改、数据的正确与否对最终结果影响不大\nMyBatis中的一级缓存指的是MyBatis中的SqlSession对象的缓存\n执行查询后，查询结果会同时存入SqlSession提供的一块区域中，改区域的结构是一个Map\n再次查询同样的数据时，MyBatis会先去SqlSession中查询是否有结果，有的话直接拿出来用\n当SqlSession对象消失时，一级缓存也消失\n测试@Testpublic void testFirstLevelCache()&#123;  // 根据id查询用户  User user1 = userDao.findById(41);  System.out.println(user1);  // 再次查询同一用户  User user2 = userDao.findById(41);  System.out.println(user2);  System.out.println(user1 == user2);&#125;\n\n打印发现user1和user2是同一个，且日志信息中只记录了一次查询\n说明user2是直接从缓存中取的\n如果在两次查询中关闭SqlSession\n@Testpublic void testFirstLevelCache()&#123;  // 根据id查询用户  User user1 = userDao.findById(41);  System.out.println(user1);  // 关闭并重新获取Session  sqlSession.close();  sqlSession = factory.openSession();  userDao = sqlSession.getMapper(IUserDao.class);    // 再次查询同一用户  User user2 = userDao.findById(41);  System.out.println(user2);  System.out.println(user1 == user2);&#125;\n\n这次两个对象不同了\nsqlSession.clearCache() 可以清缓存，两个对象也不同\n触发清空一级缓存的情况调用SqlSession的修改、添加、删除、提交、关闭等方法时，会清空一级缓存\n如在两次查询中更新用户\n配置文件中加更新方法\n&lt;!-- 更新用户信息--&gt;&lt;update id=&quot;updateUser&quot; parameterType=&quot;user&quot;&gt;  update user set username=#&#123;username&#125;,address=#&#123;address&#125; where id=#&#123;id&#125;&lt;/update&gt;\n\n测试时\n@Testpublic void testClearlCache()&#123;  // 1.根据id查询用户  User user1 = userDao.findById(41);  System.out.println(user1);  // 2.更新用户信息  user1.setUsername(&quot;update user clear cache&quot;);  user1.setAddress(&quot;北京市海淀区&quot;);  userDao.updateUser(user1);  // 3.再次查询id为41的用户  User user2 = userDao.findById(41);  System.out.println(user2);  System.out.println(user1 == user2);&#125;\n\n更新之后再查询，会发起一次新的查询\nMyBatis中的二级缓存指的是MyBatis中SqlSessionFactory对象的缓存，由同一个SqlSessionFactory对象创建的SqlSession共享其缓存\n\n\n使用步骤：\n\n让MyBatis框架支持二级缓存（在SqlMapConfig.xml中配置）\n&lt;settings&gt;  &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt;\n\n（不配也行，默认是true）\n\n让当前的映射文件支持二级缓存（在IUserDao.xml中配置）\n&lt;!--开启user支持二级缓存--&gt;&lt;cache/&gt;\n\n让当前的操作支持二级缓存（在select标签中配置）\n &lt;!-- 根据id查询用户 --&gt;&lt;select id=&quot;findById&quot; parameterType=&quot;INT&quot; resultType=&quot;user&quot; useCache=&quot;true&quot;&gt;  select * from user where id = #&#123;uid&#125;&lt;/select&gt;\n\n\n\n测试\nSqlSession sqlSession1 = factory.openSession();IUserDao dao1 = sqlSession1.getMapper(IUserDao.class);User user1 = dao1.findById(41);System.out.println(user1);sqlSession1.close();SqlSession sqlSession2 = factory.openSession();IUserDao dao2 = sqlSession2.getMapper(IUserDao.class);User user2 = dao2.findById(41);System.out.println(user2);sqlSession2.close();System.out.println(user1 == user2);\n\n发现第二次并没有查询，直接从缓存中获取\n但是打印结果为false\n因为二级缓存中存放的是数据，而不是对象\n","categories":["Note"],"tags":["mybatis"]},{"title":"SpringMVC笔记01 入门","url":"/2020/04/03/note-springmvc-01/","content":"\nhttps://www.bilibili.com/video/BV1Sb411s7qa\np1~9\n\nSpringMVC是一个基于Java的、实现MVC设计模型的、请求驱动类型的轻量级Web框架\n使用Spring进行web开发时，可以选择SpringMVC，也可以集成其它框架如Struts2\n它通过一套注解，让一个简单的Java类成为处理请求的控制器，而无需实现任何接口\n支持RESTful风格的请求\n\n\n入门案例需求：\n\n\n环境搭建Idea创建Maven工程，选择webapp\nmaven项目创建时，可以加一组键值对archetypeCatalog : internal，解决加载慢的问题\n建立的工程目录是不全的，在src/main下手动加上java、resource文件夹，并右键Mark Directory as设置为源码、资源文件夹\npom.xml&lt;properties&gt;  &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;  &lt;!-- 编译版本改成1.8 --&gt;  &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;  &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;  &lt;!-- spring版本锁定，下面直接引用 --&gt;  &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;    &lt;version&gt;2.5&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;    &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;    &lt;version&gt;2.0&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;\n\nweb.xml配置前端控制器（servlet）\n&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;!-- 加载springmvc的配置文件 --&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;!-- 启动服务器时加载 --&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;\n\nspringmvc的配置文件在resources中New-&gt;XML Configuration File-&gt;Spring Config\n名称没有要求，这里叫springmvc\n导入名称空间，开启注解扫描\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/mvc       http://www.springframework.org/schema/mvc/spring-mvc.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- 开启注解扫描 --&gt;    &lt;context:component-scan base-package=&quot;com.test&quot;/&gt;    \t&lt;!-- 视图解析器 --&gt;    &lt;bean id=&quot;internalResourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;!-- 配置文件目录 --&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages&quot;&gt;&lt;/property&gt;        &lt;!-- 配置后缀名 --&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;  \t&lt;!-- 开启SpringMVC框架注解支持 --&gt;    &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;  &lt;/beans&gt;\n\n部署服务器Add Configuration\n加一个本地的Tomcat\n在Deployment中添加\n\n\n代码编写index.jsp默认自带的index.jsp没有头文件信息，中文可能会有乱码问题\n可以删了重新创建一个\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;入门程序&lt;/h1&gt;    &lt;a href=&quot;hello&quot;&gt;点这里&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;\n\nHelloController.javapackage com.test.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class HelloController &#123;    @RequestMapping(path=&quot;/hello&quot;)    public String sayHello()&#123;        System.out.println(&quot;Hello Spring&quot;);        return &quot;success&quot;;    &#125;&#125;\n\n这里返回”success”，规则默认返回这个名字的jsp\nsuccess.jsp可以在WEB-INF中新建pages文件夹，在里面新建success.jsp\n加一个一级标题\n&lt;h1&gt;成功&lt;/h1&gt;\n\n测试\n\n点击\n\n\n控制台输出\n\n\n成功\n入门案例流程总结 \n\n \n\nRequestMapping注解作用\n建立请求url和处理请求方法之间的对应关系\n可以加在方法上，也可以加在类上（相当于一级目录）\n如类上加”/user”，方法上加”/hello”，跳转时请求路径为”user/hello”\n属性\npath和value：作用相同，指映射路径，当只有value一个属性时，”value=”可以省略不写\nmethod：指当前方法可以接受的请求方式，参数可以是数组，里面是枚举类型（如RequestMathod.POST）\nparams：用于指定限制请求参数的条件，支持简单的表达式（如params={“username=he”}，表示请求参数中必须有username，且值必须为he）\nheaders：发送的请求必须包含请求头\n","categories":["Note"],"tags":["springmvc"]},{"title":"SpringMVC笔记02 请求参数的绑定","url":"/2020/04/04/note-springmvc-02/","content":"\nhttps://www.bilibili.com/video/BV1Sb411s7qa\nP11~16\n\n简单参数&lt;a href=&quot;param/testParam?username=hehe&amp;password=123&quot;&gt;\n\n@RequestMapping(&quot;/testParam&quot;)public String testParam(String username,String password)&#123;  // ...&#125;\n\n绑定实体类型实体类\npublic class Account implements Serializable&#123;    private String username;    private String password;    private Double money;    \t// get set ...  &#125;\n\n表单\n&lt;form action=&quot;param/saveAccount&quot; method=&quot;post&quot;&gt;  姓名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt;  密码：&lt;input type=&quot;text&quot; name=&quot;password&quot; /&gt;&lt;br/&gt;  金额：&lt;input type=&quot;text&quot; name=&quot;money&quot; /&gt;&lt;br/&gt;  &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;\n\n绑定\n/*** 请求参数绑定把数据封装到JavaBean的类中* @return*/@RequestMapping(&quot;/saveAccount&quot;)public String saveAccount(Account account)&#123;  System.out.println(&quot;执行了...&quot;);  System.out.println(account);  return &quot;success&quot;;&#125;\n\n引用类型实体类\npublic class User implements Serializable&#123;    private String uname;    private Integer age;    \t// get set ...  &#125;\n\npublic class Account implements Serializable&#123;    private String username;    private String password;    private Double money;   \tprivate User user;  &#125;\n\n表单\n&lt;form action=&quot;param/saveAccount&quot; method=&quot;post&quot;&gt;  姓名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt;  密码：&lt;input type=&quot;text&quot; name=&quot;password&quot; /&gt;&lt;br/&gt;  金额：&lt;input type=&quot;text&quot; name=&quot;money&quot; /&gt;&lt;br/&gt;  用户姓名：&lt;input type=&quot;text&quot; name=&quot;user.uname&quot; /&gt;&lt;br/&gt;  用户年龄：&lt;input type=&quot;text&quot; name=&quot;user.age&quot; /&gt;&lt;br/&gt;  &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;\n\n集合类型实体类\npublic class Account implements Serializable&#123;    private String username;    private String password;    private Double money;    private List&lt;User&gt; list;    private Map&lt;String,User&gt; map;  &#125;\n\n表单\n&lt;form action=&quot;param/saveAccount&quot; method=&quot;post&quot;&gt;  姓名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt;  密码：&lt;input type=&quot;text&quot; name=&quot;password&quot; /&gt;&lt;br/&gt;  金额：&lt;input type=&quot;text&quot; name=&quot;money&quot; /&gt;&lt;br/&gt;  用户姓名：&lt;input type=&quot;text&quot; name=&quot;list[0].uname&quot; /&gt;&lt;br/&gt;  用户年龄：&lt;input type=&quot;text&quot; name=&quot;list[0].age&quot; /&gt;&lt;br/&gt;  用户姓名：&lt;input type=&quot;text&quot; name=&quot;map[&#x27;one&#x27;].uname&quot; /&gt;&lt;br/&gt;  用户年龄：&lt;input type=&quot;text&quot; name=&quot;map[&#x27;one&#x27;].age&quot; /&gt;&lt;br/&gt;  &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;\n\nmap中放key值，这里是’one’\n自定义类型转换器页面提交的数据都是字符串类型\n基本类型可以自动转，如Integer\n但日期类型可能不支持某些格式，需要自定义类型转换器\n例如，给User加一个Date属性\npublic class User implements Serializable&#123;    private String uname;    private Integer age;    private Date date;  &#125;\n\n&lt;form action=&quot;param/saveUser&quot; method=&quot;post&quot;&gt;  用户姓名：&lt;input type=&quot;text&quot; name=&quot;uname&quot; /&gt;&lt;br/&gt;  用户年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot; /&gt;&lt;br/&gt;  用户生日：&lt;input type=&quot;text&quot; name=&quot;date&quot; /&gt;&lt;br/&gt;  &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;\n\n@RequestMapping(&quot;/saveUser&quot;)public String saveUser(User user)&#123;  System.out.println(&quot;执行了...&quot;);  System.out.println(user);  return &quot;success&quot;;&#125;\n\n在生日框中输入”2000/11/11”发现可以正常封装\n但是”2000-11-11”出现Bad Request\n需要写一个类型转换类并注册\n需要实现Converter接口\npublic class StringToDateConverter implements Converter&lt;String,Date&gt;&#123;    public Date convert(String source) &#123;        if(source == null)&#123;            throw new RuntimeException(&quot;请您传入数据&quot;);        &#125;        DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);        try &#123;            return df.parse(source);        &#125; catch (Exception e) &#123;            throw new RuntimeException(&quot;数据类型转换出现错误&quot;);        &#125;    &#125;&#125;\n\n然后在springmvc.xml中配置\n&lt;!--配置自定义类型转换器--&gt;&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;  &lt;property name=&quot;converters&quot;&gt;    &lt;set&gt;      &lt;bean class=&quot;cn.itcast.utils.StringToDateConverter&quot;/&gt;    &lt;/set&gt;  &lt;/property&gt;&lt;/bean&gt;&lt;!-- 开启SpringMVC框架注解的支持 --&gt;&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt;\n\n解决中文乱码在web.xml中\n&lt;!--配置解决中文乱码的过滤器--&gt;&lt;filter&gt;  &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;  &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;  &lt;init-param&gt;    &lt;param-name&gt;encoding&lt;/param-name&gt;    &lt;param-value&gt;UTF-8&lt;/param-value&gt;  &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;  &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;\n\n获取Servlet原生的API直接在方法上加参数即可\n@RequestMapping(&quot;/testServlet&quot;)public String testServlet(HttpServletRequest request, HttpServletResponse response)&#123;  System.out.println(&quot;执行了...&quot;);  System.out.println(request);  HttpSession session = request.getSession();  System.out.println(session);  ServletContext servletContext = session.getServletContext();  System.out.println(servletContext);  System.out.println(response);  return &quot;success&quot;;&#125;","categories":["Note"],"tags":["springmvc"]},{"title":"Underwelming","url":"/2020/04/06/excerpt/","content":"\n软件最大的好处就是让一切变得简单。但是，做到这一点的方法是正确设置默认值，而不是限制用户的选择。\n—— Paul Graham《黑客与画家》\n\n上次看这本书的时候都没有注意到这句话\n这次见到视线都挪不走了\n可能是Spring后遗症\n想起曾经某次听到的介绍Apple Design Award Winning App\n其中Pixelmator Photo的魔法棒可以用”Underwelming”来形容\n不仅是正确设置默认值，同时动态展示诸多参数的变化，让用户看到变化的起因和结果\n\n\nReaveal what’s behind the App’s intelligence\n\nAllow adjustments\n\n\n\n这条规律似乎适用很广呢\n唉 这么看的话之前自己的App为了简化操作而疯狂缩减可调节的参数实在不妥\n","categories":["Memo"]},{"title":"SpringMVC笔记04 响应数据和结果视图","url":"/2020/04/06/note-springmvc-04/","content":"\nhttps://www.bilibili.com/video/BV1Sb411s7qa\nP25~32\n\n返回值类型字符串@RequestMapping(&quot;/testReturnString&quot;) public String testReturnString() &#123;  return &quot;success&quot;; &#125;\n\n返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址\n此处返回”success”将跳转到success.jsp\n应用\n从数据库中取User并存入Model\n@RequestMapping(&quot;/testReturnString&quot;) public String testReturnString(Model model) &#123;  // 模拟从数据库查询出User对象  User user = new User();  user.setUsername(&quot;ha&quot;);    // 存入Model  model.addAttribute(&quot;user&quot;,user);    // 跳转到success.jsp  return &quot;success&quot;; &#125;\n\n在success.jsp中取出User\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h3&gt;执行成功&lt;/h3&gt;    $&#123;user.username&#125;    $&#123;user.password&#125;&lt;/body&gt;&lt;/html&gt;\n\nvoid@RequestMapping(&quot;/testVoid&quot;) public void testReturnString() &#123;&#125;\n\n如果没有返回值，默认根据请求路径跳转，如此处会找testVoid.jsp\n修改需要用到Request、Response对象\n@RequestMapping(&quot;/testVoid&quot;) public void testReturnString(HttpServletRequest request,HttpServletResponse response) throws Exception &#123;  // 请求转发  request.getRequestDispatcher(&quot;/WEB-INF/pages/success.jsp&quot;).forward(request, response);&#125;\n\n也可以用response重定向\n// 例1response.sendRedirect(request.getContextPath()+&quot;index.jsp&quot;);// 例2response.sendRedirect(&quot;testRetrunString&quot;);\n\n或者指定响应结果，例如响应json数据\nresponse.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;application/json;charset=utf-8&quot;); response.getWriter().write(&quot;HELLO&quot;);\n\nModelAndViewModelAndView 是 SpringMVC 提供的一个对象\n内部有一个Model，可以存数据\n@RequestMapping(&quot;/testReturnModelAndView&quot;) public ModelAndView testReturnModelAndView() &#123;  // 创建ModelAndView对象\tModelAndView mv = new ModelAndView();     // 模拟从数据库查询出User对象  User user = new User();  user.setUsername(&quot;ha&quot;);    // 可以存对象  mv.addObject(&quot;user&quot;,user);  // 也可以直接存键值对  mv.addObject(&quot;username&quot;, &quot;张三&quot;);     // 指定跳转到哪个页面  mv.setViewName(&quot;success&quot;);    return mv;&#125;\n\n转发和重定向使用关键字进行转发和重定向时，无法使用视图解析器，需要自己写路径，用得不多\nforward@RequestMapping(&quot;/testForward&quot;) public String testForward() &#123;  return &quot;forward:/WEB-INF/pages/success.jsp&quot;; &#125;\n\n路径必须写实际视图url，不能写逻辑视图\n既可以转发到jsp，也可以转发到其他的控制器方法\nredirect@RequestMapping(&quot;/testRedirect&quot;) public String testRedirect() &#123;  // return &quot;redirect:/index.jsp&quot;  return &quot;redirect:testReturnModelAndView&quot;; &#125;\n\n如果重定向到jsp页面，页面不能再WEB-INF中，会找不到\n响应json使用@ResponseBody 注解实现将 controller 方法返回对象转换为 json 响应给客户端\n在webapp目录下新建js文件夹，把jquery.main.js复制进去，要用的jsp中引入\nresponse.jsp\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        // 页面加载，绑定单击事件        $(function()&#123;            $(&quot;#btn&quot;).click(function()&#123;                 alert(&quot;hello btn&quot;);            &#125;);        &#125;);    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;button id=&quot;btn&quot;&gt;发送ajax的请求&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;\n\n然而此时在页面中点击按钮，不会有响应\n因为虽然引入了jquery.min.js\n但是在web.xml中配置的DispatcherServlet拦截路径”/“，也会拦截静态的资源文件\n过滤静态资源在springmvc.xml中配置\n&lt;!--前端控制器，哪些静态资源不拦截--&gt;&lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot;/&gt;&lt;mvc:resources location=&quot;/images/&quot; mapping=&quot;/images/**&quot;/&gt;&lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot;/&gt;\n\n配置之后再点击按钮，就会有弹框了\n发送ajax请求&lt;script&gt;  // 页面加载，绑定单击事件  $(function()&#123;    $(&quot;#btn&quot;).click(function()&#123;      // 发送ajax请求      $.ajax(&#123;        // 编写json格式，设置属性和值        url:&quot;user/testAjax&quot;,        contentType:&quot;application/json;charset=UTF-8&quot;,        data:&#x27;&#123;&quot;username&quot;:&quot;hehe&quot;,&quot;password&quot;:&quot;123&quot;,&quot;age&quot;:30&#125;&#x27;,        dataType:&quot;json&quot;,        type:&quot;post&quot;,        success:function(data)&#123;          // data是服务器端响应的json数据          alert(data);          alert(data.username);          alert(data.password);          alert(data.age);        &#125;      &#125;);    &#125;);  &#125;);&lt;/script&gt;\n\n响应json格式数据Springmvc 默认用 MappingJacksonHttpMessageConverter 对 json 数据进行转换，需要加入 jackson 的包\n&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;  &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;  &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;  &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;\n\n客户端发送的ajax请求，传的是json字符串，后端将其封装到user对象中\n// 模拟异步请求响应@RequestMapping(&quot;/testAjax&quot;)public @ResponseBody User testAjax(@RequestBody User user)&#123;  // 响应，模拟查询数据库  user.setUsername(&quot;haha&quot;);  user.setAge(40);  return user;&#125;\n\n加@ResponseBody，把user转成json\n","categories":["Note"],"tags":["springmvc"]},{"title":"SpringMVC笔记03 常用注解","url":"/2020/04/04/note-springmvc-03/","content":"\nhttps://www.bilibili.com/video/BV1Sb411s7qa\nP17~24\n\nRequestParam作用：把请求中的指定名称的参数传递给控制器中的形参赋值\n属性：\n\nvalue：请求参数中的名称\nrequired：请求参数中是否必须提供此参数，默认值是true，必须提供\n\n如，方法中需要name属性，但是url中传的是username属性，就会封装不上\n可以用@RequestParam修饰参数\n@RequestMapping(path=&quot;/hello&quot;)public String sayHello(@RequestParam(value=&quot;username&quot;,required=false)String name) &#123;  System.out.println(name);   return &quot;success&quot;;&#125;\n\nRequestBody作用：用于获取请求体的内容（get方法不适用）\n直接使用得到的是key=value&amp;key=value结构的数据\n属性：\n\nrequired：是否必须有请求体，默认值是true\n\n&lt;form action=&quot;anno/testRequestBody&quot; method=&quot;post&quot;&gt;  用户姓名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt;  用户年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot; /&gt;&lt;br/&gt;  &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;\n\n@RequestMapping(path=&quot;/testRequestBody&quot;)public String sayHello(@RequestBody String body) &#123;\tSystem.out.println(body);  return &quot;success&quot;;&#125;\n\n后面传json数据时会用到\nPathVariable作用：用于绑定 url 中的占位符（如:请求 /delete/{id}中的{id}）\n用于支持RESTful风格\n属性：\n\nvalue：用于指定 url 中占位符名称\nrequired：是否必须提供占位符\n\n&lt;a href=&quot;springmvc/usePathVariable/100&quot;&gt;pathVariable 注解&lt;/a&gt;\n\n@RequestMapping(&quot;/usePathVariable/&#123;id&#125;&quot;)public String usePathVariable(@PathVariable(&quot;id&quot;) Integer id)&#123;\tSystem.out.println(id);\treturn &quot;success&quot;; &#125;\n\n用RESTful风格时\n由于浏览器form表单只支持GET与POST请求，而不支持DELETE、PUT\nSpring3.0提供了一个过滤器HiddentHttpMethodFilter，可以将浏览器请求修改为指定方式，但比较麻烦\n还有WebClient类可以使用静态方法模拟各种请求方式\n或者可以给浏览器装插件\nRequestHeader作用：获取请求消息头\n属性：\n\nvalue：提供消息头名称\nrequired：是否必须有此消息头\n\n@RequestMapping(&quot;/useRequestHeader&quot;)public String useRequestHeader(@RequestHeader(value=&quot;Accept-Language&quot;,required=false)String requestHeader)&#123;   System.out.println(requestHeader);\treturn &quot;success&quot;;&#125;\n\nCookieValue作用：获取Cookie的值\n属性：\n\nvalue：指定 cookie 的名称\nrequired：是否必须\n\n@RequestMapping(&quot;/useCookieValue&quot;)public String useCookieValue(@CookieValue(value=&quot;JSESSIONID&quot;,required=false) String cookieValue)&#123;\tSystem.out.println(cookieValue);\treturn &quot;success&quot;; &#125;\n\nModelAttribute作用：加在方法上，该方法在控制器的方法执行前先执行；加在参数上，获取指定的数据给参数赋值\n属性：\n\nvalue：用于获取数据的 key（key 可以是 POJO 的属性名称，也可以是 map 结构的 key）\n\n应用场景：\n表单提交数据不完整时，先从数据库查用户信息，没有提交数据的字段用原值\n&lt;!-- 修改用户信息 --&gt;&lt;form action=&quot;springmvc/updateUser&quot; method=&quot;post&quot;&gt;   用户名称:&lt;input type=&quot;text&quot; name=&quot;username&quot; &gt;&lt;br/&gt;\t用户年龄:&lt;input type=&quot;text&quot; name=&quot;age&quot; &gt;&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;保存&quot;&gt; &lt;/form&gt;\n\nModelAttribute 修饰方法带返回值@ModelAttributepublic User showModel(String username) &#123;   //模拟去数据库查询\tUser abc = findUserByName(username);   System.out.println(&quot;执行了 showModel 方法&quot;+abc);\treturn abc; &#125;@RequestMapping(&quot;/updateUser&quot;)public String testModelAttribute(User user) &#123;\tSystem.out.println(&quot;控制器中处理请求的方法:修改用户:&quot;+user);\treturn &quot;success&quot;; &#125;\n\nModelAttribute 修饰方法不带返回值放到map中\n@ModelAttributepublic void showModel(String username,Map&lt;String,User&gt; map) &#123;  //模拟去数据库查询\tUser user = findUserByName(username);   System.out.println(&quot;执行了 showModel 方法&quot;+user);   map.put(&quot;abc&quot;,user);&#125;@RequestMapping(&quot;/updateUser&quot;)public String testModelAttribute(@ModelAttribute(&quot;abc&quot;)User user) &#123;\tSystem.out.println(&quot;控制器中处理请求的方法:修改用户:&quot;+user);\treturn &quot;success&quot;; &#125;\n\nSessionAttribute作用：多次执行控制器方法间的参数共享\n属性：\n\nvalue：指定存入的属性名称\ntype：指定存入的数据类型\n\n&lt;!-- SessionAttribute 注解的使用 --&gt;&lt;a href=&quot;springmvc/testPut&quot;&gt;存入SessionAttribute&lt;/a&gt; &lt;hr/&gt;&lt;a href=&quot;springmvc/testGet&quot;&gt;取出SessionAttribute&lt;/a&gt; &lt;hr/&gt;&lt;a href=&quot;springmvc/testClean&quot;&gt;清除SessionAttribute&lt;/a&gt;\n\n@Controller(&quot;sessionAttributeController&quot;)@RequestMapping(&quot;/springmvc&quot;)@SessionAttributes(value =&#123;&quot;username&quot;,&quot;password&quot;&#125;,types=&#123;Integer.class&#125;) public class SessionAttributeController &#123;  @RequestMapping(&quot;/testPut&quot;)  public String testPut(Model model)&#123;    model.addAttribute(&quot;username&quot;, &quot;泰斯特&quot;);    model.addAttribute(&quot;password&quot;,&quot;123456&quot;);    return &quot;success&quot;;  &#125;    @RequestMapping(&quot;/testGet&quot;)\tpublic String testGet(ModelMap model)&#123;    System.out.println(model.get(&quot;username&quot;)+&quot;;&quot;+model.get(&quot;password&quot;));\t\treturn &quot;success&quot;;   &#125;    @RequestMapping(&quot;/testClean&quot;)\tpublic String complete(SessionStatus sessionStatus)&#123;\t\tsessionStatus.setComplete();\t\treturn &quot;success&quot;;   &#125;  &#125;\n\n","categories":["Note"],"tags":["springmvc"]},{"title":"SpringMVC笔记05 文件上传","url":"/2020/04/06/note-springmvc-05/","content":"\nhttps://www.bilibili.com/video/BV1Sb411s7qa\nP33~38\n\n传统方式上传的文件和访问的应用在同一台服务器上\n依赖使用 Commons-fileupload 组件\n&lt;dependency&gt;  &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;  &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;  &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;commons-io&lt;/groupId&gt;  &lt;artifactId&gt;commons-io&lt;/artifactId&gt;  &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt;\n\njsp页面&lt;form action=&quot;/user/fileupload1&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;  选择文件：&lt;input type=&quot;file&quot; name=&quot;upload&quot; /&gt;&lt;br/&gt;  &lt;input type=&quot;submit&quot; value=&quot;上传&quot; /&gt;&lt;/form&gt;\n\n控制器// 使用fileupload组件完成文件上传@RequestMapping(&quot;/fileupload1&quot;)public String fileuoload1(HttpServletRequest request) throws Exception &#123;    // 上传的位置  String path = request.getSession().getServletContext().getRealPath(&quot;/uploads/&quot;);  // 判断路径是否存在  File file = new File(path);  if(!file.exists())&#123;    // 创建该文件夹    file.mkdirs();  &#125;  // 解析request对象，获取上传文件项  DiskFileItemFactory factory = new DiskFileItemFactory();  ServletFileUpload upload = new ServletFileUpload(factory);  // 解析request  List&lt;FileItem&gt; items = upload.parseRequest(request);  // 遍历  for(FileItem item:items)&#123;    // 判断当前item对象是否是上传文件项    if(item.isFormField())&#123;      // 普通表单向    &#125;else&#123;      // 获取上传文件的名称      String filename = item.getName();      // 把文件的名称设置唯一值，uuid      String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);      filename = uuid+&quot;_&quot;+filename;      // 完成文件上传      item.write(new File(path,filename));      // 删除临时文件      item.delete();    &#125;  &#125;  return &quot;success&quot;;&#125;\n\n测试上传后\n在target/uploads中找到上传的文件\nSpringMVC传统方式上传原理分析\n\njsp页面和传统方式一样\n&lt;form action=&quot;/user/fileupload2&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;  选择文件：&lt;input type=&quot;file&quot; name=&quot;upload&quot; /&gt;&lt;br/&gt;  &lt;input type=&quot;submit&quot; value=&quot;上传&quot; /&gt;&lt;/form&gt;\n\n配置文件解析器spingmvc.xml中\n&lt;!--配置文件解析器对象--&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;  &lt;property name=&quot;maxUploadSize&quot; value=&quot;10*1024*1024&quot; /&gt;&lt;/bean&gt;\n\n里面可以设置一些属性，如文件大小\n控制器@RequestMapping(&quot;/fileupload2&quot;)public String fileuoload2(HttpServletRequest request, MultipartFile upload) throws Exception &#123;  // 上传的位置  String path = request.getSession().getServletContext().getRealPath(&quot;/uploads/&quot;);  // 判断该路径是否存在  File file = new File(path);  if(!file.exists())&#123;    // 创建该文件夹    file.mkdirs();  &#125;  // 获取上传文件的名称  String filename = upload.getOriginalFilename();  // 把文件的名称设置唯一值，uuid  String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);  filename = uuid+&quot;_&quot;+filename;  // 完成文件上传  upload.transferTo(new File(path,filename));  return &quot;success&quot;;&#125;\n\n相较传统方式，省了解析操作，简化上传步骤\nSpringMVC跨服务器上传\n\n用2个tomcat服务器，文件服务器端口号此处用的9090\n文件服务器新建一个工程\n在webapp下新建uploads文件夹用来存文件\n启动\n依赖&lt;dependency&gt;  &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt;  &lt;artifactId&gt;jersey-core&lt;/artifactId&gt;  &lt;version&gt;1.18.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt;  &lt;artifactId&gt;jersey-client&lt;/artifactId&gt;  &lt;version&gt;1.18.1&lt;/version&gt;&lt;/dependency&gt;\n\njsp页面仍没什么区别\n&lt;form action=&quot;/user/fileupload3&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;  选择文件：&lt;input type=&quot;file&quot; name=&quot;upload&quot; /&gt;&lt;br/&gt;  &lt;input type=&quot;submit&quot; value=&quot;上传&quot; /&gt;&lt;/form&gt;\n\n控制器@RequestMapping(&quot;/fileupload3&quot;)public String fileuoload3(MultipartFile upload) throws Exception &#123;  // 定义上传文件服务器路径  String path = &quot;http://localhost:9090/uploads/&quot;;  // 获取上传文件的名称  String filename = upload.getOriginalFilename();  // 把文件的名称设置唯一值，uuid  String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);  filename = uuid+&quot;_&quot;+filename;  // 创建客户端的对象  Client client = Client.create();  // 和图片服务器进行连接  WebResource webResource = client.resource(path + filename);  // 上传文件  webResource.put(upload.getBytes());  return &quot;success&quot;;&#125;\n\n出现409异常可以手动创建一下uploads文件夹\n","categories":["Note"],"tags":["springmvc"]},{"title":"SpringMVC笔记06 异常处理与拦截器","url":"/2020/04/07/note-springmvc-06/","content":"\nhttps://www.bilibili.com/video/BV1Sb411s7qa\nP39~45\n\n异常处理\n\n如果什么都不做，产生异常时（模拟可以除0），会出现500 Internal Server Error\n教务系统就是这样🙃\n解决步骤\n\n编写自定义异常类（用作提示信息）\n编写异常处理器\n配置异常处理器（跳转到提示页面）\n\n自定义异常类public class SysException extends Exception&#123;    // 存储提示信息    private String message;    // get set constructor ...&#125;\n\n控制器捕获异常，抛自定义异常\n@RequestMapping(&quot;/testException&quot;)    public String testException() throws SysException&#123;        try &#123;            // 模拟异常            int a = 10/0;        &#125; catch (Exception e) &#123;            e.printStackTrace();            // 抛出自定义异常信息            throw new SysException(&quot;查询所有用户出现错误了...&quot;);        &#125;        return &quot;success&quot;;    &#125;\n\n异常处理器实现HandlerExceptionResolver接口\npublic class SysExceptionResolver implements HandlerExceptionResolver&#123;  \t// 处理异常的逻辑    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123;        // 获取到异常对象        SysException e = null;        if(ex instanceof SysException)&#123;            e = (SysException)ex;        &#125;else&#123;            e = new SysException(&quot;系统正在维护....&quot;);        &#125;        // 创建ModelAndView对象        ModelAndView mv = new ModelAndView();        mv.addObject(&quot;errorMsg&quot;,e.getMessage());        mv.setViewName(&quot;error&quot;);        return mv;    &#125;&#125;\n\n配置异常处理器在springmvc.xml中\n&lt;!--配置异常处理器--&gt;&lt;bean id=&quot;sysExceptionResolver&quot; class=&quot;cn.itcast.exception.SysExceptionResolver&quot;/&gt;\n\n错误提示页面&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    $&#123;errorMsg&#125;&lt;/body&gt;&lt;/html&gt;\n\n拦截器SpringMVC的拦截器用于对处理器进行预处理和后处理，类似Servlet的过滤器 Filter\n是AOP的体现\n拦截器链\n将拦截器按一定的顺序联结成一条链，按顺序调用\n与过滤器的区别\n过滤器是Servlet规范中的一部分，任何java web工程都可以用；拦截器是Spring MVC框架的\n过滤器在url-pattern中配置了”/*”后，可以对所有要访问的资源拦截；拦截器只会拦截访问的控制器方法，不会拦截jsp、html等\n使用步骤\n\n编写拦截器，实现HandlerInterceptor接口\n配置拦截器\n\n控制器@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123;    @RequestMapping(&quot;/testInterceptor&quot;)    public String testInterceptor()&#123;        System.out.println(&quot;testInterceptor执行了...&quot;);        return &quot;success&quot;;    &#125;&#125;\n\n自定义拦截器public class MyInterceptor1 implements HandlerInterceptor&#123;  \t// 预处理，controller方法执行前  \t// return true 放行，执行下一个拦截器，如果没有，执行controller中的方法    // return false 不放行    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        System.out.println(&quot;MyInterceptor1执行了...前&quot;);      \t// 也可以请求转发        // request.getRequestDispatcher(&quot;/WEB-INF/pages/error.jsp&quot;).forward(request,response);        return true;    &#125;    // 后处理方法，controller方法执行后，success.jsp执行之前    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;        System.out.println(&quot;MyInterceptor1执行了...后&quot;);    &#125;    // success.jsp页面执行后，该方法会执行    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;        System.out.println(&quot;MyInterceptor1执行了...最后&quot;);    &#125;&#125;\n\n配置springmvc.xml中\n&lt;!--配置拦截器--&gt;&lt;mvc:interceptors&gt;  &lt;mvc:interceptor&gt;    &lt;!--要拦截的具体的方法--&gt;    &lt;mvc:mapping path=&quot;/user/*&quot;/&gt;    &lt;!--不要拦截的方法            &lt;mvc:exclude-mapping path=&quot;&quot;/&gt; --&gt;    &lt;!--配置拦截器对象--&gt;    &lt;bean class=&quot;cn.itcast.controller.cn.itcast.interceptor.MyInterceptor1&quot; /&gt;  &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;\n\n要拦截的方法和不要拦截的方法配置一个就可以了\n这样配置拦截器后，测试输出为\nMyInterceptor1执行了...前testInterceptor执行了MyInterceptor1执行了...后success.jsp执行了MyInterceptor1执行了...最后\n\n2个拦截器\n\n拦截器代码和第一个一样\n配置\n&lt;mvc:interceptors&gt;  &lt;!--配置拦截器--&gt;  &lt;mvc:interceptor&gt;    &lt;mvc:mapping path=&quot;/user/*&quot;/&gt;    &lt;!--配置拦截器对象--&gt;    &lt;bean class=&quot;cn.itcast.controller.cn.itcast.interceptor.MyInterceptor1&quot; /&gt;  &lt;/mvc:interceptor&gt;  &lt;!--配置第二个拦截器--&gt;  &lt;mvc:interceptor&gt;    &lt;!--拦截所有方法--&gt;    &lt;mvc:mapping path=&quot;/**&quot;/&gt;    &lt;!--配置拦截器对象--&gt;    &lt;bean class=&quot;cn.itcast.controller.cn.itcast.interceptor.MyInterceptor2&quot; /&gt;  &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;\n\n输出\nMyInterceptor1执行了...前1MyInterceptor1执行了...前2testInterceptor执行了MyInterceptor1执行了...后2MyInterceptor1执行了...后1success.jsp执行了MyInterceptor1执行了...最后2MyInterceptor1执行了...最后1\n\n","categories":["Note"],"tags":["springmvc"]},{"title":"SpringMVC笔记07 SSM整合","url":"/2020/04/07/note-springmvc-07/","content":"\nhttps://www.bilibili.com/video/BV1Sb411s7qa\nP46~54\n\n三层架构\n\n\n先保证每个框架能单独运行\n然后用Spring整合另外2个\n准备数据库account表，以前建过了，继续用\n\n\n搭建环境创建Maven工程，选webapp\n解决创建项目过慢，加一对archetypeCatalog：internal\npom.xml版本锁定\n&lt;properties&gt;  &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;  &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;  &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;  &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;  &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt;  &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt;  &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt;  &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt;&lt;/properties&gt;\n\n加依赖\n\n\n&lt;dependencies&gt;  &lt;!-- spring IOC --&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;  &lt;/dependency&gt;  &lt;!-- spring AOP --&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;    &lt;version&gt;1.6.8&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;  &lt;/dependency&gt;  &lt;!-- JdbcTemplate --&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;  &lt;/dependency&gt;  &lt;!-- 事务 --&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;  &lt;/dependency&gt;  &lt;!-- 测试 --&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;    &lt;version&gt;4.12&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;  &lt;/dependency&gt;  &lt;!-- mysql驱动 --&gt;  &lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt;  &lt;/dependency&gt;  &lt;!-- 连接池 --&gt;  &lt;dependency&gt;    &lt;groupId&gt;c3p0&lt;/groupId&gt;    &lt;artifactId&gt;c3p0&lt;/artifactId&gt;    &lt;version&gt;0.9.1.2&lt;/version&gt;    &lt;type&gt;jar&lt;/type&gt;    &lt;scope&gt;compile&lt;/scope&gt;  &lt;/dependency&gt;  &lt;!-- spring MVC --&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;  &lt;/dependency&gt;  &lt;!-- servlet --&gt;  &lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;    &lt;version&gt;2.5&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;    &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;    &lt;version&gt;2.0&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;  &lt;/dependency&gt;  &lt;!-- jsp标签 --&gt;  &lt;dependency&gt;    &lt;groupId&gt;jstl&lt;/groupId&gt;    &lt;artifactId&gt;jstl&lt;/artifactId&gt;    &lt;version&gt;1.2&lt;/version&gt;  &lt;/dependency&gt;  &lt;!-- log --&gt;  &lt;dependency&gt;    &lt;groupId&gt;log4j&lt;/groupId&gt;    &lt;artifactId&gt;log4j&lt;/artifactId&gt;    &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;    &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;    &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;  &lt;/dependency&gt;  &lt;!-- mybatis --&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;    &lt;version&gt;1.3.0&lt;/version&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;\n\n创建目录java和resources文件夹\n\n\n用到的类\n\n\nAccount三个属性\nprivate Integer id;private String name;private Double money;\n\n做2个方法\npublic List&lt;Account&gt; findAll();public void saveAccount(Account account);\n\nSpring框架配置 applicationContext.xmlresources下新建applicationContext.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\thttp://www.springframework.org/schema/beans/spring-beans.xsd\thttp://www.springframework.org/schema/context\thttp://www.springframework.org/schema/context/spring-context.xsd\thttp://www.springframework.org/schema/aop\thttp://www.springframework.org/schema/aop/spring-aop.xsd\thttp://www.springframework.org/schema/tx\thttp://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;    &lt;!-- 开启注解的扫描，希望处理service和dao，controller不需要Spring框架去处理 --&gt;    &lt;context:component-scan base-package=&quot;com.coconutnut&quot; &gt;        &lt;!-- 配置哪些注解不扫描 --&gt;        &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt;    &lt;/context:component-scan&gt;&lt;/beans&gt;\n\ncontroller是表现层的，Spring框架不管\n加注解@Service(&quot;accountService&quot;)public class AccountServiceImpl implements IAccountService &#123;    @Override    public List&lt;Account&gt; findAll() &#123;        System.out.println(&quot;业务层：查询所有&quot;);        return null;    &#125;    @Override    public void saveAccount(Account account) &#123;        System.out.println(&quot;业务层：保存账户&quot;);    &#125;&#125;\n\n测试用junit单元测试\npublic class TestSpring &#123;    @Test    public void test()&#123;        // 加载配置文件        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);        // 获取对象        IAccountService as = (IAccountService) ac.getBean(&quot;accountService&quot;);        // 调用方法        as.findAll();    &#125;&#125;\n\n\n\nWARNING说没有log4j的配置文件\n复制一个log4j.properties到resources目录下即可\n# Set root category priority to INFO and its only appender to CONSOLE.#log4j.rootCategory=INFO, CONSOLE            debug   info   warn error fatallog4j.rootCategory=info, CONSOLE, LOGFILE# Set the enterprise logger category to FATAL and its only appender to CONSOLE.log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE# CONSOLE is set to be a ConsoleAppender using a PatternLayout.log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\\n# LOGFILE is set to be a File appender using a PatternLayout.log4j.appender.LOGFILE=org.apache.log4j.FileAppenderlog4j.appender.LOGFILE.File=/Users/coconutnut/TREE/Midgard/Idea/SSM/axis.loglog4j.appender.LOGFILE.Append=truelog4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayoutlog4j.appender.LOGFILE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\\n\n\n要改一下路径\nSpringMVC框架配置 web.xmlWEB-INF文件夹下的web.xml\n&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;!-- 配置前端控制器 --&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;!-- 加载springmvc.xml配置文件 --&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;!-- 启动服务器，创建该servlet --&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;  &lt;!-- 解决中文乱码的过滤器 --&gt;  &lt;filter&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;&lt;/web-app&gt;\n\n配置 springmvc.xmlresources文件夹下新建springmvc.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- 开启注解扫描，只扫描Controller注解 --&gt;    &lt;context:component-scan base-package=&quot;com.coconutnut&quot;&gt;        &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt;    &lt;/context:component-scan&gt;    &lt;!--配置的视图解析器对象--&gt;    &lt;bean id=&quot;internalResourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;/&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;    &lt;/bean&gt;    &lt;!--过滤静态资源--&gt;    &lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot; /&gt;    &lt;mvc:resources location=&quot;/images/&quot; mapping=&quot;/images/**&quot; /&gt;    &lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot; /&gt;    &lt;!--开启SpringMVC注解的支持--&gt;    &lt;mvc:annotation-driven/&gt;&lt;/beans&gt;\n\n页面index.jsp中加一个超链接\n&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;a href=&quot;account/findAll&quot;&gt;测试&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;\n\nWEB-INF中新建pages文件夹，新建list.jsp\n&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h3&gt;查询所有的账户信息&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt;\n\n控制器@Controller@RequestMapping(&quot;/account&quot;)public class AccountController &#123;    @RequestMapping(&quot;/findAll&quot;)    public String findAll()&#123;        System.out.println(&quot;表现层：查询所有&quot;);        return &quot;TODO&quot;;    &#125;&#125;\n\n部署\n\n测试\n\n\n\nSpring整合SpringMVC目标：Controller中调用业务层方法\n方法：要把Service注入到Controller中\n问题：web.xml中配置了springmvc.xml，springmvc.xml中配置了对Controller的扫描，其它扫描的配置在applicationContext.xml中，而这个文件始终没有被加载过\n解决：启动tomcat服务器时，加载Spring的配置文件applicationContext.xml\nServletContext对象生命周期和服务器相同，可以用监听器监听其创建和销毁\n于是，可以在web.xml中用监听器加载Spring的配置文件\n监听器是spring-web提供的\n它默认只加载WEB-INF目录下的applicationContext.xml配置文件\n可以复制一份丢到WEB-INF目录，或者手动设置路径\n&lt;!-- 配置Spring的监听器，默认只加载WEB-INF目录下的applicationContext.xml配置文件 --&gt;&lt;listener&gt;  &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- 设置配置文件的路径 --&gt;&lt;context-param&gt;  &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;\n\n这样启动服务器时，Spring的配置文件也加载了\nService和Controller都放到容器中了\n于是可以在AccountController中进行依赖注入\n@Controller@RequestMapping(&quot;/account&quot;)public class AccountController &#123;    @Autowired    private IAccountService accountService;    @RequestMapping(&quot;/findAll&quot;)    public String findAll()&#123;        System.out.println(&quot;表现层：查询所有&quot;);        accountService.findAll();        return &quot;list&quot;;    &#125;&#125;\n\n测试点击浏览器中测试按钮\n\n\n成功\nMyBatis框架加注解public interface IAccountDao &#123;    @Select(&quot;select * from account&quot;)    public List&lt;Account&gt; findAll();    @Insert(&quot;insert into account (name,money) values (#&#123;name&#125;,#&#123;money&#125;)&quot;)    public void saveAccount(Account account);&#125;\n\n配置 sqlMapConfig.xml在resources中新建sqlMapConfig.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!-- 配置环境 --&gt;    &lt;environments default=&quot;mysql&quot;&gt;        &lt;environment id=&quot;mysql&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/groot?characterEncoding=utf8&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;iamgroot&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;!-- 引入映射配置文件 --&gt;    &lt;mappers&gt;        &lt;package name=&quot;com.coconutnut.dao&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\n\n测试public class TestMyBatis &#123;    @Test    public void test01() throws Exception &#123;        // 加载配置文件        InputStream in = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);        // 创建SqlSessionFactory对象        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);        // 创建SqlSession对象        SqlSession session = factory.openSession();        // 获取到代理对象        IAccountDao dao = session.getMapper(IAccountDao.class);        // 查询所有数据        List&lt;Account&gt; list = dao.findAll();        for(Account account : list)&#123;            System.out.println(account);        &#125;        // 关闭资源        session.close();        in.close();    &#125;     @Test    public void test02() throws Exception &#123;        Account account = new Account();        account.setName(&quot;熊大&quot;);        account.setMoney(400d);        // 加载配置文件        InputStream in = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);        // 创建SqlSessionFactory对象        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);        // 创建SqlSession对象        SqlSession session = factory.openSession();        // 获取到代理对象        IAccountDao dao = session.getMapper(IAccountDao.class);        // 保存        dao.saveAccount(account);        // 提交事务        session.commit();        // 关闭资源        session.close();        in.close();    &#125;&#125;\n\n测试查询\n\n\n测试保存\n\n\nSpring整合MyBatis目标：Service能调用Dao\n此时Service已经在容器中了，需要把生成的Dao的代理对象也存到容器中\n配置在Spring的配置文件applicationContext.xml中\n&lt;!-- Spring整合MyBatis框架 --&gt;&lt;!-- 配置连接池 --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;  &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;  &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/groot?characterEncoding=utf8&quot;/&gt;  &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt;  &lt;property name=&quot;password&quot; value=&quot;iamgroot&quot;/&gt;&lt;/bean&gt;&lt;!-- 配置SqlSessionFactory工厂 --&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt;&lt;!-- 配置AccountDao接口所在包 --&gt;&lt;bean id=&quot;mapperScanner&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;  &lt;property name=&quot;basePackage&quot; value=&quot;com.coconutnut.dao&quot;/&gt;&lt;/bean&gt;\n\n有了这段配置，sqlMapConfig.xml其实就不需要了，可以删除\n加注解在AccountDao上加@Repository注解\n在AccountServiceImpl中注入\n@Service(&quot;accountService&quot;)public class AccountServiceImpl implements IAccountService &#123;    @Autowired    private IAccountDao accountDao;    @Override    public List&lt;Account&gt; findAll() &#123;        System.out.println(&quot;业务层：查询所有&quot;);        return accountDao.findAll();    &#125;    @Override    public void saveAccount(Account account) &#123;        System.out.println(&quot;业务层：保存账户&quot;);        accountDao.saveAccount(account);    &#125;&#125;\n\n在AccountController中把查出的数据存入Model\n@Controller@RequestMapping(&quot;/account&quot;)public class AccountController &#123;    @Autowired    private IAccountService accountService;    @RequestMapping(&quot;/findAll&quot;)    public String findAll(Model model)&#123;        System.out.println(&quot;表现层：查询所有&quot;);        List&lt;Account&gt; list = accountService.findAll();        model.addAttribute(&quot;list&quot;,list);        return &quot;list&quot;;    &#125;&#125;\n\n页面在list.jsp中打印出来\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;查询所有的帐户&lt;/h3&gt;&lt;c:forEach items=&quot;$&#123;list&#125;&quot; var=&quot;account&quot;&gt;    $&#123;account.name&#125;&lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt;\n\n测试查询出了一个异常\n2020-04-07 12:31:59,102 36291  [r$PoolThread-#0] WARN  resourcepool.BasicResourcePool  - com.mchange.v2.resourcepool.BasicResourcePool$AcquireTask@64fe7a60 -- Acquisition Attempt Failed!!! Clearing pending acquires. While trying to acquire a needed new resource, we failed to succeed more than the maximum number of allowed acquisition attempts (30). Last acquisition attempt exception: java.sql.SQLException: Unknown system variable &#x27;tx_isolation&#x27;\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:1055)\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:956)\t...\n\n查询发现是mysql-connector-java版本太低导致\n在pom.xml中将\n&lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt;\n\n改为\n&lt;mysql.version&gt;5.1.48&lt;/mysql.version&gt;\n\n再试\n\n\n成功\n事务保存方法还需管理事务\nSpring中进行声明式事务管理，在applicationContext.xml中增加\n&lt;!--配置Spring框架声明式事务管理--&gt;&lt;!--配置事务管理器--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt;&lt;!--配置事务通知--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;  &lt;tx:attributes&gt;    &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;    &lt;tx:method name=&quot;*&quot; isolation=&quot;DEFAULT&quot;/&gt;  &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--配置AOP增强--&gt;&lt;aop:config&gt;  &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* com.coconutnut.service.impl.*ServiceImpl.*(..))&quot;/&gt;&lt;/aop:config&gt;\n\n页面在index.jsp中新增表单\n&lt;body&gt;    &lt;a href=&quot;account/findAll&quot;&gt;测试查询&lt;/a&gt;    &lt;h3&gt;测试保存&lt;/h3&gt;    &lt;form action=&quot;account/save&quot; method=&quot;post&quot;&gt;        姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;&lt;br/&gt;        金额：&lt;input type=&quot;text&quot; name=&quot;money&quot; /&gt;&lt;br/&gt;        &lt;input type=&quot;submit&quot; value=&quot;保存&quot;/&gt;&lt;br/&gt;    &lt;/form&gt;&lt;/body&gt;\n\n控制器增加save方法\n@RequestMapping(&quot;/save&quot;)public void save(Account account, HttpServletRequest request, HttpServletResponse response) throws IOException &#123;  accountService.saveAccount(account);  response.sendRedirect(request.getContextPath()+&quot;/account/findAll&quot;);  return;&#125;\n\n存完重定向到list页面\n测试保存\n\n点击保存\n\n\n成功\n项目结构","categories":["Note"],"tags":["springmvc"]},{"title":"刷题阶段一完工纪念！","url":"/2020/04/08/memo/","content":"这个目录终于完工了\nLeetCode从去年准备算法考试开始刷\n到现在刚好2222个硬币😃\n棒球帽！冲鸭！\n\n\n3月每日1题忘了1天 就那么 干干净净 无忧无虑的 忘了😭\n4月搞了张日历贴在床对面的白板上 但愿…\n\n最近周赛还不如刚开始做得好\n有一丝丝凄凉\n希望烧掉的脑细胞给新的神经回路提供养料了吧\n\n\n最近看到这张图觉得貌似很有道理\n放在这里\n不知道以后会不会有什么感受\n\n最后是一大条看板的完工记录\n\n\n快乐\n宅家运动计划进行中\n两个月没出门还轻了也是很震惊\n继续打卡！嘿咻！\n也许哪天就能劈叉了呢\n","categories":["Memo"],"tags":["algorithm"]},{"title":"SpringCloud笔记03 Hystrix断路器","url":"/2020/04/12/note-springcloud-03/","content":"\nhttps://blog.csdn.net/ThinkWon/article/details/103732497\n\nHystrix功能：服务降级、服务熔断、线程隔离、请求缓存、请求合并、服务监控等\n创建一个hystrix-service模块经过前面一系列扎心操作，这次创建的时候没有用Spring Initializer加依赖，直接改的pom.xml并修改版本\n@EnableCircuitBreaker开启断路器功能\npom中还要加一个依赖\n&lt;dependency&gt;&lt;groupId&gt;cn.hutool&lt;/groupId&gt;&lt;artifactId&gt;hutool-all&lt;/artifactId&gt;&lt;version&gt;5.1.0&lt;/version&gt;&lt;/dependency&gt;\n\n这个模块也添加了Ribbon的负载均衡功能\n但是pom中并没有配置这个依赖\n看了下依赖图发现是eureka-client依赖的\n\n\n服务降级在UserHystrixController中添加用于测试服务降级的接口\n在UserService中添加调用方法与服务降级方法，并添加@HystrixCommand注解\n启动eureka-server、user-service、hystrix-service服务\n\n\n关闭user-service服务重新测试该接口\n\n\n后面测试忽略某些异常降级、缓存、请求合并表现均和教程一样\n\n\nDEBUG：调用服务失败启动后注册中心\n\n\n调用测试方法后\n\n\n直接失败了？\n试试原服务地址\n\n\n没问题\n这个bug似曾相识\n上次在ribbon-service中添加了依赖\n&lt;dependency&gt;  &lt;groupId&gt;com.netflix.ribbon&lt;/groupId&gt;  &lt;artifactId&gt;ribbon-eureka&lt;/artifactId&gt;&lt;/dependency&gt;\n\nhystrix-service中也加一个试试\n注册中心多了警告\n\n\n运行*2\n还是失败了\n看下Maven\n\n\n加个版本\nribbon模块用的是2.3.0\n运行*3\n还是挂了\n拿源码的这三个模块试试\n\n\n是可以的\n对比版本\n\n\n全部改成一样的\n发现源码pom中还多了一个\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;\n\n以及\n&lt;dependencyManagement&gt;  &lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;      &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;      &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;      &lt;type&gt;pom&lt;/type&gt;      &lt;scope&gt;import&lt;/scope&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;&lt;/dependencyManagement&gt;\n\n难怪前面springframework-cloud的模块总是没有版本号，原来是没加这个\n（解决了前面笔记02中一个MARK）\n运行*4\n还🥶是🥶挂🥶了\n再来一个个比代码\n没差啊？\n难道是其它模块的依赖也要改？改吧\n发现前面大部分都是有dependencyManagement的，所以其实也没什么变动\n运行*5\n挂\n刚才把spring-boot-starter-actuator删了，重新加上\n运行*6\n！成功了\n可是这个时候其它版本都和源码一样了，但是源码没有用这个啊？-MARK-\n问题总结\n版本 版本 版本\n\n注册中心有，但找不到服务，试试加上\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n\n总结\n\n","categories":["Note"],"tags":["springcloud"]},{"title":"SpringCloud笔记01 Eureka注册中心","url":"/2020/04/08/note-springcloud-01/","content":"\nhttps://blog.csdn.net/ThinkWon/article/details/103726655\n\n\n\nSpring Cloud Netflix Eureka是Spring Cloud Netflix子项目的核心组件之一，主要用于微服务架构中的服务治理\n\n先疑惑了一下此Netflix是不是彼Netflix\n查了一下 Netflix是什么，与Spring Cloud有什么关系 还真是\n爱了爱了\n\n搭建Eureka注册中心\n创建eureka-server模块\n\n@EnableEurekaServer启用Euerka注册中心功能\n\napplication.yml添加配置\n项目默认是application.properties，为了和教程保持一致\n删除application.properties，执行 mvn -X clean install\n\nRun Dashboard运行应用\n\n浏览器打开注册中心\n\n\n\n\n成功\n\n依赖下了挺久，看眼都有些什么\n\n\n😱😱😱\n上面是spring-cloud-starter-netflix-eureka-server\n\n\n下面是spring-boot-starter-test\n\n\nDEBUG：没有Run Dashboard尝试1\n\nhttps://blog.csdn.net/chinoukin/article/details/80577890\n\n改.idea/workspace.xml的\n原本是这样\n&lt;component name=&quot;RunDashboard&quot;&gt;  &lt;option name=&quot;configurationTypes&quot;&gt;\t\t&lt;option value=&quot;SpringBootApplicationConfigurationType&quot; /&gt;  &lt;/option&gt;&lt;/component&gt;\n\n但是这个文件每次改了command+s就又回去了\n尝试2\n\nhttps://blog.csdn.net/feixiangsmile/article/details/96908744\n\nEdit Configurations中\nTemplates中\n点击加号添加Application和Spring Boot\nworkspace.xml变成了\n&lt;component name=&quot;RunDashboard&quot;&gt;  &lt;option name=&quot;configurationTypes&quot;&gt;    &lt;set&gt;      &lt;option value=&quot;Application&quot; /&gt;      &lt;option value=&quot;SpringBootApplicationConfigurationType&quot; /&gt;    &lt;/set&gt;  &lt;/option&gt;&lt;/component&gt;\n\n但还是没有\n尝试3\n\nhttps://www.cnblogs.com/JealousGirl/p/openorcloserundash.html\nhttps://blog.csdn.net/icebox126/article/details/78861943\n\n在workspace.xml中添加（这次可以加了）\n&lt;property name=&quot;show.run.dashboard.notification&quot; value=&quot;true&quot; /&gt;\n\n但是重启还是不会弹出提示\n尝试4\n\nhttps://intellij-support.jetbrains.com/hc/en-us/community/posts/115000428264-New-Spring-Boot-Run-dashboard-not-showing-up\nhttps://blog.csdn.net/jianxia801/article/details/99576764\n\n\n\n…\nfine\n原来一直都在啊\n\n\n搭建Eureka客户端\n创建eureka-client模块\n\n添加依赖\n\n加@EnableDiscoveryClient表明是一个Eureka客户端\n\n配置\n\n\nDEBUG：注册中心中没有显示eureka-client尝试1\n原来的pom.xml中的依赖\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;  &lt;scope&gt;test&lt;/scope&gt;  &lt;exclusions&gt;    &lt;exclusion&gt;      &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;      &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;    &lt;/exclusion&gt;  &lt;/exclusions&gt;&lt;/dependency&gt;\n\n教程中说要添加的依赖\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;\n\n一开始由于spring-cloud-starter-netflix-eureka-client已经有了\n直接添加了上面这个spring-boot-starter-web\n但是觉得好像有点问题？\nspring-boot-starter-test和spring-boot-starter-web会不会冲突呢?\n\n\n没冲突\n但是spring-boot-starter-test似乎多了很多东西（试了一下并不能删）\n尝试2\n看下报错\n2020-04-09 10:43:38.777 ERROR 1243 --- [           main] c.n.d.s.t.d.RedirectingEurekaHttpClient  : Request execution error. endpoint=DefaultEndpoint&#123; serviceUrl=&#x27;http://localhost:8001/eureka/&#125;com.sun.jersey.api.client.ClientHandlerException: java.net.ConnectException: Connection refused (Connection refused)\n\n好像干了个蠢事\n\n\n果然 服务器没开\n重来 先开eureka-server 再开eureka-client\n\n\n\n\n注册成功\n搭建Eureka注册中心集群目的：防止注册中心挂了整个垮掉 搭建双节点的注册中心集群\n\n2个配置文件\n（不知道原本的application.yml要不要删？看了下源码没有删）\n\n本机配置域名\nmacOS在/etc/hosts\n改之前的存个档\n### Host Database## localhost is used to configure the loopback interface# when the system is booting.  Do not change this entry.##127.0.0.1\tlocalhost255.255.255.255\tbroadcasthost::1             localhost127.0.0.1 xmind.net127.0.0.1 www.xmind.net\n\n加两行\n127.0.0.1 replica1127.0.0.1 replica2\n\n启动\n\n修改配置，让eureka-client连接到集群\n\n\n# 配置注册中心地址# defaultZone: http://localhost:8001/eureka# 同时注册到两个注册中心defaultZone: http://replica1:8002/eureka/,http://replica2:8003/eureka/\n\nDEBUG：服务器没有注册复制一份原启动配置，修改为从replica1启动\n\n\nRun\n\n\n发现有备份，但是没有注册？\n\n\n似乎是只复制了一份配置，replica2没有启动\n加上\n\n\n好了\n\n\n给Eureka注册中心添加认证\n创建eureka-security-server模块\n添加依赖\n配置pom.xml\n添加WebSecurityConfig\neureka-client注册到有登录认证的注册中心\n以application-security.yml配置运行eureka-client\n\nDEBUG：SpringSecurity模块要添加SpringSecurity模块，也许是Spring Cloud Security下的Cloud Security？先试试\n创建出的pom.xml中依赖是\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;  &lt;scope&gt;test&lt;/scope&gt;  &lt;exclusions&gt;    &lt;exclusion&gt;      &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;      &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;    &lt;/exclusion&gt;  &lt;/exclusions&gt;&lt;/dependency&gt;\n\n教程中要加的依赖是\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;\n\n好像不是这个\n重新创建\n这次直接搜索Spring Security 发现有这个模块\n\n\n（最后发现都行，且没必要创建时添加，随时在pom.xml中修改都可）\nDEBUG：新的模块没有被识别为Maven项目\nhttps://www.jianshu.com/p/909eb8a48d49\n\n右边Maven栏＋对应的pom.xml\nDEBUG：启动报错&amp;Whitelabel Error Page\n\n\nhttps://blog.csdn.net/qq_28379809/article/details/102789716\n\n添加依赖\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;\n\n启动\n\n\n输入账号密码\n\n\n发现EurekaSecurityServerApplication没有加@EnableEurekaServer\n\n\npom.xml中有spring-cloud-starter-netflix-eureka-server，为什么导不进来呢\n和eureka-server的配置比较，发现少一句\n&lt;spring-cloud.version&gt;Hoxton.SR3&lt;/spring-cloud.version&gt;\n\n加上\n还是不行\n源码中是\n&lt;spring-cloud.version&gt;Hoxton.RELEASE&lt;/spring-cloud.version&gt;\n\n现在的依赖\n&lt;dependencies&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;    &lt;exclusions&gt;      &lt;exclusion&gt;        &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;        &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;      &lt;/exclusion&gt;    &lt;/exclusions&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;    &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-netflix-eureka-server&lt;/artifactId&gt;    &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;\n\n源码中的依赖\n&lt;dependencies&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;    &lt;exclusions&gt;      &lt;exclusion&gt;        &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;        &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;      &lt;/exclusion&gt;    &lt;/exclusions&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;\n\n复制过去\nReimport Maven Projects\n发现正在下载的进度条\n所以难道刚才是因为依赖还没下载完吗\n下载完成\n全红了…\n\n\n改回原本的依赖 删掉spring-boot-starter-web 不红了\n启动\n\n\n🙃\n仔细看下源码的配置是\n&lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt;\n\n而不是\n&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;\n\n所以难道还是应该引入Spring Cloud Security模块？\n重新创建试试\n成功！\nDEBUG：以application-security.yml配置运行eureka-client现在eureka-client有2个yml\n\n\n直接运行还是application.yml的8101端口\n根据刚才eureka-server的多个yml\n是修改了指定主机地址\n# application.ymleureka:  instance:    hostname: localhost\n\n# application-replica1.ymleureka:  instance:    hostname: replica1\n\n# application-replica2.ymleureka:  instance:    hostname: replica2\n\n然后在Edit Configurations中复制Configuration，然后修改主机名\n于是这里也加上指定主机名\ninstance:  hostname: eureka-client-security\n\n复制一个EurekaClientApplication的配置，Active profiles处改为主机名\n\n\n但还是8101？\n\n\n观察发现\nServer的配置文件1叫application-replica1.yml，hostname是replica1，Active profiles填的replica1\n配置文件2叫application-replica2.yml，hostname是replica2，Active profiles填的replica2\n难道…\n把Client的application-security.yml中改成\ninstance:  hostname: security\n\nActive profiles改成security\nRun\n\n\n打开了！\n\n\n有个EMERGENCY! \n保护机制后面再看\n先试试这个指定yml到底是怎么指定的\n\n\n\n文件名\nhostname\nActive profiles\n能否启动\n\n\n\napplication-security.yml\neureka-client-security\neureka-client-security\n否\n\n\napplication-security.yml\nsecurity\nsecurity\n可\n\n\napplication-security.yml\nsecurityX\nsecurity\n可\n\n\napplication-securityX.yml\nsecurity\nsecurity\n否\n\n\n看来Active profiles要填文件名后面的部分\n教程最下面的常用配置\neureka:  client: #eureka客户端配置    register-with-eureka: true #是否将自己注册到eureka服务端上去    fetch-registry: true #是否获取eureka服务端上注册的服务列表    service-url:      defaultZone: http://localhost:8001/eureka/ # 指定注册中心地址    enabled: true # 启用eureka客户端    registry-fetch-interval-seconds: 30 #定义去eureka服务端获取服务列表的时间间隔  instance: #eureka客户端实例配置    lease-renewal-interval-in-seconds: 30 #定义服务多久去注册中心续约    lease-expiration-duration-in-seconds: 90 #定义服务多久不去续约认为服务失效    metadata-map:      zone: guangdong #所在区域    hostname: localhost #服务主机名称    prefer-ip-address: false #是否优先使用ip来作为主机名  server: #eureka服务端配置    enable-self-preservation: false #关闭eureka服务端的保护机制\n\n于是在eureka-server的yml中加上\nserver: #eureka服务端配置    enable-self-preservation: true #关闭eureka服务端的保护机制\n\n就没有EMERGENCY! 了\n关于eureka-security-server的依赖发现教程里写的依赖是\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;\n\n源码里用的依赖是\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;\n\n自己刚才启动成功的是spring-cloud-starter-security\n改成spring-boot-starter-security试了一下也成功了\n问题解决总结\n用Spring Cloud Security模块，不是Spring Security模块\nEurekaSecurityServerApplication要记得加@EnableEurekaServer\n用指定的yml（application-XXX.yml）启动Spring Boot，在Edit Configurations中复制一个原Configuration，Active profiles填指定yml文件后半部分（XXX），运行这个Configuration\n\n总结","categories":["Note"],"tags":["springcloud"]},{"title":"SpringCloud笔记02 Ribbon负载均衡","url":"/2020/04/09/note-springcloud-02/","content":"\nhttps://blog.csdn.net/ThinkWon/article/details/103729080\n\nuser-service模块\n创建user-service模块\npom.xml添加依赖\n配置application.yml\n实体类和响应类\n控制器\nService接口和实现类\n\nribbon-service模块\n创建ribbon-service模块\npom.xml添加依赖\n配置application.yml\n@LoadBalanced注解赋予RestTemplate负载均衡的能力\n实体类和响应类\n控制器\n\n负载均衡功能演示\n开启服务\n\n8001开一个Server（上次的模块）\n8201、8202各开一个Service\n\n\n这次是同样的配置文件，2个端口各开一个，改Active profiles\n上次是不同的配置文件，开在不同的端口，用Override parameters\n8301开Ribbon Service\n\n\n\n调用接口进行测试\n\n\n\n8201\n\n\n8202\n\n\nDEBUG：运行后没有注册启动几个服务后\n\n\n但是浏览器中查看\n\n\n发现又忘记加@EnableDiscoveryClient了\n重启\n还是没有注册上\n尝试1\n\nhttps://blog.csdn.net/yangyongming_888/article/details/83859092\n\n说是依赖带starter和不带starter\n但是看了下三个pom.xml中都是带starter的\n再比较一下依赖\n源码-eureka-server\n &lt;dependency&gt;   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;   &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;\n\n项目-eureka-server\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;\n\n源码-ribbon-service\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;&lt;/dependency&gt;\n\n项目-ribbon-service\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;&lt;/dependency&gt;\n\n源码-user-service\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;\n\n项目-user-service\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;\n\n一样，看来不是这个问题\n尝试2\n关闭server，直接启动service，发现也启动了，并没有报错\n但是上次的client如果在没开service的时候启动会报\ncom.sun.jersey.api.client.ClientHandlerException: java.net.ConnectException: Connection refused (Connection refused)\n\n所以也许根本就没有连上服务器？\n难道是yml没有生效？\nmvn -X clean install\n\n没用\n\nhttps://segmentfault.com/q/1010000012008825\n\n有说是yml的缩进问题\n看了一下上次可以注册的服务的yml\n\n\n这次的\n\n\n发现注册的true是白色的\n提示\n\n\n确实有问题\n把pom.xml中spring-cloud-starter-netflix-eureka-client的依赖注释的，依然能启动\n\nhttps://ask.csdn.net/questions/719186\n\n有说加版本号的\n没用\n想想和上次创建的区别，上次是在创建模块的时候通过Spring Initializer选择了Eureka Discovery Client的依赖\n试试创建一个user-service2，创建的时候选上Eureka Discovery Client\n把application.yml的内容复制过去，可以解析\n它的依赖\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;\n\nuser-service的依赖\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;\n\n没差啊\n那难道是依赖没有导入\n看下Maven\n\n\n???\n难道真是没有版本号\n而且为什么前面的模块也都是红的，那是怎么运行成功的 迷惑\n点进去看一下\n\n\n也许只是部分冲突所以还能运行？\n总之先加个版本号\n\n\n加了之后还是unknown\n重启也是\n发现右下角在下载\n下完之后变成了Maven中变成了2.2.2.RELEASE\n激动地搓搓手\n\n\n成功！\n\n\n注册上了\n给ribbon-service也加个版本\n加在properties里似乎不管用，暂时都加在dependency里好了\n\n\nDEBUG：调用接口调试的问题出现Whitelabel Error Page\n报错是\n2020-04-09 21:37:37.483 ERROR 3503 --- [nio-8301-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.beans.factory.BeanDefinitionStoreException: Failed to process import candidates for configuration class [org.springframework.cloud.netflix.ribbon.RibbonClientConfiguration]; nested exception is java.lang.IllegalStateException: Failed to introspect annotated methods on class org.springframework.cloud.netflix.ribbon.RestClientRibbonConfiguration] with root causejava.lang.ClassNotFoundException: com.netflix.niws.client.http.RestClient\tat java.net.URLClassLoader.findClass(URLClassLoader.java:382) ~[na:1.8.0_241]\tat java.lang.ClassLoader.loadClass(ClassLoader.java:418) ~[na:1.8.0_241]\n\n找不到com.netflix.niws.client.http.RestClient\n看一下依赖\n\n\n似乎有很多冲突\n\nhttps://stackoverflow.com/questions/50675895/java-lang-classnotfoundexception-com-netflix-discovery-eurekaclientconfig\nYou should select only Eureka Server using spring Initializr while creating eureka server project.\n\n…\n试一下重新创建\n\n\n就没有冲突了\n运行\njava.lang.ClassNotFoundException: com.netflix.niws.client.http.RestClient\n\n怎么还是找不到？？？\n把ribbon的依赖挪到前面来优先找呢？\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;\n\n还是不行\n再翻一下报错发现是getUser函数的问题\n\n\n在里面打印一下路径\n@GetMapping(&quot;/&#123;id&#125;&quot;)public Result getUser(@PathVariable Long id) &#123;  System.out.println(&quot;【getUser中】userServiceUrl：&quot;+userServiceUrl);  return restTemplate.getForObject(userServiceUrl + &quot;/user/&#123;1&#125;&quot;, Result.class, id);&#125;\n\n输出如下\n【getUser中】userServiceUrl：http://user-service\n\n没有localhost?\n浏览器访问一下\n找不到 user-service 的服务器 IP 地址\n上次好像注册过ip来着\n但是注册是hostname\n这里应该是要通过服务名称访问2个Service，似乎不一样\n试试直接用localhost加端口访问\n\n\n单个节点的服务没有问题\n那应该就是在注册服务名称到ip的转换上出了问题\n\nhttps://bbs.csdn.net/topics/392414113\n\n把\n@Autowiredprivate RestTemplate restTemplate;\n\n改成\n@Autowiredprivate RestOperations restTemplate;\n\n不行\n\nhttps://www.liangzl.com/get-article-detail-174951.html\n\n对比了一下这个教程，也没找到问题\n网页上的错误信息是\nThere was an unexpected error (type=Internal Server Error, status=500).Failed to process import candidates for configuration class [org.springframework.cloud.netflix.ribbon.RibbonClientConfiguration]; nested exception is java.lang.IllegalStateException: Failed to introspect annotated methods on class org.springframework.cloud.netflix.ribbon.RestClientRibbonConfiguration\n\n似乎是注释的问题\n…\n很久很久以后\n…\n试试源码能不能跑\n漫长的下载依赖\n第二天\n运行源码\n\n\n\n\n没有问题\n而且Maven一个都没红\n\n\n对比一下依赖版本\n源码eureka-server\n\n\n项目eureka-server\n\n\nspring-cloud-starter-netflix-eureka-server版本不一样\ndiff一下pom文件\n8c8&lt;         &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;---&gt;         &lt;version&gt;2.2.6.RELEASE&lt;/version&gt;11c11&lt;     &lt;groupId&gt;com.jourwon.springcloud&lt;/groupId&gt;---&gt;     &lt;groupId&gt;com.coconutnut&lt;/groupId&gt;19c19&lt;         &lt;spring-cloud.version&gt;Hoxton.RELEASE&lt;/spring-cloud.version&gt;---&gt;         &lt;spring-cloud.version&gt;Hoxton.SR3&lt;/spring-cloud.version&gt;\n\n一个是spring-boot-starter-parent的版本不一样\n一个是spring-cloud的版本不一样\n修改spring-cloud的版本，Maven的冲突就没有了\n于是把其它pom的版本也改了\nspring-boot-starter-parent的版本暂时没改，保持最新\n\n\n启动\n\n\n注册上了\n\n\n又崩了\n但是这次控制台没有Error了\n错误信息变成了\nThere was an unexpected error (type=Internal Server Error, status=500).No instances available for user-service\n\n单独访问http://localhost:8201/user/1或者http://localhost:8202/user/1都是可以的\n\nhttps://blog.csdn.net/choice_of_door/article/details/85467105\n\n按照这个加了个依赖\n（源码里并没有 但是可以正常运行，为什么呢？MARK (笔记03中解决)）\n&lt;dependency&gt;  &lt;groupId&gt;com.netflix.ribbon&lt;/groupId&gt;  &lt;artifactId&gt;ribbon-eureka&lt;/artifactId&gt;&lt;/dependency&gt;\n\n成功了！\n嗷！\n问题总结都是版本的坑\n创建时用Spring Initializer加还是后期在pom.xml中加不重要\n但最好和教程保持一致\n至少检查右边Maven栏中没有红线\n总结\n\n","categories":["Note"],"tags":["springcloud"]},{"title":"Axure笔记","url":"/2020/04/16/note-axure/","content":"\nhttps://www.bilibili.com/video/BV1Yx411f7d6\n\n标尺按住尺子拖下来\n\n\n左侧也是\n圆角按住黄色三角拖动\n\n\n平均排布选中几个元素，点水平\n\n\n切割顶栏右键-&gt;分割图片\n\n\n动作先建一个文件夹，一个页面对应一页，大小、位置相同\n用热区罩在点击区域上\n添加交互\n\n\n跳转页面 可选择打开链接\n\n上手完成\n\n\n\n\n","categories":["Note"],"tags":["tool"]},{"title":"axios请求跨域问题","url":"/2020/04/18/debug/","content":"\n\n发现有跨域问题\n查到\n\nhttps://www.cnblogs.com/l-y-h/p/11815452.html\n\n照着改了一下\n但是又出现了\nCannot set property $http of #&lt;Vue&gt; which has only a getter at eval axios\n\n最后解决方法\nvue.config.js\nmodule.exports = &#123;    devServer: &#123;        proxy: &#123;            &#x27;/api&#x27;: &#123;                target: &#x27;http://***:3000/&#x27;,                // 允许跨域                changeOrigin: true,                ws: true,                pathRewrite: &#123;                    &#x27;^/api&#x27;: &#x27;&#x27;                &#125;            &#125;        &#125;    &#125;&#125;\n\n调用\nthis.$axios.get(&#x27;/api/findall&#x27;).then(response =&gt; &#123;                console.log(response.data)            &#125;).catch(function (error) &#123;                alert(error);            &#125;);\n","categories":["Debug"],"tags":["vue"]},{"title":"SpringCloud笔记04 Consul服务治理","url":"/2020/04/20/note-springcloud-04/","content":"\nhttps://www.consul.io/\n\n安装\nhttps://learn.hashicorp.com/consul/getting-started/install.html\n\n% brew install consul\n\n% consul versionConsul v1.6.3Protocol 2 spoken by default, understands 2 to 3 (agent will automatically use protocol &gt;2 when speaking to compatible agents)\n\n官方教程\nhttps://learn.hashicorp.com/consul/getting-started/agent\n\n启动服务器$ consul agent -dev\n\n查看节点$ consul members\n\n尝试\n% consul membersNode                  Address         Status  Type    Build  Protocol  DC   SegmentSs-MacBook-Pro.local  127.0.0.1:8301  alive   server  1.6.3  2         dc1  &lt;all&gt;\n\ncoconutnut@Ss-MacBook-Pro ~ % consul members -detailedNode                  Address         Status  TagsSs-MacBook-Pro.local  127.0.0.1:8301  alive   acls=0,build=1.6.3:7f3b5f3+,dc=dc1,id=d9c5a17b-cc6b-1ca6-7c72-07304fbcccdc,port=8300,raft_vsn=3,role=consul,segment=&lt;all&gt;,vsn=2,vsn_max=3,vsn_min=2,wan_join_port=8302\n\n但是member命令获取的信息只是eventually consistent的\n一致性更强的方式是使用http api\ncurl localhost:8500/v1/catalog/nodes\n\n尝试\n% curl localhost:8500/v1/catalog/nodes[    &#123;        &quot;ID&quot;: &quot;d9c5a17b-cc6b-1ca6-7c72-07304fbcccdc&quot;,        &quot;Node&quot;: &quot;Ss-MacBook-Pro.local&quot;,        &quot;Address&quot;: &quot;127.0.0.1&quot;,        &quot;Datacenter&quot;: &quot;dc1&quot;,        &quot;TaggedAddresses&quot;: &#123;            &quot;lan&quot;: &quot;127.0.0.1&quot;,            &quot;wan&quot;: &quot;127.0.0.1&quot;        &#125;,        &quot;Meta&quot;: &#123;            &quot;consul-network-segment&quot;: &quot;&quot;        &#125;,        &quot;CreateIndex&quot;: 10,        &quot;ModifyIndex&quot;: 11    &#125;]\n\n也可以用dns\n% dig @127.0.0.1 -p 8600 Judiths-MBP.node.consul; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; @127.0.0.1 -p 8600 Judiths-MBP.node.consul; (1 server found);; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NXDOMAIN, id: 33684;; flags: qr aa rd; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1;; WARNING: recursion requested but not available;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 4096;; QUESTION SECTION:;Judiths-MBP.node.consul.\tIN\tA;; AUTHORITY SECTION:consul.\t\t\t0\tIN\tSOA\tns.consul. hostmaster.consul. 1587353730 3600 600 86400 0;; Query time: 0 msec;; SERVER: 127.0.0.1#8600(127.0.0.1);; WHEN: Mon Apr 20 11:35:30 CST 2020;; MSG SIZE  rcvd: 102\n\n优雅的关闭节点ctrl+C 暂停服务器\n$ consul leave\n\n注册到consul\nhttps://juejin.im/post/5db05582f265da4d4c20180f\n\n将以前注册到eureka的服务改到consul\nuser-service模块\n修改依赖\n&lt;!--        &lt;dependency&gt;--&gt;&lt;!--            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;--&gt;&lt;!--            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;--&gt;&lt;!--        &lt;/dependency&gt;--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;&lt;/dependency&gt;\n\n修改配置\n#eureka:#  client:#    register-with-eureka: true#    fetch-registry: true#    service-url:#      defaultZone: http://localhost:8001/eureka/cloud:  consul:    host: localhost    port: 8500    discovery:      service-name: $&#123;spring.application.name&#125;\n\nribbon-service模块也是\n\n\n Service Checks是X，但是可以访问？\n\n\n但是http://localhost:8301/user/1获取不了\n报错信息\njava.lang.IllegalStateException: No instances available for user-service\n\n\nhttps://blog.csdn.net/kxj19980524/article/details/86935415\n\n还需要加一个监控中心的依赖\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;\n\n重启\n\n\n访问http://localhost:8301/user/1四次\n控制台输出\n\n\n交替调用\n\n\n成功\n总结终端启动consul服务器\n$ consul agent -dev\n\nIdea模块 consul客户端\n依赖\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;\n\n配置\ncloud:  consul:    host: localhost    port: 8500    discovery:      service-name: $&#123;spring.application.name&#125;\n\n","categories":["Note"],"tags":["springcloud"]},{"title":"MyBatisPlus笔记01 CRUD","url":"/2020/04/21/note-mybatisplus-01/","content":"\nhttps://www.bilibili.com/video/BV1rE41197jR\np1~25\n\n数据库准备-- 创建测试表CREATE TABLE `tb_user` (`id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;, `user_name` varchar(20) NOT NULL COMMENT &#x27;用户名&#x27;, `password` varchar(20) NOT NULL COMMENT &#x27;密码&#x27;,`name` varchar(30) DEFAULT NULL COMMENT &#x27;姓名&#x27;,`age` int(11) DEFAULT NULL COMMENT &#x27;年龄&#x27;, `email` varchar(50) DEFAULT NULL COMMENT &#x27;邮箱&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;-- 插入测试数据INSERT INTO `tb_user` (`id`, `user_name`, `password`, `name`, `age`, `email`) VALUES (&#x27;1&#x27;, &#x27;zhangsan&#x27;, &#x27;123456&#x27;, &#x27;张三&#x27;, &#x27;18&#x27;, &#x27;test1@itcast.cn&#x27;);INSERT INTO `tb_user` (`id`, `user_name`, `password`, `name`, `age`, `email`) VALUES (&#x27;2&#x27;, &#x27;lisi&#x27;, &#x27;123456&#x27;, &#x27;李四&#x27;, &#x27;20&#x27;, &#x27;test2@itcast.cn&#x27;);INSERT INTO `tb_user` (`id`, `user_name`, `password`, `name`, `age`, `email`) VALUES (&#x27;3&#x27;, &#x27;wangwu&#x27;, &#x27;123456&#x27;, &#x27;王五&#x27;, &#x27;28&#x27;, &#x27;test3@itcast.cn&#x27;);INSERT INTO `tb_user` (`id`, `user_name`, `password`, `name`, `age`, `email`) VALUES (&#x27;4&#x27;, &#x27;zhaoliu&#x27;, &#x27;123456&#x27;, &#x27;赵六&#x27;, &#x27;21&#x27;, &#x27;test4@itcast.cn&#x27;);INSERT INTO `tb_user` (`id`, `user_name`, `password`, `name`, `age`, `email`) VALUES (&#x27;5&#x27;, &#x27;sunqi&#x27;, &#x27;123456&#x27;, &#x27;孙七&#x27;, &#x27;24&#x27;, &#x27;test5@itcast.cn&#x27;);\n\n创建工程导入依赖&lt;dependencies&gt;  &lt;!--mybatis-plus的springboot支持--&gt;  &lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.1.1&lt;/version&gt;  &lt;/dependency&gt;  &lt;!--mysql驱动--&gt;  &lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;5.1.47&lt;/version&gt;  &lt;/dependency&gt;  &lt;!--简化bean代码的工具包--&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;    &lt;exclusions&gt;      &lt;exclusion&gt;        &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;        &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;      &lt;/exclusion&gt;    &lt;/exclusions&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;\n\n配置文件log4j.propertieslog4j.rootLogger=DEBUG,A1log4j.appender.A1=org.apache.log4j.ConsoleAppenderlog4j.appender.A1.layout=org.apache.log4j.PatternLayoutlog4j.appender.A1.layout.ConversionPattern=[%t] [%c]-[%p] %m%n\n\napplication.propertiesspring.application.name = itcast-mp-springbootspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://127.0.0.1:3306/groot? useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true&amp;useSSL=falsespring.datasource.username=rootspring.datasource.password=iamgroot\n\n实体类使用lombok注解生成get、set方法\n使用MybatisPlus注解指定表名\npackage com.coconutnut.demo.pojo;import com.baomidou.mybatisplus.annotation.TableName;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@NoArgsConstructor@AllArgsConstructor@TableName(&quot;tb_user&quot;)public class User &#123;  \t@TableId(type = IdType.AUTO)    private Long id;    private String userName;    private String password;    private String name;    private Integer age;    private String email;&#125;\n\n用@TableId指定id的增长策略\n@TableField可解决的问题：\n\n对象中的属性名和字段名不一致的问题(非驼峰)\n@TableField(value = &quot;email&quot;)private String mail;\n\n对象中的属性字段在表中不存在的问题\n@TableField(exist = false)private String address;\n\n查询时不返回该字段的值\n@TableField(select = false)private String password;\n\n\n\nMapper接口package com.coconutnut.demo.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.coconutnut.demo.pojo.User;public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125;\n\nSpringBoot启动类使用@MapperScan设置mapper接口的扫描包\npackage com.coconutnut.demo;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@MapperScan(&quot;com.coconutnut.demo.mapper&quot;) @SpringBootApplicationpublic class DemoApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DemoApplication.class, args);    &#125;&#125;\n\n项目结构\n\n测试package com.coconutnut.demo;import com.coconutnut.demo.mapper.UserMapper;import com.coconutnut.demo.pojo.User;import org.junit.jupiter.api.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import java.util.List;@RunWith(SpringRunner.class)@SpringBootTestclass DemoApplicationTests &#123;    @Autowired    private UserMapper userMapper;    @Test    public void testSelect() &#123;        List&lt;User&gt; userList = userMapper.selectList(null);        for (User user : userList) &#123;            System.out.println(user);        &#125;    &#125;&#125;\n\n输出\n\n\nDEBUG 依赖重复SLF4J: Class path contains multiple SLF4J bindings.\n\n删除依赖中的\n&lt;dependency&gt;  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;  &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt;\n\nCRUD查看UserMapper继承的BaseMapper源码\n\n\nCRUD方法都有了\n官网文档\n\nhttps://mybatis.plus/guide/crud-interface.html#mapper-crud-%E6%8E%A5%E5%8F%A3\n\n直接测试\n插入// 插入一条记录int insert(T entity);\n\npackage com.coconutnut.demo;import com.coconutnut.demo.mapper.UserMapper;import com.coconutnut.demo.pojo.User;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class TestUserMapper &#123;    @Autowired    private UserMapper userMapper;    @Test    public void testInsert()&#123;        User user = new User();        user.setAge(20);        user.setUserName(&quot;zhangsi&quot;);        user.setName(&quot;张四&quot;);        user.setEmail(&quot;zhangsi@163.com&quot;);        user.setPassword(&quot;123456&quot;);        int result = this.userMapper.insert(user); // 返回的result是受影响的行数，并不是自增后的id        System.out.println(&quot;result = &quot; + result);        System.out.println(user.getId()); // 自增后的id会回填到对象中    &#125;&#125;\n\n运行后，数据库变化\n\n\n输出\n\n\n更新// 根据 whereEntity 条件，更新记录int update(@Param(Constants.ENTITY) T entity, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; updateWrapper);// 根据 ID 修改int updateById(@Param(Constants.ENTITY) T entity);\n\n根据id更新@Testpublic void testUpdateById() &#123;  User user = new User();  user.setId(1L);  user.setAge(21);  //根据id更新，更新不为null的字段  this.userMapper.updateById(user);&#125;\n\n执行后\n\n\n根据条件更新QueryWrapper@Testpublic void testUpdate() &#123;  User user = new User();  user.setAge(22);  // 更新的条件  QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();  // wrapper.eq(&quot;id&quot;, 6);  wrapper.eq(&quot;user_name&quot;,&quot;zhangsan&quot;);  // 执行更新操作  int result = this.userMapper.update(user, wrapper);  System.out.println(&quot;result = &quot; + result);&#125;\n\nwrapper中设置属性用的是mysql表中的名称\n执行后\n\n\nUpdateWrapper@Testpublic void testUpdate2() &#123;  //更新的条件以及字段  UpdateWrapper&lt;User&gt; wrapper = new UpdateWrapper&lt;&gt;();  wrapper.eq(&quot;id&quot;, 6).set(&quot;age&quot;, 23);  //执行更新操作  int result = this.userMapper.update(null, wrapper);  System.out.println(&quot;result = &quot; + result);&#125;\n\n执行后\n\n\n删除// 根据 entity 条件，删除记录int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; wrapper);// 删除（根据ID 批量删除）int deleteBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);// 根据 ID 删除int deleteById(Serializable id);// 根据 columnMap 条件，删除记录int deleteByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);\n\ndeleteById@Testpublic void testDeleteById() &#123;  int result = this.userMapper.deleteById(6L);  System.out.println(&quot;result = &quot; + result);&#125;\n\n执行后\n\n\ndeleteByMap@Testpublic void testDeleteByMap() &#123;  // 将columnMap中的元素设置为删除的条件，多个之间为and关系  Map&lt;String, Object&gt; columnMap = new HashMap&lt;&gt;();  columnMap.put(&quot;age&quot;,20);  columnMap.put(&quot;name&quot;,&quot;张三&quot;);  int result = this.userMapper.deleteByMap(columnMap);  System.out.println(&quot;result = &quot; + result);&#125;\n\n执行后\n\n\n没有符合条件的\ndelete@Testpublic void testDelete() &#123;\t// 用法1//        QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();//        wrapper.eq(&quot;user_name&quot;,&quot;zhangsan&quot;);    // 用法2  User user = new User();  user.setAge(20);  user.setName(&quot;张三&quot;);  // 将实体对象进行包装，包装为操作条件  QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(user);  int result = this.userMapper.delete(wrapper);  System.out.println(&quot;result = &quot; + result);&#125;\n\n推荐使用用法2\ndeleteByIds@Testpublic void testDeleteByIds() &#123;  int result = this.userMapper.deleteBatchIds(Arrays.asList(1L,10L,20L));   System.out.println(&quot;result = &quot; + result);&#125;\n\n查询// 根据 ID 查询T selectById(Serializable id);// 根据 entity 条件，查询一条记录T selectOne(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 查询（根据ID 批量查询）List&lt;T&gt; selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);// 根据 entity 条件，查询全部记录List&lt;T&gt; selectList(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 查询（根据 columnMap 条件）List&lt;T&gt; selectByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);// 根据 Wrapper 条件，查询全部记录List&lt;Map&lt;String, Object&gt;&gt; selectMaps(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值List&lt;Object&gt; selectObjs(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 entity 条件，查询全部记录（并翻页）IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询全部记录（并翻页）IPage&lt;Map&lt;String, Object&gt;&gt; selectMapsPage(IPage&lt;T&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询总记录数Integer selectCount(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);\n\nselectById@Testpublic void testSelectById() &#123;   User user = this.userMapper.selectById(2L);  System.out.println(&quot;result = &quot; + user);&#125;\n\n执行后\n\n\n没查到为null\nselectOne不存在返回null\n查到多条报错\n@Testpublic void testSelectOne() &#123;  QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;User&gt;();  wrapper.eq(&quot;name&quot;, &quot;李四&quot;);  User user = this.userMapper.selectOne(wrapper);  System.out.println(user);&#125;\n\n输出\nUser(id=2, userName=lisi, password=123456, name=李四, age=20, email=test2@itcast.cn)\n\nselectBatchIds@Testpublic void testSelectBatchIds() &#123;  List&lt;User&gt; users = this.userMapper.selectBatchIds(Arrays.asList(2L, 3L, 100L));  for (User user : users) &#123;    System.out.println(user);  &#125;&#125;\n\n执行后\n\n\nselectCount@Testpublic void testSelectCount() &#123;  QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;User&gt;();  wrapper.gt(&quot;age&quot;, 23); // 年龄大于23岁  Integer count = this.userMapper.selectCount(wrapper);  System.out.println(&quot;count = &quot; + count);&#125;\n\n输出\ncount = 2\n\nselectList@Testpublic void testSelectList() &#123;  QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;User&gt;();  wrapper.gt(&quot;age&quot;, 23); // 年龄大于23岁  //根据条件查询数据  List&lt;User&gt; users = this.userMapper.selectList(wrapper);  for (User user : users) &#123;    System.out.println(&quot;user = &quot; + user);  &#125;&#125;\n\n执行后\n\n\nselectPage配置分页插件\nimport com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor;import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@MapperScan(&quot;com.coconutnut.demo.mapper&quot;) // 设置mapper接口的扫描包public class MybatisPlusConfig &#123;    @Bean    public PaginationInterceptor paginationInterceptor()&#123;        return new PaginationInterceptor();    &#125;    &#125;\n\n有了这个配置类之后，DemoApplication中的@MapperScan可以去掉\n@Testpublic void testSelectPage() &#123;  QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;User&gt;();  wrapper.gt(&quot;age&quot;, 20); // 年龄大于20岁  Page&lt;User&gt; page = new Page&lt;&gt;(2,2);  IPage&lt;User&gt; iPage = this.userMapper.selectPage(page, wrapper);  System.out.println(&quot;数据总条数:&quot; + iPage.getTotal());  System.out.println(&quot;总页数:&quot; + iPage.getPages());  List&lt;User&gt; users = iPage.getRecords();  for (User user : users) &#123;    System.out.println(&quot;user = &quot; + user);  &#125;&#125;\n\n执行后\n\n\n","categories":["Note"],"tags":["mybatis_plus"]},{"title":"SpringCloud笔记05 OpenFeign服务消费者","url":"/2020/04/21/note-springcloud-05/","content":"\nhttps://blog.csdn.net/ThinkWon/article/details/103735751\n\nSpring Cloud OpenFeign 是声明式的服务调用工具，它整合了Ribbon和Hystrix，拥有负载均衡和服务容错功能\n创建feign-service模块依赖教程给的依赖是\n&lt;dependency&gt;\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\t&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\t&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;\n\n换成consul注册中心，改成\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;\n\n发现没有spring cloud版本和依赖管理，加上\n&lt;spring-cloud.version&gt;Hoxton.RELEASE&lt;/spring-cloud.version&gt;\n\n&lt;dependencyManagement&gt;  &lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;      &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;      &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;      &lt;type&gt;pom&lt;/type&gt;      &lt;scope&gt;import&lt;/scope&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;&lt;/dependencyManagement&gt;\n\n查看右侧Maven栏中没有红线\n下一步\n配置教程给的配置\nserver:  port: 8701spring:  application:    name: feign-serviceeureka:  client:    register-with-eureka: true    fetch-registry: true    service-url:      defaultZone: http://localhost:8001/eureka/\n\n换成consul\n#eureka:#  client:#    register-with-eureka: true#    fetch-registry: true#    service-url:#      defaultZone: http://localhost:8001/eureka/cloud:  consul:    host: localhost    port: 8500    discovery:      service-name: $&#123;spring.application.name&#125;\n\n@EnableFeignClients启动功能@EnableFeignClients@EnableDiscoveryClient@SpringBootApplicationpublic class FeignServiceApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(FeignServiceApplication.class, args);    &#125;&#125;\n\n接口和控制器根据源码补齐其它代码\n\n\n负载均衡启动consul服务器，两个user-service，feign-service服务\n\n\n调用http://localhost:8701/user/1四次\n\n\n交替打印\n\n\n服务降级前面UserFallbackService也拷过来了\n@FeignClient(value = &quot;user-service&quot;, fallback = UserFallbackService.class)public interface UserService &#123;&#125;\n\n注释也加了\n修改application.yml，开启Hystrix功能\n#在Feign中开启Hystrixfeign:  hystrix:    enabled: true\n\n关闭两个user-service服务，重新启动feign-service\n调用http://localhost:8701/user/1进行测试\n发现被降级\n\n\n日志打印功能用FeignConfig配置类\n在application.yml中配置需要开启日志的Feign客户端\n可设置日志级别\n总结\n\n","categories":["Note"],"tags":["springcloud"]},{"title":"MyBatisPlus笔记02 配置","url":"/2020/04/22/note-mybatisplus-02/","content":"\nhttps://www.bilibili.com/video/BV1rE41197jR\np27~32\n\n官方文档\n基本配置configLocationMyBatis 配置文件位置\neg：resources文件夹下有mybatis-config.xml，要将其作为MyBatis配置文件\n则需在applications.properties中配置\n# 指定全局的配置文件mybatis-plus.config-location = classpath:mybatis-config.xml\n\nmapperLocations指定mapper文件位置\n当默认的Mapper不够用（如需要多表查询时），可以指定自定义的mapper，在里面写sql语句\n例如resources中新建mybatis文件夹，新建一个UserMapper.xml\nmybatis-plus.mapper-locations = classpath*:mybatis/*.xml\n\nMaven多模块项目的扫描路径需以classpath*开头（即加在多个jar包下的xml文件）\ntypeAliasesPackage给包中的类注册别名，注册后在 Mapper 对应的 XML 文件中可以直接使用类名，而不用使用全限定的类名\n例如\nmybatis-plus.type-aliases-package = cn.itcast.mp.pojo\n\n进阶配置大都为 MyBatis 原生支持的配置\n注意：如果制定了全局配置文件，需要在全局配置文件中配置，和application.properties不能共存\nmapUnderscoreToCamelCase是否开启自动驼峰命名规则映射\ncacheEnabled开启Mybatis二级缓存，默认为 true\nDB 策略配置idType全局默认主键类型，设置后，即可省略实体对象中的@TableId(type = IdType.AUTO)配置\nmybatis-plus.global-config.db-config.id-type = auto\n\ntablePrefix指定表名前缀，全局配置后可省略@TableName()配置\nmybatis-plus.global-config.db-config.table-prefix = tb_\n\n如，User类默认会去找user表，如果要找tb_user表，需要使用注解，或者全局配置前缀\n","categories":["Note"],"tags":["mybatis_plus"]},{"title":"MyBatisPlus笔记03 条件构造器","url":"/2020/04/22/note-mybatisplus-03/","content":"\nhttps://www.bilibili.com/video/BV1rE41197jR\np33~39\n\nWrapper接口实现类重点有AbstractWrapper和AbstractChainWrapper\n区别在于AbstractChainWrapper采用lambda表达式编写\n使用以allEq为例\n QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();// 设置条件Map&lt;String,Object&gt; params = new HashMap&lt;&gt;(); params.put(&quot;name&quot;, &quot;张三&quot;);params.put(&quot;age&quot;, &quot;20&quot;); params.put(&quot;password&quot;, null);wrapper.allEq(params);// 查询List&lt;User&gt; users = this.userMapper.selectList(wrapper);for (User user : users) &#123;\tSystem.out.println(user); &#125;\n\n这样生成的sql语句为\nSELECT * FROM tb_user WHERE password IS NULL AND name = ? AND age = ?\n\n第二个参数为false时忽略值为null的\nwrapper.allEq(params,false);\n\n生成的sql语句为\nSELECT * FROM tb_user WHERE name = ? AND age = ?\n\n还可以设置过滤器\n基本比较操作官方文档\n模糊查询like、notLike、likeLeft、likeRight\n例如\nQueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();wrapper.like(&quot;name&quot;, &quot;曹&quot;); // %曹%List&lt;User&gt; users = this.userMapper.selectList(wrapper);for (User user : users) &#123;\tSystem.out.println(user); &#125;\n\n排序orderBy（默认Asc）、orderByAsc、orderByDesc\n例如\nQueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();// SELECT id,user_name,password,name,age,email FROM tb_user ORDER BY age DESCwrapper.orderByDesc(&quot;age&quot;);List&lt;User&gt; users = this.userMapper.selectList(wrapper);for (User user : users) &#123;\tSystem.out.println(user); &#125;\n\n逻辑查询or、and\n例如\nQueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();// SELECT id,user_name,password,name,age,email FROM tb_user WHERE name = ? OR age = ?wrapper.eq(&quot;name&quot;,&quot;李四&quot;).or().eq(&quot;age&quot;, 24);List&lt;User&gt; users = this.userMapper.selectList(wrapper);for (User user : users) &#123;\tSystem.out.println(user); &#125;\n\n指定查询字段select\n例如\nQueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();// SELECT id,name,age FROM tb_user WHERE name = ? OR age = ?wrapper.eq(&quot;name&quot;, &quot;李四&quot;).or().eq(&quot;age&quot;, 24).select(&quot;id&quot;, &quot;name&quot;, &quot;age&quot;);List&lt;User&gt; users = this.userMapper.selectList(wrapper);for (User user : users) &#123;\tSystem.out.println(user); &#125;\n\n","categories":["Note"],"tags":["mybatis_plus"]},{"title":"MyBatisPlus笔记05 插件","url":"/2020/04/24/note-mybatisplus-05/","content":"\nhttps://www.bilibili.com/video/BV1rE41197jR\nP49~54\n\nmybatis的插件机制MyBatis 允许在已映射语句执行过程中的某一点进行拦截\n默认情况下，MyBatis 允许使用插件来拦截的方法调用包括:\n\nExecutor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed) \n\nParameterHandler (getParameterObject, setParameters)\n\nResultSetHandler (handleResultSets, handleOutputParameters)\n\nStatementHandler (prepare, parameterize, batch, update, query)\n\n\n可以拦截：\n\n执行器的方法\n参数的处理\n结果集的处理\nSql语法构建的处理\n\n自定义拦截器可以实现Interceptor接口，注入到Spring容器\n执行分析插件可用作阻断全表更新、删除的操作\n注意:该插件仅适用于开发环境，不适用于生产环境（性能问题）\n配置MybatisPlusConfig中配置\n@Beanpublic SqlExplainInterceptor sqlExplainInterceptor()&#123;  SqlExplainInterceptor sqlExplainInterceptor = new SqlExplainInterceptor();  List&lt;ISqlParser&gt; sqlParserList = new ArrayList&lt;&gt;();  sqlParserList.add(new BlockAttackSqlParser());  sqlExplainInterceptor.setSqlParserList(sqlParserList);  return sqlExplainInterceptor;&#125;\n\n测试@Autowiredprivate UserMapper userMapper;@Testpublic void testUpdateAll()&#123;  User user = new User();  user.setAge(20);  int result = this.userMapper.update(user, null);  System.out.println(&quot;result = &quot; + result);&#125;\n\n结果：全表更新被阻断\nProhibition of table update operation\n\n\n\n性能分析插件用于输出每条 SQL 语句及其执行时间，可以设置最大执行时间，超过时间会抛出异常\n配置两种方式，可以像上面一样在Config中配置，也可以在xml中配置\n这里用xml方式\nmybatis-config.xml中\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;plugins&gt;        &lt;!-- SQL 执行性能分析，开发环境使用，线上不推荐。 maxTime 指的是 sql 最大执行时长 --&gt;        &lt;plugin interceptor=&quot;com.baomidou.mybatisplus.extension.plugins.PerformanceInterceptor&quot;&gt;            &lt;property name=&quot;maxTime&quot; value=&quot;100&quot; /&gt;            &lt;!--SQL是否格式化 默认false--&gt;            &lt;property name=&quot;format&quot; value=&quot;true&quot; /&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/configuration&gt;\n\n测试执行testSelectById()\n输出\nTime：10 ms - ID：com.coconutnut.demo.mapper.UserMapper.selectByIdExecute SQL：    SELECT        id,        user_name,        password,        name,        age,        email     FROM        tb_user     WHERE        id=2 User(id=2, userName=lisi, password=123456, name=李四, age=20, email=test2@itcast.cn)\n\n乐观锁插件当要更新一条记录的时候，希望这条记录没有被别人更新\n实现方式:\n\n取出记录时，获取当前version\n更新时，带上这个version\n执行更新时， set version = newVersion where version = oldVersion\n如果version不对，就更新失败\n\n配置@Beanpublic OptimisticLockerInterceptor optimisticLockerInterceptor() &#123;    return new OptimisticLockerInterceptor();&#125;\n\nVersion字段为表添加version字段，并且设置初始值为1\nALTER TABLE `tb_user`ADD COLUMN `version` int(10) NULL AFTER `email`;UPDATE `tb_user` SET `version`=&#x27;1&#x27;;\n\n为User实体类添加version字段和注解\n@Versionprivate Integer version;\n\n测试@Testpublic void testUpdateVersion()&#123;  User user = new User();  user.setAge(30);  user.setId(2L);  user.setVersion(1); // 当前version为1  int result = this.userMapper.updateById(user);  System.out.println(&quot;result = &quot; + result);&#125;\n\n输出\n Time：2 ms - ID：com.coconutnut.demo.mapper.UserMapper.updateByIdExecute SQL：    UPDATE        tb_user     SET        age=30,        version=2     WHERE        id=2         AND version=1result = 1\n\n乐观锁插件添加了version条件，并设置新的version为2\n\n\n如果再执行一次\n Time：1 ms - ID：com.coconutnut.demo.mapper.UserMapper.updateByIdExecute SQL：    UPDATE        tb_user     SET        age=30,        version=2     WHERE        id=2         AND version=1result = 0\n\n此时version已经是2，不能执行了\n正常的使用方式\n@Testpublic void testUpdateVersion()&#123;  User user = new User();  user.setId(2L); // 查询条件  User userVersion = user.selectById(); // 当前版本  user.setAge(30);  // 更新的数据  user.setVersion(userVersion.getVersion()); // 版本信息  int result = this.userMapper.updateById(user);  System.out.println(&quot;result = &quot; + result);&#125;\n\n特别说明\n支持的数据类型只有:int,Integer,long,Long,Date,Timestamp,LocalDateTime\n整数类型下 newVersion = oldVersion + 1\nnewVersion 会回写到 entity 中\n仅支持 updateById(id) 与 update(entity, wrapper) 方法\n在 update(entity, wrapper) 方法下, wrapper 不能复用\n\n","categories":["Note"],"tags":["mybatis_plus"]},{"title":"MyBatisPlus笔记04 ActiveRecord","url":"/2020/04/24/note-mybatisplus-04/","content":"\nhttps://www.bilibili.com/video/BV1rE41197jR\nP40~45\n\n属于ORM(对象关系映射)层\n主要思想:\n\n每一个数据库表对应创建一个类，类的每一个对象实例对应于数据库中表的一行记录;通常表的每个字段在类中都有相应的Field;\nActiveRecord同时负责把自己持久化，在ActiveRecord中封装了对数据库的访问，即CURD;\nActiveRecord是一种领域模型(Domain Model)，封装了部分业务逻辑;\n\n开启AR实体对象继承Model即可\n@Data@NoArgsConstructor@AllArgsConstructor@TableName(&quot;tb_user&quot;)public class User extends Model&lt;User&gt; &#123;    @TableId(type = IdType.AUTO)    private Long id;    private String userName;    private String password;    private String name;    private Integer age;    private String email;&#125;\n\n测试不需要UserMapper了，直接查询\n@Testpublic void testSelectById() &#123;  User user = new User();  user.setId(2L);  User user2 = user.selectById();  System.out.println(user2);&#125;\n\n运行输出\nUser(id=2, userName=lisi, password=123456, name=李四, age=20, email=test2@itcast.cn)\n\n对比以前的查询方式\n@Autowiredprivate UserMapper userMapper;@Testpublic void testSelectById() &#123;   User user = this.userMapper.selectById(2L);  System.out.println(&quot;result = &quot; + user);&#125;\n\n使用AR后，不需要显示的注入UserMapper，但是这个类还是需要的\npublic interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125;\n\n如果把这个删了就运行不了了\nCRUD查询方法一：同上\n方法二：条件查询\n@Testpublic void testSelect()&#123;  User user = new User();  QueryWrapper&lt;User&gt; userQueryWrapper = new QueryWrapper&lt;&gt;();  userQueryWrapper.le(&quot;age&quot;,&quot;20&quot;);  List&lt;User&gt; users = user.selectList(userQueryWrapper);  for (User user1 : users) &#123;    System.out.println(user1);  &#125;&#125;\n\n新增@Testpublic void testInsert()&#123;  User user = new User();  user.setName(&quot;刘备&quot;);  user.setAge(30);  user.setPassword(&quot;123456&quot;);  user.setUserName(&quot;liubei&quot;);  user.setEmail(&quot;liubei@itcast.cn&quot;);  boolean insert = user.insert();  System.out.println(insert);&#125;\n\n返回插入是否成功\n\n\n更新@Testpublic void testUpdate()&#123;  User user = new User();  user.setId(5L);  user.setAge(35);  boolean update = user.updateById();  System.out.println(update);&#125;\n\n\n\n也可以根据条件（用Wrapper）更新\n删除@Testpublic void testDelete() &#123;  User user = new User(); user.setId(7L);  boolean delete = user.deleteById();  System.out.println(delete);&#125;\n\n\n\n","categories":["Note"],"tags":["mybatis_plus"]},{"title":"MyBatisPlus笔记06 自动填充、逻辑删除、通用枚举等","url":"/2020/04/24/note-mybatisplus-06/","content":"\nhttps://www.bilibili.com/video/BV1rE41197jR\nP55~62\n\nsql注入器默认的Mapper中方法不够用时，自己扩充BaseMapper中的方法\n\nhttps://www.bilibili.com/video/BV1rE41197jR?p=55\n\n自动填充插入或者更新数据时，希望有些字段可以自动填充数据，比如密码、version 等\n添加@TableField注解@Version@TableField(fill = FieldFill.INSERT)private Integer version;\n\nFieldFill可选：\n\nDEFAULT 默认不处理\nINSERT 插入试填充字段\nUPDATE 更新时填充字段\nINSERT_UPDATE 插入和更新时填充字段\n\n编写MyMetaObjectHandler@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123;    @Override    public void insertFill(MetaObject metaObject) &#123;        Object version = getFieldValByName(&quot;version&quot;, metaObject);        if(version == null)&#123;            setFieldValByName(&quot;version&quot;, 1, metaObject);        &#125;    &#125;&#125;\n\n测试@Testpublic void testInsertFill()&#123;  User user = new User();  user.setName(&quot;张四&quot;);  user.setUserName(&quot;zhangsi&quot;);  user.setPassword(&quot;123123&quot;);  user.setAge(30);  user.setEmail(&quot;zhangsi@itast.cn&quot;);  int result = this.userMapper.insert(user);  System.out.println(&quot;result = &quot; + result);&#125;\n\n输出\n Time：9 ms - ID：com.coconutnut.demo.mapper.UserMapper.insertExecute SQL：    INSERT     INTO        tb_user        ( user_name, password, name, age, email, version )     VALUES        ( &#x27;zhangsi&#x27;, &#x27;123123&#x27;, &#x27;张四&#x27;, 30, &#x27;zhangsi@itast.cn&#x27;, 1 )result = 1\n\n逻辑删除将数据标记为删除，而并非真正删除\n查询时需要携带状态条件，确保被标记的数据不被查询到\n修改表结构为tb_user表增加deleted字段，用于表示数据是否被删除，1代表删除，0代表未删除\nALTER TABLE `tb_user`ADD COLUMN `deleted` int(1) NULL DEFAULT 0 COMMENT &#x27;1代表删除，0代表未删除&#x27; AFTER `version`;\n\n修改User实体，增加deleted属性并且添加@TableLogic注解\n@TableLogicprivate Integer deleted;\n\n配置application.properties中\n# 逻辑已删除值(默认为 1) mybatis-plus.global-config.db-config.logic-delete-value=1# 逻辑未删除值(默认为 0) mybatis-plus.global-config.db-config.logic-not-delete-value=0\n\n直接用默认值可以省略\n测试@Testpublic void testDelete() &#123;  User user = new User(); user.setId(2L);  boolean delete = user.deleteById();  System.out.println(delete);&#125;\n\n输出\n Time：2 ms - ID：com.coconutnut.demo.mapper.UserMapper.deleteByIdExecute SQL：    UPDATE        tb_user     SET        deleted=1     WHERE        id=2         AND deleted=0true\n\n实际上变成了UPDATE\n\n\n然后查询\n@Testpublic void testSelectById() &#123;  User user = new User();  user.setId(2L);  User user2 = user.selectById();  System.out.println(user2);&#125;\n\n输出\n Time：5 ms - ID：com.coconutnut.demo.mapper.UserMapper.selectByIdExecute SQL：    SELECT        id,        user_name,        password,        name,        age,        email,        version,        deleted     FROM        tb_user     WHERE        id=2         AND deleted=0null\n\nSQL中添加了deleted=0的条件，没有查到数据\n通用枚举修改表结构ALTER TABLE `tb_user`ADD COLUMN `sex` int(1) NULL DEFAULT 1 COMMENT &#x27;1-男，2-女&#x27; AFTER `deleted`;\n\n修改User实体类\nprivate SexEnum sex;\n\n定义枚举package com.coconutnut.demo.enums;import com.baomidou.mybatisplus.core.enums.IEnum;public enum SexEnum implements IEnum&lt;Integer&gt; &#123;    MAN(1,&quot;男&quot;),    WOMAN(2,&quot;女&quot;);    private int value;    private String desc;    SexEnum(int value, String desc) &#123;        this.value = value;        this.desc = desc;    &#125;    @Override    public Integer getValue() &#123;        return this.value;    &#125;    @Override    public String toString() &#123;        return this.desc;    &#125;&#125;\n\n配置# 枚举包扫描mybatis-plus.type-enums-package=com.coconutnut.demo.enums\n\n测试@Testpublic void testInsert()&#123;  User user = new User();  user.setName(&quot;张五&quot;);  user.setAge(30);  user.setPassword(&quot;123456&quot;);  user.setUserName(&quot;zhangwu&quot;);  user.setEmail(&quot;zhangwu@itcast.cn&quot;);  user.setSex(SexEnum.WOMAN);  boolean insert = user.insert();  System.out.println(insert);&#125;\n\n输出\n Time：6 ms - ID：com.coconutnut.demo.mapper.UserMapper.insertExecute SQL：    INSERT     INTO        tb_user        ( user_name, password, name, age, email, sex, version )     VALUES        ( &#x27;zhangwu&#x27;, &#x27;123456&#x27;, &#x27;张五&#x27;, 30, &#x27;zhangwu@itcast.cn&#x27;, 2, 1 )true\n\n\n\n代码生成器AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、MapperXML、Service、Controller 等各个模块的代码，提升开发效率\n\nhttps://www.bilibili.com/video/BV1rE41197jR?p=60\n\nMyBatisX快速开发插件基于 IDEA 的快速开发插件\n安装：File -&gt; Settings -&gt; Plugins，搜索并安装\n功能：Java和对应XML跳转；Mapper方法自动生成 XML\n","categories":["Note"],"tags":["mybatis_plus"]},{"title":"SpringCloud笔记06 Gateway服务网关","url":"/2020/04/25/note-springcloud-06/","content":"\nhttps://blog.csdn.net/ThinkWon/article/details/103757927\n\nGateway是在Spring生态系统之上构建的API网关服务，旨在提供一种简单而有效的方式来对API进行路由，以及提供一些强大的过滤器功能， 例如：熔断、限流、重试等\n集成Hystrix的断路器功能和Spring Cloud服务发现功能\n创建api-gateway模块添加依赖&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt;\n\n不需要注册？\n配置server:  port: 9201service-url:  user-service: http://localhost:8201spring:  cloud:    gateway:      routes:          # 路由的ID        - id: path_route          # 匹配后路由地址          uri: $&#123;service-url.user-service&#125;/user/&#123;id&#125;          predicates:              # 断言，路径相匹配的进行路由            - Path=/user/&#123;id&#125;\n\n启动consul-server、user-service和api-gateway\n测试 http://localhost:9201/user/1\n\n\nRoute Predicate 的使用\nAfter Route Predicate : 在指定时间之后的请求会匹配该路由\n\nBefore Route Predicate : 在指定时间之前的请求会匹配该路由\n\nBetween Route Predicate : 在指定时间区间内的请求会匹配该路由\n\nCookie Route Predicate : 带有指定Cookie的请求会匹配该路由\nusername=jourwon\n\nHeader Route Predicate : 带有指定请求头的请求会匹配该路由\nX-Request-Id:123\n\nHost Route Predicate : 带有指定Host的请求会匹配该路由\nHost:www.jourwon.com\n\nMethod Route Predicate : 发送指定方法的请求会匹配该路由\nGET\n\nPath Route Predicate : 发送指定路径的请求会匹配该路由\n/user/1\n\nQuery Route Predicate : 带指定查询参数的请求可以匹配该路由\nusername=jourwon\n\nRemoteAddr Route Predicate : 从指定远程地址发起的请求可以匹配该路由\n\nWeight Route Predicate : 使用权重来路由相应请求\n如80%的请求路由到localhost:8201，20%路由到localhost:8202\nspring:  cloud:    gateway:      routes:      - id: weight_high        uri: http://localhost:8201        predicates:        - Weight=group1, 8      - id: weight_low        uri: http://localhost:8202        predicates:        - Weight=group1, 2\n\n\n\nRoute Filter的使用可用于修改进入的HTTP请求和返回的HTTP响应，只能指定路由进行使用\n\nAddRequestParameter GatewayFilter : 给请求添加参数的过滤器\nStripPrefix GatewayFilter : 对指定数量的路径前缀进行去除的过滤器\nPrefixPath GatewayFilter : 与StripPrefix过滤器相反，会对原有路径进行增加操作的过滤器\nRetry GatewayFilter : 对路由请求进行重试的过滤器，根据路由请求返回的HTTP状态码来确定是否进行重试\n\nHystrix GatewayFilter将断路器功能添加到网关路由中\n需添加Hystrix的相关依赖\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt;\n\n添加相关服务降级的处理类FallbackController\n@RestControllerpublic class FallbackController &#123;    @GetMapping(&quot;/fallback&quot;)    public Object fallback() &#123;        Map&lt;String,Object&gt; result = new HashMap&lt;&gt;();        result.put(&quot;data&quot;,null);        result.put(&quot;message&quot;,&quot;Get request fallback!&quot;);        result.put(&quot;code&quot;,500);        return result;    &#125;&#125;\n\n配置服务降级\nfilters:  - name: Hystrix    args:      name: fallbackcmd      fallback-uri: forward:/fallback\n\n测试（先重启api-gateway）\n关闭user-service，调用http://localhost:9201/user/1 \n\n\n发生了降级\nRequestRateLimiter GatewayFilter可以用于限流\n添加依赖\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis-reactive&lt;/artifactId&gt;&lt;/dependency&gt;\n\n添加限流策略的配置类\n@Configurationpublic class RedisRateLimiterConfig &#123;    @Bean    public KeyResolver userKeyResolver() &#123;        // 根据请求参数中的username进行限流        return exchange -&gt; Mono.just(exchange.getRequest().getQueryParams().getFirst(&quot;username&quot;));    &#125;    @Primary    @Bean    public KeyResolver ipKeyResolver() &#123;        // 根据访问IP进行限流        return exchange -&gt; Mono.just(exchange.getRequest().getRemoteAddress().getHostName());    &#125;&#125;\n\n添加Redis和RequestRateLimiter的配置\n- name: RequestRateLimiter  args:    # 每秒允许处理的请求数量    redis-rate-limiter.replenishRate: 1    # 每秒最大处理的请求数量    redis-rate-limiter.burstCapacity: 2    # 限流策略，对应策略的Bean    key-resolver: &quot;#&#123;@ipKeyResolver&#125;&quot;\n\n测试\n启动服务，多次请求 http://localhost:9201/user/1\n\n\n报错429\nDEBUG：启动失败报错\n***************************APPLICATION FAILED TO START***************************Description:Parameter 1 of method requestRateLimiterGatewayFilterFactory in org.springframework.cloud.gateway.config.GatewayAutoConfiguration required a single bean, but 2 were found:\t- userKeyResolver: defined by method &#x27;userKeyResolver&#x27; in class path resource [com/coconutnut/apigateway/config/RedisRateLimiterConfig.class]\t- ipKeyResolver: defined by method &#x27;ipKeyResolver&#x27; in class path resource [com/coconutnut/apigateway/config/RedisRateLimiterConfig.class]Action:Consider marking one of the beans as @Primary, updating the consumer to accept multiple beans, or using @Qualifier to identify the bean that should be consumedProcess finished with exit code 1\n\n根据提示加上@Primary，解决\nDEBUG：Redis连接失败访问http://localhost:9201/user/1时数据正常，但控制台报错\norg.springframework.data.redis.RedisConnectionFailureException: Unable to connect to Redis; nested exception is io.lettuce.core.RedisConnectionException: Unable to connect to localhost:6379\tat org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory$SharedConnection.getNativeConnection(LettuceConnectionFactory.java:1199) ~[spring-data-redis-2.2.3.RELEASE.jar:2.2.3.RELEASE]\tat org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory$SharedConnection.getConnection(LettuceConnectionFactory.java:1178) ~[spring-data-redis-2.2.3.RELEASE.jar:2.2.3.RELEASE]\t...\n\n下载安装\n\nhttp://www.redis.cn/download.html\n\n启动\nredis-5.0.5 % src/redis-server\n\n\n\n好可爱🙀\n结合注册中心使用（弃）\n教程给的是eureka，这里尝试改成consul\n加依赖\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;\n\n改配置\nspring:  cloud:    application:      name: api-gateway    consul:      host: localhost      port: 8500      discovery:        service-name: $&#123;spring.application.name&#125;    gateway:      discovery:        locator:          #开启从注册中心动态创建路由的功能          enabled: true          #使用小写服务名，默认是大写          lower-case-service-id: true\n\nDEBUG：启动失败报错\norg.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;webHandler&#x27; defined in class path resource [org/springframework/boot/autoconfigure/web/reactive/WebFluxAutoConfiguration$EnableWebFluxConfiguration.class]: Initialization of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;webEndpointReactiveHandlerMapping&#x27; defined in class path resource [org/springframework/boot/actuate/autoconfigure/endpoint/web/reactive/WebFluxEndpointManagementContextConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.boot.actuate.endpoint.web.reactive.WebFluxEndpointHandlerMapping]: Factory method &#x27;webEndpointReactiveHandlerMapping&#x27; threw exception; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;org.springframework.cloud.client.serviceregistry.ServiceRegistryAutoConfiguration$ServiceRegistryEndpointConfiguration&#x27;: Unsatisfied dependency expressed through field &#x27;registration&#x27;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;consulRegistration&#x27; defined in class path resource [org/springframework/cloud/consul/serviceregistry/ConsulAutoServiceRegistrationAutoConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.cloud.consul.serviceregistry.ConsulAutoRegistration]: Factory method &#x27;consulRegistration&#x27; threw exception; nested exception is java.lang.IllegalArgumentException: Consul service ids must not be empty, must start with a letter, end with a letter or digit, and have as interior characters only letters, digits, and hyphen: 9201\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:603) ~[spring-beans-5.2.2.RELEASE.jar:5.2.2.RELEASE]\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) ~[spring-beans-5.2.2.RELEASE.jar:5.2.2.RELEASE]\n\n发现启动类忘加注释了，加上先\n@EnableDiscoveryClient\n\n看下依赖，没有冲突\n\n\n但是确实是加了consul的依赖之后才报错的\n去掉它的依赖就可以正常启动\n\nhttps://blog.csdn.net/jiazhiyuan0/article/details/84033595\nhttps://blog.csdn.net/maduo_duo/article/details/84866137\n\n确实可能是有冲突\n现在的Spring Boot版本是2.2.2.RELEASE，Spring Cloud版本是2.2.0.RELEASE\n尝试1\n把Spring Boot降到2.2.0\n并不行\n尝试2\n\nhttps://github.com/spring-cloud/spring-cloud-gateway/issues/319\nFinchley is not compatible with boot 2.1.0. Either downgrade to boot 2.0.6 or use Greenwich.M3\n\n这里用的是Hoxton版本\n找下文档\n\nhttps://spring.io/blog/2019/11/28/spring-cloud-hoxton-released\n\nConsul和Gateway的版本也是2.2.0.RELEASE\n\nhttps://spring.io/projects/spring-cloud#overview\n\nHoxton对应的Boot Version是2.2.x\n应该没错\n好几个地方看到说是spring-boot-starter-web的问题\n\n\n搜一下，确实引用了\n把它排除\n&lt;exclusions&gt;  &lt;exclusion&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;  &lt;/exclusion&gt;&lt;/exclusions&gt;\n\n\n\n并不行\n尝试3\n找找Spring Cloud Hoxton + Gatway + Consul的教程\n\nhttps://piotrminkowski.com/2019/11/06/microservices-with-spring-boot-spring-cloud-gateway-and-consul-cluster/\n\n这个教程的依赖是\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-consul-all&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;\n\n已有\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n\n把之前spring-boot-starter的依赖改成spring-boot-starter-web\n&lt;!--        &lt;dependency&gt;--&gt;&lt;!--            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;--&gt;&lt;!--            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;--&gt;&lt;!--        &lt;/dependency&gt;--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;\n\n还是没启动成功，但是报错变成了\n2020-04-25 12:09:53.083 ERROR 4989 --- [           main] o.s.boot.SpringApplication               : Application run failedorg.springframework.context.ApplicationContextException: Unable to start web server; nested exception is org.springframework.boot.web.server.WebServerException: Unable to start embedded Tomcat\tat org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.onRefresh(ServletWebServerApplicationContext.java:156) ~[spring-boot-2.2.2.RELEASE.jar:2.2.2.RELEASE]\t...\n\n\nhttps://blog.csdn.net/fly_west/article/details/101229871?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1\n\n还是spring-boot-starter-web冲突的问题\n现在再把gateway里的webflux排除试试\n2020-04-25 12:12:38.331 ERROR 5002 --- [           main] o.s.boot.SpringApplication               : Application run failedorg.springframework.context.ApplicationContextException: Unable to start web server; nested exception is org.springframework.boot.web.server.WebServerException: Unable to start embedded Tomcat\tat org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.onRefresh(ServletWebServerApplicationContext.java:156) ~[spring-boot-2.2.2.RELEASE.jar:2.2.2.RELEASE]\t...\n\n尝试4\n依赖全改得和刚那个教程一样试试\nhystrix和redis相关的都注释掉\n版本\n&lt;parent&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;  &lt;version&gt;2.2.0.RELEASE&lt;/version&gt;&lt;/parent&gt;\n\n&lt;spring-cloud.version&gt;Hoxton.RC1&lt;/spring-cloud.version&gt;\n\n依赖\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-consul-all&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;\n\n还是崩了\n发现一个问题，依赖的最下面怎么还有个\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-commons&lt;/artifactId&gt;  &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;  &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;\n\n估计是创建的时候导入的，删掉\n重启\n崩\n尝试5\n还是把版本改回Spring Boot 2.2.0和Spring Cloud Hoxton\n现在的依赖\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;  &lt;!--            &lt;exclusions&gt;--&gt;  &lt;!--                &lt;exclusion&gt;--&gt;  &lt;!--                    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;--&gt;  &lt;!--                    &lt;artifactId&gt;spring-cloud-starter-webflux&lt;/artifactId&gt;--&gt;  &lt;!--                &lt;/exclusion&gt;--&gt;  &lt;!--            &lt;/exclusions&gt;--&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;\n\n现在的报错\n2020-04-25 12:32:36.436 ERROR 5170 --- [           main] o.s.boot.SpringApplication               : Application run failedorg.springframework.context.ApplicationContextException: Unable to start web server; nested exception is org.springframework.boot.web.server.WebServerException: Unable to start embedded Tomcat\tat org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.onRefresh(ServletWebServerApplicationContext.java:156) ~[spring-boot-2.2.2.RELEASE.jar:2.2.2.RELEASE]\t...\n\n刚才看依赖图发现gateway依赖的是webflux\n这里依赖的是web\n如果改成webflux？\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;&lt;/dependency&gt;\n\n报错\n2020-04-25 12:33:57.502 ERROR 5182 --- [           main] o.s.boot.SpringApplication               : Application run failedorg.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;webHandler&#x27; defined in class path resource [org/springframework/boot/autoconfigure/web/reactive/WebFluxAutoConfiguration$EnableWebFluxConfiguration.class]: Initialization of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;webEndpointReactiveHandlerMapping&#x27; defined in class path resource [org/springframework/boot/actuate/autoconfigure/endpoint/web/reactive/WebFluxEndpointManagementContextConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.boot.actuate.endpoint.web.reactive.WebFluxEndpointHandlerMapping]: Factory method &#x27;webEndpointReactiveHandlerMapping&#x27; threw exception; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;org.springframework.cloud.client.serviceregistry.ServiceRegistryAutoConfiguration$ServiceRegistryEndpointConfiguration&#x27;: Unsatisfied dependency expressed through field &#x27;registration&#x27;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;consulRegistration&#x27; defined in class path resource [org/springframework/cloud/consul/serviceregistry/ConsulAutoServiceRegistrationAutoConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.cloud.consul.serviceregistry.ConsulAutoRegistration]: Factory method &#x27;consulRegistration&#x27; threw exception; nested exception is java.lang.IllegalArgumentException: Consul service ids must not be empty, must start with a letter, end with a letter or digit, and have as interior characters only letters, digits, and hyphen: 9201\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:603) ~[spring-beans-5.2.2.RELEASE.jar:5.2.2.RELEASE]\t...\n\n所以应该是，启动需要web，否则报BeanCreationException\n而gateway依赖了webflux，和web冲突，报ApplicationContextException\n再把exclusion加上\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;  &lt;exclusions&gt;    &lt;exclusion&gt;      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;      &lt;artifactId&gt;spring-cloud-starter-webflux&lt;/artifactId&gt;    &lt;/exclusion&gt;  &lt;/exclusions&gt;&lt;/dependency&gt;\n\n2020-04-25 12:35:30.492 ERROR 5188 --- [           main] o.s.boot.SpringApplication               : Application run failedorg.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;webHandler&#x27; defined in class path resource [org/springframework/boot/autoconfigure/web/reactive/WebFluxAutoConfiguration$EnableWebFluxConfiguration.class]: Initialization of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;webEndpointReactiveHandlerMapping&#x27; defined in class path resource [org/springframework/boot/actuate/autoconfigure/endpoint/web/reactive/WebFluxEndpointManagementContextConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.boot.actuate.endpoint.web.reactive.WebFluxEndpointHandlerMapping]: Factory method &#x27;webEndpointReactiveHandlerMapping&#x27; threw exception; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;org.springframework.cloud.client.serviceregistry.ServiceRegistryAutoConfiguration$ServiceRegistryEndpointConfiguration&#x27;: Unsatisfied dependency expressed through field &#x27;registration&#x27;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;consulRegistration&#x27; defined in class path resource [org/springframework/cloud/consul/serviceregistry/ConsulAutoServiceRegistrationAutoConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.cloud.consul.serviceregistry.ConsulAutoRegistration]: Factory method &#x27;consulRegistration&#x27; threw exception; nested exception is java.lang.IllegalArgumentException: Consul service ids must not be empty, must start with a letter, end with a letter or digit, and have as interior characters only letters, digits, and hyphen: 9201\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:603) ~[spring-beans-5.2.2.RELEASE.jar:5.2.2.RELEASE]\t...\n\n把exclusion去掉，webflux删了\n2020-04-25 12:37:30.419 ERROR 5199 --- [           main] o.s.boot.SpringApplication               : Application run failedorg.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;webHandler&#x27; defined in class path resource [org/springframework/boot/autoconfigure/web/reactive/WebFluxAutoConfiguration$EnableWebFluxConfiguration.class]: Initialization of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;webEndpointReactiveHandlerMapping&#x27; defined in class path resource [org/springframework/boot/actuate/autoconfigure/endpoint/web/reactive/WebFluxEndpointManagementContextConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.boot.actuate.endpoint.web.reactive.WebFluxEndpointHandlerMapping]: Factory method &#x27;webEndpointReactiveHandlerMapping&#x27; threw exception; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;org.springframework.cloud.client.serviceregistry.ServiceRegistryAutoConfiguration$ServiceRegistryEndpointConfiguration&#x27;: Unsatisfied dependency expressed through field &#x27;registration&#x27;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;consulRegistration&#x27; defined in class path resource [org/springframework/cloud/consul/serviceregistry/ConsulAutoServiceRegistrationAutoConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.cloud.consul.serviceregistry.ConsulAutoRegistration]: Factory method &#x27;consulRegistration&#x27; threw exception; nested exception is java.lang.IllegalArgumentException: Consul service ids must not be empty, must start with a letter, end with a letter or digit, and have as interior characters only letters, digits, and hyphen: 9201\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:603) ~[spring-beans-5.2.2.RELEASE.jar:5.2.2.RELEASE]\t...\n\n\n\n尝试6\n\nhttps://github.com/spring-cloud/spring-cloud-gateway/issues/319\n\n之前这个issue里面有人说\n\nspring cloud gateway is not compatible with spring mvc and servlet containers, what you get when you depend on spring-boot-starter-web.\n\n试试把spring-boot-starter-web里的spring mvc和servlet排除了？\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;  &lt;exclusions&gt;    &lt;exclusion&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;    &lt;/exclusion&gt;  &lt;/exclusions&gt;&lt;/dependency&gt;\n\n不行\n\nhttps://github.com/spring-cloud/spring-cloud-gateway/issues/1004\nspring-cloud-gateway-mvc is not compatible with gateway core. You need to use spring-cloud-gateway-webflux.\n\n\nhttps://github.com/spring-cloud/spring-cloud-gateway/issues/1473\nSpring MVC found on classpath, which is incompatible with Spring Cloud Gateway at this time. Please remove spring-boot-starter-web dependency.\n\n现在就只有这几个依赖，为什么还是启动不了呢\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;\n\n难道actuator里面也有web？\n把它注释掉\n报错变成\n2020-04-25 13:17:36.860 ERROR 5310 --- [           main] o.s.boot.SpringApplication               : Application run failedorg.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;org.springframework.cloud.client.serviceregistry.AutoServiceRegistrationAutoConfiguration&#x27;: Unsatisfied dependency expressed through field &#x27;autoServiceRegistration&#x27;; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;consulAutoServiceRegistration&#x27; defined in class path resource [org/springframework/cloud/consul/serviceregistry/ConsulAutoServiceRegistrationAutoConfiguration.class]: Unsatisfied dependency expressed through method &#x27;consulAutoServiceRegistration&#x27; parameter 3; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;consulRegistration&#x27; defined in class path resource [org/springframework/cloud/consul/serviceregistry/ConsulAutoServiceRegistrationAutoConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.cloud.consul.serviceregistry.ConsulAutoRegistration]: Factory method &#x27;consulRegistration&#x27; threw exception; nested exception is java.lang.IllegalArgumentException: Consul service ids must not be empty, must start with a letter, end with a letter or digit, and have as interior characters only letters, digits, and hyphen: 9201\tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:643) ~[spring-beans-5.2.2.RELEASE.jar:5.2.2.RELEASE]\t...\n\n\nhttps://github.com/spring-cloud/spring-cloud-gateway/issues/802\nGateway is thought to be used as a separate technical component in your architecture. It usually does not make sense to add a gateway dependency directly to your business code.\n\n适合单独使用…\n单独使用…\n单独…\nfine\n暂时就不结合注册中心了\n以后有需要再说\n再见\n","categories":["Note"],"tags":["springcloud"]},{"title":"SpringCloud笔记07 总结","url":"/2020/04/25/note-springcloud-07/","content":"\n\n","categories":["Note"],"tags":["mindmap","springcloud"]},{"title":"四月每日一题打卡完工纪念","url":"/2020/04/30/memo/","content":"\n\n三月差一点点，四月成功咯~\n\n\n","categories":["Memo"],"tags":["algorithm"]},{"title":"读书笔记 深度工作","url":"/2020/05/02/deepwork/","content":"\n《深度工作》 [美] 卡尔·纽波特\n\n","categories":["Memo"],"tags":["mindmap"]},{"title":"git笔记","url":"/2020/05/02/note-git/","content":"\nhttps://github.com/pcottle/learnGitBranching\n\n\n\n","categories":["Note"],"tags":["tool","mindmap"]},{"title":"Android 10 闪退问题","url":"/2020/05/04/debug/","content":"（未解决）\nbug描述打开工程可以安装，但是闪退\nBuild中报错\n注: 某些输入文件使用或覆盖了已过时的 API。注: 有关详细信息, 请使用 -Xlint:deprecation 重新编译。\n\n尝试解决尝试1\nhttps://blog.csdn.net/caidi1988314/article/details/52460922?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3\n\nbuild.gradle android {}里加\nallprojects &#123;  gradle.projectsEvaluated &#123;    tasks.withType(JavaCompile) &#123;    \toptions.compilerArgs &lt;&lt; &quot;-Xlint:unchecked&quot; &lt;&lt; &quot;-Xlint:deprecation&quot;                       \t\t&#125;  &#125;&#125;\n\n 出现\n\n\n在报错的函数上加\n@SuppressWarnings(&quot;deprecation&quot;)\n\nBuild成功，但还是闪退\n尝试2看到activity_main.xml里有\n\n\n按提示修改\n还是闪退\n\nhttps://blog.csdn.net/yogima/article/details/89416885?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1\n\n把MainActivity所有函数都注释掉，可以打开\n一点一点放开\n发现问题在\nFile path = new File(dir);String[] list = path.list();len = list.length;if (len == 0) &#123; return 0; &#125;\n\nlist空的时候，list.length会异常\n加了个为空返回0\n但是这个异常怎么不提示呢？？？\n这里会为空应该读文件权限没有获取到\n尝试3像上次那样加\nandroid:requestLegacyExternalStorage=&quot;true&quot;\n\n报错\nAAPT: error: attribute android:requestLegacyExternalStorage not found.\n\n\nhttps://blog.csdn.net/DeMonliuhui/article/details/99718553\n\n现在这个工程的版本是\ncompileSdkVersion 28buildToolsVersion &#x27;28.0.3&#x27;defaultConfig &#123;  applicationId &quot;com.example.mydoppler&quot;  minSdkVersion 15  targetSdkVersion 28  versionCode 1  versionName &quot;1.0&quot;  testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#125;\n\n改成\ncompileSdkVersion 29buildToolsVersion &quot;29.0.2&quot;defaultConfig &#123;  applicationId&quot;com.example.mydoppler&quot;  minSdkVersion 26  targetSdkVersion 29  versionCode 1  versionName &quot;1.0&quot;  testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#125;\n\nrequestLegacyExternalStorage属性可以加了\n输出那个获取的文件路径，还是null\n尝试4在Run里面又发现一句红的\nE/libc: Access denied finding property &quot;ro.vendor.df.effect.conflict&quot;\n\n","categories":["Debug"]},{"title":"pyenv配置不生效","url":"/2020/05/07/debug/","content":"问题描述以前装过pyenv，可以正常使用\n今天用的时候发现配置的版本没有生效\ncoconutnut@Ss-MacBook-Pro ~ % pyenv versions* system (set by /Users/coconutnut/.pyenv/version)  3.7.4coconutnut@Ss-MacBook-Pro ~ % pyenv global 3.7.4coconutnut@Ss-MacBook-Pro ~ % python -VPython 2.7.17\n\n解决\nhttps://blog.csdn.net/vencent7/article/details/76849849\n\n也许是以前装Jupiter或者用Tensorflow的时候把环境搞坏了？\n试试把pyenv的配置放在.bash_profile的最后\n# pyenvexport PYENV_ROOT=&quot;$HOME/.pyenv&quot;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;eval &quot;$(pyenv init -)&quot;# eval &quot;$(pyenv virtualenv-init -)&quot;\n\n再试试\ncoconutnut@Ss-MacBook-Pro ~ % source ~/.bash_profilecoconutnut@Ss-MacBook-Pro ~ % python -V            Python 3.7.4\n\n成功\nPS：\n安装pyenv的教程有的改.bash_profile有的改.bashrc\n\nhttps://www.bbsmax.com/A/lk5aj7Eld1/\n在安装成功之后需要在.bashrc或者.bash_profile中添加三行来开启自动补全\n\n应该都是可以的\n","categories":["Debug"]},{"title":"记录服务器部署","url":"/2020/05/07/memo-server/","content":"以前的服务器过期了，重新买了部署，希望这次少踩点坑\n服务器环境：Ubuntu 16.04 64位\n服务器配置\n重置密码&amp;重启实例\n\n添加安全组规则\n\nhttps://help.aliyun.com/document_detail/151694.html?spm=a2c4g.11186623.6.582.56d15bbbDfXG8X\n\n顺便把8000~9000都开了\n\n\n终端访问\nssh连接\nssh root@&lt;实例公网IP地址&gt;\n\n✌️\n\n\n安装jdk和Tomcat\n下载jdk-14.0.1_linux-x64_bin.tar.gz和apache-tomcat-9.0.34.tar.gz\n\nhttps://www.oracle.com/java/technologies/javase-jdk14-downloads.html\nhttps://tomcat.apache.org/download-90.cgi\n\n（之前装的是jdk12，不知道这样会不会有毛病）\n\nFileZilla连接服务器，上面两个包传到root文件夹下\n\n回到终端，新建javaee文件夹，解压\n~# lsapache-tomcat-9.0.34.tar.gz jdk-14.0.1_linux-x64_bin.tar.gz~# mkdir javaee~# tar zxvf jdk-14.0.1_linux-x64_bin.tar.gz -C javaee\n\n配置java环境变量\n~# vim /etc/profile\n\n最后加上\n# set java environmentexport JAVA_HOME=/root/javaee/jdk-14.0.1export PATH=$JAVA_HOME/bin:$PATH\n\n~# source /etc/profile~# java -versionjava version &quot;14.0.1&quot; 2020-04-14Java(TM) SE Runtime Environment (build 14.0.1+7)Java HotSpot(TM) 64-Bit Server VM (build 14.0.1+7, mixed mode, sharing)\n\n✌️\n\n安装tomcat\n~# tar zxvf apache-tomcat-9.0.34.tar.gz -C javaee\n\n配置catalina.sh\n~/javaee/apache-tomcat-9.0.34/bin# vim /catalina.sh\n\n加一句\nexport JAVA_HOME=/root/javaee/jdk-14.0.1\n\n测试\n~/javaee/apache-tomcat-9.0.34/bin# ./startup.sh Using CATALINA_BASE:   /root/javaee/apache-tomcat-9.0.34Using CATALINA_HOME:   /root/javaee/apache-tomcat-9.0.34Using CATALINA_TMPDIR: /root/javaee/apache-tomcat-9.0.34/tempUsing JRE_HOME:        /root/javaee/jdk-14.0.1Using CLASSPATH:       /root/javaee/apache-tomcat-9.0.34/bin/bootstrap.jar:/root/javaee/apache-tomcat-9.0.34/bin/tomcat-juli.jarTomcat started.\n\n\n\n~/javaee/apache-tomcat-9.0.34/bin# ./shutdown.sh Using CATALINA_BASE:   /root/javaee/apache-tomcat-9.0.34Using CATALINA_HOME:   /root/javaee/apache-tomcat-9.0.34Using CATALINA_TMPDIR: /root/javaee/apache-tomcat-9.0.34/tempUsing JRE_HOME:        /root/javaee/jdk-14.0.1Using CLASSPATH:       /root/javaee/apache-tomcat-9.0.34/bin/bootstrap.jar:/root/javaee/apache-tomcat-9.0.34/bin/tomcat-juli.jarNOTE: Picked up JDK_JAVA_OPTIONS:  --add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/java.io=ALL-UNNAMED --add-opens=java.rmi/sun.rmi.transport=ALL-UNNAMED\n\n✌️\n\n\n\n完工！\n一遍过太快乐了\n","categories":["Memo"]},{"title":"Anki也太优秀了吧！","url":"/2020/05/12/memo/","content":"以前看剧的时候喜欢截屏，把不认识的词记录下来，零零散散屯了好多词\n\n\n但是并不好复习，背单词的时候还是不认识\n而Anki！加上Image Occlusion Enhanced插件！完美解决！\n\n\n拖个框遮住单词就好了，再在header里面填上单词\n以后的复习安排就不用自己管了~\n\n\n一个问题是header里填的单词会在复习时显示\n但是！\n还能编辑卡片模板是什么神仙功能啊！注释掉header就行了嗷~\n\n\n太美妙了快乐得原地转圈~\n仿佛能看见日后蹭蹭增长的词汇量\n我爱Anki😍😍😍\n\n发现现在真的是用了好多效率软件，简直是强迫症，为了找个满意的能从安卓应用商店到App Store到Google Play翻个遍，尤其是背单词和任务管理，扇贝不背百词斩、滴答ToDo水滴…最后剩下的都是现在最喜欢的，不知道以后还能不能发现更好的~\n\n日程管理：Apple自带的日历📅\n任务管理：Trello\n背单词：墨墨\n背诗：年轮（估计要转移到Anki了哈哈）\n习惯打卡：Dot Habit（还没用到一个月，待定）\n\n","categories":["Memo"]},{"title":"五月每日一题打卡完工纪念","url":"/2020/05/31/memo/","content":"\n\n居然出徽章了，太戳我了\n","categories":["Memo"],"tags":["algorithm"]},{"title":"项目Debug记录","url":"/2020/06/16/debug/","content":"找不到’xmlModelPlugin’05.30\nclone的工程启动失败，控制台报错：\nError starting ApplicationContext. To display the conditions report re-run your application with &#x27;debug&#x27; enabled.2020-05-30 10:57:39.476 ERROR 1335 --- [           main] o.s.boot.SpringApplication               : Application run failedorg.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;xmlModelPlugin&#x27;: Lookup method resolution failed; nested exception is java.lang.IllegalStateException: Failed to introspect Class [springfox.documentation.schema.XmlModelPlugin] from ClassLoader [jdk.internal.loader.ClassLoaders$AppClassLoader@3d4eac69]\tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.determineCandidateConstructors(AutowiredAnnotationBeanPostProcessor.java:289) ~[spring-beans-5.2.5.RELEASE.jar:5.2.5.RELEASE]\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.determineConstructorsFromBeanPostProcessors(AbstractAutowireCapableBeanFactory.java:1286) ~[spring-beans-5.2.5.RELEASE.jar:5.2.5.RELEASE]\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1201) ~[spring-beans-5.2.5.RELEASE.jar:5.2.5.RELEASE]\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557) ~[spring-beans-5.2.5.RELEASE.jar:5.2.5.RELEASE]\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) ~[spring-beans-5.2.5.RELEASE.jar:5.2.5.RELEASE]...\n\n解决\n添加依赖\n&lt;dependency&gt;    &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;    &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;    &lt;version&gt;2.3.0&lt;/version&gt;&lt;/dependency&gt;\n\n加载yml文件错误06.12\n今天新pull的工程打不开\njava.lang.IllegalStateException: Failed to load property source from location &#x27;classpath:/bootstrap.yml&#x27;\n\n查看target -&gt; classes -&gt; bootstrap.yml\n发现一个main被画了波浪线，说重复定义\n发现\nmain:  allow-bean-definition-overriding: true\n\n写了2次\n注释掉一个就好了\n找不到’springSecurityFilterChain’06.16\n新pull的又打不开了\norg.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;springSecurityFilterChain&#x27;\n\n根据这里的一个回答\n\nhttps://github.com/spring-guides/tut-spring-boot-oauth2/issues/68\n\n加上了\n&lt;dependency&gt;  &lt;groupId&gt;org.glassfish.jaxb&lt;/groupId&gt;  &lt;artifactId&gt;jaxb-runtime&lt;/artifactId&gt;  &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt;  &lt;!-- JAXB needs javax.activation module (jdk9) --&gt;&lt;dependency&gt;  &lt;groupId&gt;javax.activation&lt;/groupId&gt;  &lt;artifactId&gt;javax.activation-api&lt;/artifactId&gt;  &lt;version&gt;1.2.0&lt;/version&gt;&lt;/dependency&gt;\n\n成功启动\n","categories":["Debug"]},{"title":"笔记 推荐系统","url":"/2020/06/23/recommendation/","content":"\nhttps://www.bilibili.com/video/av30578499/\n\nOverview\n\n传统推荐系统Content-based：unstructured，文字、图像等，需理解语义、提取大量特征，算法复杂延迟高\nCollaborative filtering协同过滤：基于User、Item历史，如点击是1、不点击是0\nDemographic：地域信息\nKnowledge-based：根据专业知识\nCommunity-based：类似Content-based，如社交网络、人群兴趣\nHybrid：综合\n协同过滤\n\n基于相似User判断\n计算相似性 \n\nMemery-based\nItem-based 如，把Item转成矩阵计算相似性\nUser-based\n\n\nModel-based 建立User和Item的方程，给定一个User和Item返回一个分数\n\n\n\n思想：根据User-Item Rating矩阵，学到User和Item低维的特征表示，用它计算相似性\n购买为1，点击未购买为0，剩下补0\n矩阵分解：降维 找一个矩阵代表User，一个代表Item，相乘得到\n可做Regularization\n优点\nEasy to implement，系统简单，响应快\nContent-independent，与用户其它特征无关，不需要获取这些信息即可实现\n\n缺点\n数据稀疏\nCold-start problem 如新用户特征向量全0，无法计算\nDo not consider content\n\n深度学习优势：表征能力强、不需要做特征工程、\n先创建深度学习的网络结构实现协同过滤，再加入Content-based\nNeural Collaborative filtering\n\n\nEmbedding Layers\n\n把任何一个User、Item变成一个低维向量\nOne-Hot Encoding\n\n\nNeural CF Layers\n\n做矩阵分解\n可以加隐藏层，学习非线性表征\n\n\n\nNeural Matrix Factorization Model\n\n线性的和非线性的结合到一起\n问题：没有Content-based，希望加入手工提取的特征\nWide Deep Neural NetworkWide部分输入手工特征工程的结果，如：年龄、历史记录\nDeep部分是User、Item\n最后结合到一起做出预测\nEg: Google Play\n\n\n传统的 Factorization Machines直接对产品的类型信息做One-Hot Encoding\n\n\n特征交叉 如性别=男，年龄=20 把对应的维相乘，数据过大是难处理\n用矩阵分解的思想，wij变成&lt;vi,vj&gt;，其中vi,vj都是低维向量\n变形版本：\nField-aware Factorization Machines\n\n考虑特征是来自哪里的\n每一个特征，与其他类别交叉时，有一个不一样的依赖向量\nDeep Factorization Machines\n\n左侧：传统部分\n每个种类做Embedding\n为了实现交叉，两两做特征交叉\n线性部分，求和（最左的+）\n右侧：深度部分\n美团的测试结果：\n\n\nWide &amp; Deep 要做特征工程，DeepFM 做了一阶、二阶的特征交叉，同时用Deep神经网络做特征工程\nDeep Cooperative Neural Network卷积神经网络\n涉及图片、文字时可参考\n\n\nWord-Embedding 把每个单词映射成向量（Google : word2vec）\n最后得到User记录的低维表示，Item描述的低维表示\nRecurrent Neural Network\n\n给一个input，映射成低维向量，输出output\n同时反复自己迭代\n可学习与时间有关的信息，如不需要login的网站上用户点击的行为\nSession-based Recommendation with RNN\n\n预测用户下一步行为\n强化学习因为用户行为随时在变化，传统推荐系统无法实时做出调整\n\n\nState可以是用户的点击行为\nReward可以是点击了推荐的产品\n根据当前的State和Reward返回下一步Action\n用户对Action做出反应，得到新的State和Reward\n阿里的例子：\n\n\n","categories":["Note"]},{"title":"记录服务器安装Anaconda","url":"/2020/06/24/memo-python/","content":"pyenv每次都要source ~/.bash_profile才能生效，扎心，卸了\n现在笔记本上应该只有系统自带的2.7（和没卸干净的遗留文件）\ncoconutnut@Ss-MacBook-Pro ~ % python -VPython 2.7.17coconutnut@Ss-MacBook-Pro ~ % pip -Vpip 19.3.1 from /usr/local/lib/python2.7/site-packages/pip (python 2.7)\n\n想了下干脆装服务器上好了\n\n安装Anaconda\nhttps://blog.csdn.net/qq_41813258/article/details/102400325\n\n\nhttps://repo.anaconda.com/archive/\n\n官网下了个最新版anaconda3-2020.02-linux-x86_64.sh/\nbash安装，配置环境变量\n# conda -Vconda 4.8.2\n\n完成\n创建一个3.7.6的环境\n# conda create -n env3.7 python=3.7.6...## To activate this environment, use##     $ conda activate env3.7## To deactivate an active environment, use##     $ conda deactivate\n\n配置Jupyter notebook\nhttps://blog.csdn.net/qq_43058685/article/details/103804238\n\n端口配的2020\njupyter notebook --ip=0.0.0.0 --no-browser --allow-root\n\n浏览器试了一下，ok\n常用命令# 打开jupyter notebookjupyter notebook --allow-root# 后台运行nohup jupyter notebook --allow-root &amp;# 找到jupyter进程ps aux | grep jupyter# 关闭它kill XXX(pid)\n\n","categories":["Memo"]},{"title":"读书笔记 推荐系统实践","url":"/2020/06/24/recommender-system/","content":"\n\n","categories":["Note"],"tags":["mindmap"]},{"title":"记录部署静态页面","url":"/2020/08/10/webpage/","content":"把index.html和assets准备好\nssh连上服务器\nsudo apt-get install apache2\n\n把文件传到/var/www/html\n（一开始传成了/root/var/www/html，index.html一直显示不对）\nvim /etc/apache2/apache2.conf\n\n最后加一句\nServerName ***.**.**.89\n\n然后\nvim /etc/apache2/mods-available/dir.conf\n\n改成\n&lt;IfModule mod_dir.c&gt;DirectoryIndex  index.html&lt;/IfModule&gt;\n\n重启\nsudo apache2ctl -k restart\n\n浏览器访问\nhttp://xxx/index.html\nok\n","categories":["Note"]},{"title":"读书笔记 大脑修复术","url":"/2020/07/25/brain/","content":"\n\n\n\n\n\n","categories":["Memo"],"tags":["mindmap"]},{"title":"安装splinter记录","url":"/2020/09/09/note-splinter/","content":"pip install splinter\n\n坑\nbrew cask install chromedriver\n\n特别慢，装完一跑发现版本是81\n但是chrome://version查看是85，用不了\nbrew cask uninstall chromedriver\n\n卸了\n直接在https://sites.google.com/a/chromium.org/chromedriver/downloads 下载了对应版本，拖到/usr/local/bin/ 里\n% chromedriver -vChromeDriver 85.0.4183.87 (cd6713ebf92fa1cacc0f1a598df280093af0c5d7-refs/branch-heads/4183@&#123;#1689&#125;)\n\n成功\n","categories":["Debug"]},{"title":"AR Foundation笔记01 安卓Setup","url":"/2020/09/26/note-arfoundation-01/","content":"\n https://www.youtube.com/watch?v=0mpsiO2lCx0&amp;list=PL6VJLOFcTt7awvyIGIbLLPOBrW6-Y1R-J&amp;index=1&amp;ab_channel=DineshPunni\n\n\n环境macOS Catalina 10.15.6\nUnity Hub 2.3.10\nUnity 2020.1.6f1c1\n配置File -&gt; Build Settings\n切换平台到Android\n-&gt; Player Settings\n\nOther Settings -&gt; 改Package Name\n\nDisable Multithread Rendering (Android doesn’t support yet)\n\nGraphics APIs -&gt; disable Vulkan\n\nMinimun API level -&gt; 26\n\n\nPackageWindow -&gt; Package Manager -&gt; Packages : Unity Registry\n\n\nSample Scene\n删除Main Camera\n\nRight Click -&gt; XR -&gt; AR Session Origin\nAR Camera 标签 MainCamera\n\nRight Click -&gt; XR -&gt; AR Session\n\nRight Click -&gt; 3D Object -&gt; Cube位置改成0，0，0缩放改成0.2，0.2，0.2随便转转\n\n\nBuild手机 -&gt; 开发者模式\n连上\nFile -&gt; Build Settings -&gt; Run Device -&gt; 选中手机\n Add Open Scene\nBuild and Run\n\n\n成功~\n","categories":["Note"],"tags":["ar"]},{"title":"AR Foundation笔记02 Image Tracking","url":"/2020/09/26/note-arfoundation-02/","content":"\nhttps://www.youtube.com/watch?v=o_z_Eb8Yh2g&amp;list=PL6VJLOFcTt7awvyIGIbLLPOBrW6-Y1R-J&amp;index=3&amp;ab_channel=DineshPunni\n\n\nAR Session Origin -&gt; Add AR Tracked Image Manager\nAssets -&gt; Create -&gt; XR -&gt; Reference Image Library\n拖一张图到Assets里\nReference Library -&gt; Add Image 把图拖进去，填Physical Size\n\n\nAR Session Origin -&gt; 把Reference Library拖到AR Tracked Image Manager中\nAssets -&gt; Create -&gt; C# Script -&gt; 重命名ImageRecognitionExample\nusing System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.XR.ARFoundation;public class NewBehaviourScript : MonoBehaviour&#123;    private ARTrackedImageManager _arTrackedImageManager;        private void Awake()    &#123;        _arTrackedImageManager = FindObjectOfType&lt;ARTrackedImageManager&gt;();        &#125;        public void OnEnable()    &#123;        _arTrackedImageManager.trackedImagesChanged += OnImageChanged;    &#125;        public void onDisable()    &#123;        _arTrackedImageManager.trackedImagesChanged -= OnImageChanged;    &#125;        public void OnImageChanged(ARTrackedImagesChangedEventArgs args)    &#123;        foreach (var trackedImage in args.added)        &#123;            Debug.Log(trackedImage.name);        &#125;    &#125;&#125;\n\nCreate 3D Object Cube，调整位置、大小\n\n\n拖进Assets（变成prefab），在SampleScene中删除\n把prefab拖进AR Tracked Image Manager\nBuild\n\n\n成功~\n","categories":["Note"],"tags":["ar"]},{"title":"AR Foundation笔记03 Plane Detection","url":"/2020/09/28/note-arfoundation-03/","content":"\n https://www.youtube.com/watch?v=uWWiYfPTUtU&amp;list=PL6VJLOFcTt7awvyIGIbLLPOBrW6-Y1R-J&amp;index=4&amp;ab_channel=DineshPunni\n\n\n\nadd AR Plane Manager\n\nAR Session Origin-&gt; add component -&gt; AR Plane Manager\n\nBuild your own plane object (or use prebuilt prefab)\n\nCreate Empty Object\nAdd Components\n\n\nLine Renderer\n\n\n\nAdd material to Mesh Renderer\n\nCreate a folder in Assets\nCreate Material\n\n\nAssign to Mesh Renderer\n\nCreate prefab of this plane\n\nCreate a folder (Prefabs)\nDrag ARPlane to folder\nAssign to AR Plane Manager\n\n\n\nBuild\n\n\n\n🧐很是迷惑\n\n\n改了一下顺眼多了\n","categories":["Note"],"tags":["ar"]},{"title":"AR Foundation笔记04 Tap to Place Objects in AR","url":"/2020/09/28/note-arfoundation-04/","content":"\nhttps://www.youtube.com/watch?v=xguiSueY1Lw&amp;list=PL6VJLOFcTt7awvyIGIbLLPOBrW6-Y1R-J&amp;index=5&amp;ab_channel=DineshPunni\n\n\n(接笔记03)\nCreate New Folder (Scripts)\nCreate C# Script\nusing System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.XR.ARFoundation;using UnityEngine.XR.ARSubsystems;[RequireComponent(typeof(ARRaycastManager))]public class ARTapToPlaceObject : MonoBehaviour&#123;    public GameObject gameObjectToInstantiate;        private GameObject spawnedObject;    private ARRaycastManager arRaycastManager;    private Vector2 touchPosition;        static List&lt;ARRaycastHit&gt; hits = new List&lt;ARRaycastHit&gt;();        private void Awake()    &#123;        arRaycastManager = GetComponent&lt;ARRaycastManager&gt;();    &#125;        bool TryGetTouchPosition(out Vector2 touchPosition)    &#123;        if(Input.touchCount &gt; 0)        &#123;            touchPosition = Input.GetTouch(0).position;            return true;        &#125;                touchPosition = default;        return false;    &#125;        void Update()    &#123;        if(!TryGetTouchPosition(out Vector2 touchPosition))        &#123;            return;        &#125;        if(arRaycastManager.Raycast(touchPosition,hits,TrackableType.PlaneWithinPolygon))        &#123;            var hitPose = hits[0].pose;                        if(spawnedObject == null)            &#123;                spawnedObject = Instantiate(gameObjectToInstantiate, hitPose.position, hitPose.rotation);            &#125;            else            &#123;                spawnedObject.transform.position = hitPose.position;            &#125;        &#125;    &#125;    &#125;\n\n把Script拖进AR Session Origin\nCreate Cube拖进Prefabs，拖进GameObjectToInstantiate\n\n\nBuild\n\n\nYeah~\n","categories":["Note"],"tags":["ar"]},{"title":"AR Foundation笔记05 Gaze Interaction","url":"/2020/09/28/note-arfoundation-05/","content":"\nhttps://www.youtube.com/watch?v=OE66gtiF8QQ&amp;ab_channel=ThirdAurora\n\n\nFirst Try (Failed)创建项目start from : https://github.com/Third-Aurora/ARFoundationExample \n新建一个Project03，把Assets拷进去\n资源管理器里+ARFoundation &amp; AR Core\n切换平台到Android，一系列设置同笔记01\nContent Parent已导入资源：\n\n\nContent Parent -&gt; Cube xyz都改成0.5\n创建空对象叫SectionInfo\n创建3D Object Quad叫InfoParent\n把SectionInfo拖高一点 Y-&gt;1.5\n旋转InfoParent Y-&gt;180 缩放 X-&gt;2\nMaterialsAssets中新建文件夹Materials\n创建材质trans，拖到InfoParent上\n颜色：Black 0.7Opacity\nRendering Mode：Transparent\n另外创建一个blue材质，拖到cube上\nInfoParentInfoParent下创建Cube，调整一下位置\n\n\n也用trans材质\n创建Text - TextMeshPro，import TMP essentials\n调整大小，文字居中，Auto Size（min 0，max 1000）\n\n\nInfoParent拖成和SectionInfo同级\n拖动SectionInfo的锚点高度和Cube上方对齐\n再把InfoParent拖进去\n此时调整SetcionInfo Scale的y，牌子像从Box里出来\n(Text -&gt; Extra Setting -&gt; Order in Layer改成1 )\nScript\n让SectionInfo出现\n\n新建Script叫InfoBehavior，拖到Cube上\n并把SetionInfo拖到变量上\n\n\n\nSectionInfo旋转对准摄像头\n\n新建script叫FaceCamera\nAR Camera标签为MainCamera\nscript拖到SectionInfo上\n此时拖动camera，牌子就会跟着动了（不行就删了script然后重新拖进去）\n\n\n\nGaze\n\nCube加标签hasInfo\n\n\n新建script叫Gaze，拖到MainCamera上\n\n测试并没有预期效果？\n而且之前导入的一堆Assets并没有用到？\n重新创建空白项目试试\n\nSecond Try","categories":["Note"],"tags":["ar"]},{"title":"读论文笔记 ANN to Detect Structural Proteins","url":"/2020/11/13/reading-note/","content":"Artificial Neural Networks Trained to Detect Viral and Phage Structural Proteins\n数据来源：GenBank’s non-redun- dant database\n原始数据：\n\n正样本：6000+噬菌体结构蛋白序列\n\n负样本：6000+噬菌体和原核基因组非结构蛋白序列\n\n\n处理后的网络输入：氨基酸百分比组成（人工标记每个样本是/不是结构蛋白）\n目的：有一段新的序列，计算氨基酸百分比组成，输入网络，预测是否为结构蛋白\n网络训练目标：找最佳的网络结构&amp;数据集划分\n备选网络结构：\n\n隐藏层1，1~100个神经元\n隐藏层2，1~30个神经元\n\n备选train/validation set划分：\n\n50:50, 60:40, 70:30, 80:20, 95:5\n\n验证方法：160-fold交叉验证（图3A画的是10-fold交叉验证的结果）\n验证结果：\n\n输入层（20个输入单元）+ 1个隐藏层（90个神经元）+ 输出层（1个输出单元）表现最好，准确率85.6%\n\ntrain/validation set划分80:20表现最好，准确率86.2%\n\n由于没有很大差别，最终选了160个网络，投票决定\n\n\n更多工作关注对结构蛋白亚类的分类结果，如：是否是衣壳结构蛋白\n即输入数据的标记，原来标记是否为结构蛋白，现在标记是否为衣壳结构蛋白，重新训练网络，评估分类准确度\n还做了针对古细菌和真核生物衣壳蛋白的\nIsoelectric point？没看懂\n工具Neural Network Toolbox 7.0 in Matlab version 7.6.0.324\ncomputations and data manipulations were done with Java, UNIX shell utilities, and Perl and Bash scripts\nweb interfacehttps://vdm.sdsu.edu/ivireons/\n测试随便上Genbank找了一个序列https://www.ncbi.nlm.nih.gov/protein/SYW18879.1\n下载FASTA格式\nsequence.fasta:\n&gt;SYW18879.1 putative transcriptional regulator (Immunity repressor; phage) [Oenococcus oeni]MENKPNIAKNIREIRIKEDLTQEKLAELSGLSINFVSRLERSNNQNVSINKLEAIASALKVDIWRLLKSNDSEINKKEFPLHTKILFDKLSEFDPERSDRISKTILSLLEELELKQK\n\n提交测试\n\n\nStructural, MCP, &amp; Tail Protein Network Predictions\nAnnotation\tStructural\tMCP 1:1\tMCP 2:1\tMCP 3:1\tMCP 4:1\tMCP 7:1\tMCP Lambda:1\tMCP Lambda2:1\tTail 1:1\tTail 2:1\tTail 3:1\tTail 4:1\tTail 7:1\tTail Lambda:1\tTail Lambda2:1\tSDS\tSD MCP 1:1\tSD MCP 2:1\tSD MCP 3:1\tSD MCP 4:1\tSD MCP 7:1\tSD MCP Lambda:1\tSD MCP Lambda2:1\tSD Tail 1:1\tSD Tail 2:1\tSD Tail,3:1\tSD Tail 4:1\tSD Tail 7:1\tSD Tail Lambda:1\tSD Tail Lambda2:1\n\nPercent Compositions and Isoelectric Point Estimates (last column)\n0.0427 0.0000 0.0513 0.1197 0.0342 0.0085 0.0085 0.1026 0.1197 0.1453 0.0085 0.0855 0.0256 0.0256 0.0598 0.1026 0.0256 0.0256 0.0085 0.0000 9.07\n\n根据interpret your results的提示…没看懂\n","categories":["Note"],"tags":["bioinformatics"]},{"title":"看源码笔记 DeephageTP","url":"/2020/11/19/code-note/","content":"\nhttps://github.com/chuym726/DeephageTP\n\n环境搭建&amp;数据准备（已有：conda 4.9.2）\n\n下载https://github.com/chuym726/DeephageTP\n\n创建新的虚拟环境deephageTP\n\n\nconda create --name deephageTP python=3.6 numpy theano keras scikit-learn\n\n\n新建工程文件夹DeephageTP-test（需要的文件从下载的DeephageTP-master拷）\n\nPyCharm打开DeephageTP-test，激活环境\n\n\nconda activate deephageTP\n\n\n\nPython Interpreter也改成deephageTP\n\n\n\n\n测试example_data.fa代码里面直接读的training_data.faa，X和Y应该在同一个文件里，\n但是给的training_data.faa.X.npy.tar.gz、training_data.faa.Y.npy.tar.gz是在不同文件\n于是先用example_data.fa试一下（遇到bug #1，解决见Debug）\n(deephageTP) coconutnut@x86_64-apple-darwin13 DeephageTP-test % python DeephageTP_model_training.pyUsing TensorFlow backend.only amino acid code.ok! there is the same number (193) of labels and sequences. 193193193ok! windows is 900.ok! raw data has been saved as a npy file example_data.fa.X/Ynow runing is DL_Train.nb_filters:  50kernel_s:  3n_batch:  10n_echos:  20dropout1:  0.1dropout2:  0.1ok! the npy file example_data.fa.X/Y.npy are loaded!ok! all labels are in 4 kinds.193now training for all, Be noted here no test part !!![[1. 0. 0. 0.] [1. 0. 0. 0.] [1. 0. 0. 0.]...... [0. 0. 0. 1.] [0. 0. 0. 1.] [0. 0. 0. 1.] [0. 0. 0. 1.]]2020-11-19 17:30:03.895070: I tensorflow/core/platform/cpu_feature_guard.cc:145] This TensorFlow binary is optimized with Intel(R) MKL-DNN to use the following CPU instructions in performance critical operations:  SSE4.1 SSE4.2 AVX AVX2 FMATo enable them in non-MKL-DNN operations, rebuild TensorFlow with the appropriate compiler flags.2020-11-19 17:30:03.895316: I tensorflow/core/common_runtime/process_util.cc:115] Creating new thread pool with default inter op setting: 8. Tune using inter_op_parallelism_threads for best performance.Epoch 1/20193/193 [==============================] - 12s 64ms/step - loss: 1.1962 - accuracy: 0.4767Epoch 2/20193/193 [==============================] - 11s 55ms/step - loss: 0.4503 - accuracy: 0.8446Epoch 3/20193/193 [==============================] - 10s 53ms/step - loss: 0.1844 - accuracy: 0.9534Epoch 4/20193/193 [==============================] - 10s 52ms/step - loss: 0.1079 - accuracy: 0.9845Epoch 5/20193/193 [==============================] - 11s 55ms/step - loss: 0.0383 - accuracy: 1.0000Epoch 6/20193/193 [==============================] - 10s 50ms/step - loss: 0.0203 - accuracy: 1.0000Epoch 7/20193/193 [==============================] - 12s 61ms/step - loss: 0.0105 - accuracy: 1.0000Epoch 8/20193/193 [==============================] - 10s 51ms/step - loss: 0.0063 - accuracy: 1.0000Epoch 9/20193/193 [==============================] - 10s 51ms/step - loss: 0.0058 - accuracy: 1.0000Epoch 10/20193/193 [==============================] - 10s 50ms/step - loss: 0.0104 - accuracy: 0.9948Epoch 11/20193/193 [==============================] - 10s 51ms/step - loss: 0.0066 - accuracy: 1.0000Epoch 12/20193/193 [==============================] - 10s 51ms/step - loss: 0.0041 - accuracy: 1.0000Epoch 13/20193/193 [==============================] - 10s 52ms/step - loss: 0.0017 - accuracy: 1.0000Epoch 14/20193/193 [==============================] - 10s 50ms/step - loss: 0.0026 - accuracy: 1.0000Epoch 15/20193/193 [==============================] - 10s 51ms/step - loss: 0.0017 - accuracy: 1.0000Epoch 16/20193/193 [==============================] - 10s 50ms/step - loss: 0.0013 - accuracy: 1.0000Epoch 17/20193/193 [==============================] - 10s 52ms/step - loss: 0.0011 - accuracy: 1.0000Epoch 18/20193/193 [==============================] - 9s 48ms/step - loss: 8.4943e-04 - accuracy: 1.0000Epoch 19/20193/193 [==============================] - 9s 49ms/step - loss: 8.9927e-04 - accuracy: 1.0000Epoch 20/20193/193 [==============================] - 9s 49ms/step - loss: 0.0011 - accuracy: 1.0000the model (example_data.fa.all.h5) has saved!\n\n产生了3个文件\nexample_data.fa.all.h5\nexample_data.fa.X.npy\nexample_data.fa.Y.npy\n所以给的training_data.faa.X.npy.tar.gz、training_data.faa.Y.npy.tar.gz也是生成的吗？data文件夹里就一个叫a的空文件，难道是没传training_data.faa？😧\n看了下代码，还真是🙄\naa_ref2npy()用来转格式，存成one-hot编码后，X和Y分开的形式\nDL_Train()用来训练\n既然如此，直接用training_data.faa.X.npy.tar.gz、training_data.faa.Y.npy.tar.gz解压，不跑aa_ref2npy()，就可以直接训练了\n测试training_data.faa解压training_data.faa.X.npy.tar.gz、training_data.faa.Y.npy.tar.gz\n（25.3MB解压后3.97 GB，是得有多少0啊，不愧是one-hot）\n代码改了2处：\n第8行\nfrom sklearn.cross_validation import train_test_split\n\n改成\nfrom sklearn.model_selection import train_test_split\n\n最后的\nif 1:\taa_ref2npy(ref_Data=ref_Data,len_w=len_w)\n\n注释掉\n运行\n(deephageTP) coconutnut@x86_64-apple-darwin13 DeephageTP-test % python DeephageTP_model_training.pyUsing TensorFlow backend.only amino acid code.now runing is DL_Train.nb_filters:  50kernel_s:  3n_batch:  10n_echos:  20dropout1:  0.1dropout2:  0.1ok! the npy file training_data.faa.X/Y.npy are loaded!ok! all labels are in 4 kinds.27585now training for all, Be noted here no test part !!![[1. 0. 0. 0.] [1. 0. 0. 0.] [1. 0. 0. 0.] ... [0. 0. 0. 1.] [0. 0. 0. 1.] [0. 0. 0. 1.]]2020-11-19 17:52:30.350217: I tensorflow/core/platform/cpu_feature_guard.cc:145] This TensorFlow binary is optimized with Intel(R) MKL-DNN to use the following CPU instructions in performance critical operations:  SSE4.1 SSE4.2 AVX AVX2 FMATo enable them in non-MKL-DNN operations, rebuild TensorFlow with the appropriate compiler flags.2020-11-19 17:52:30.350529: I tensorflow/core/common_runtime/process_util.cc:115] Creating new thread pool with default inter op setting: 8. Tune using inter_op_parallelism_threads for best performance.Epoch 1/20 1250/27585 [&gt;.............................] - ETA: 22:33 - loss: 0.5788 - accuracy: 0.8016\n\n太大了，不跑了\n代码分析训练部分 DeephageTP_model_training.py\naa_ref2npy()做one-hot编码用的\n把蛋白质序列↓\n&gt;UniRef100_A0A017QK57 PBSX family phage terminase large subunit n=1 Tax=Glaesserella parasuis str. Nagasaki TaxID=1117322 RepID=A0A017QK57_HAEPR 1MKIQLNLPPKLIPVFTQQNVRYRGAYGGRGSAKTRTFAKMTAVVAYQRAMQGESGVILCGREFMNSLEDSSLEEIKQAIQSEPWLTDFFEVGEKYVRTKCGRISYIFTGLRHNLDSIKSKARILLAWIDEAESVSEMAWRKLLPTVRENGSEIWLTWNPEKKGSATDLRFRQHQDESMAIVEMNYSDNPWFPDVLEQERLRDKARLDDATYRWIWEGAYLEQSEAQIFRDKFQELEFKPNGDFSGPYFGLDFGFAQDPTAAVKCWVFKDELYIEYEAGKVGLELDDTATFLQKGIVGIEQYVIRADSARPESISYLKRHGLPRIDGVSKWKGSVEDGIAHIKSYKKIYIHPRCQQTLNEFRLYSYKTDRLSGDILPVVLDENNHYIDALRYALEPLMKGRQSWFG\n\none-hot编码，np.array格式，保存（分别存X和Y）\n把X打出来看下\n[[0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],  对应M [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],  对应K [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],  对应I [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], ...\n\n就是和蛋白质序列MKI…一一对应的one-hot编码（还是手动写死的）\n大小是(900, 20)，和文中描述一样\n这里Y是0，根据每个蛋白质第一行\n&gt;UniRef100_A0A017QK57 PBSX family phage terminase large subunit n=1 Tax=Glaesserella parasuis str. Nagasaki TaxID=1117322 RepID=A0A017QK57_HAEPR 1\n\n最后这个数字-1表示类别\n如下面这个蛋白的类别是2\n&gt;UniRef100_A0A072NPV4 Phage terminase, small subunit n=1 Tax=Bacillus azotoformans MEV2011 TaxID=1348973 RepID=A0A072NPV4_BACAZ 3MAKDGTNRGGARVGAGAKKKPLTDKIAEGNPGGRKLTVMEFKDTADLKGLEMPEPNKMLEAIQKDGKALVAGEIYRNTWAWLNERGCAALVSPQLLERYAMSVARWIQCEEAVTEYGFLAKHPTTGNAIQSPYVAMGQNYMNQTNRLWMEIFQIVKENCTGEYSGINPQDDVMERLLTARRGK\n\nDL_Train()def DL_Train(ref_Data, len_w):\t# 参数设置\tnb_filters = 50\tkernel_s = 3\tn_batch = 10\tn_echos = 20\tdropout1 = 0.10\tdropout2 = 0.10\tprint (&quot;now runing is DL_Train.&quot;)\t\t# end_lossrint(&quot;all is ended.&quot;)\tprint (&quot;nb_filters: &quot;, nb_filters)\tprint (&quot;kernel_s: &quot;, kernel_s)\tprint (&quot;n_batch: &quot;, n_batch)\tprint (&quot;n_echos: &quot;, n_echos)\tprint (&quot;dropout1: &quot;, dropout1)\tprint (&quot;dropout2: &quot;, dropout2)\t\t# 处理数据\tX2 = np.load(ref_Data + &quot;.X.npy&quot;)\tY2 = np.load(ref_Data + &quot;.Y.npy&quot;)\tprint (&quot;ok! the npy file &quot; + ref_Data + &quot;.X/Y.npy are loaded!&quot; )\tn_classes = 4    #len(np.unique(Y))\tprint (&quot;ok! all labels are in &quot; + str(n_classes) + &quot; kinds.&quot; )\tYY_t = []\tfor i in Y2:\t\tll = np.zeros(n_classes)\t\tll[i] = 1\t\tYY_t.append(ll)\tYY_t = np.array(YY_t)\tprint(len(YY_t))\tprint(&quot;now training for all, Be noted here no test part !!!&quot;)\tX_train = X2.reshape(-1,1,len_w,matrix_size)\tY_train = YY_t\tprint(Y_train)\t\t# 构建模型\tmodel = Sequential()\tmodel.add(Conv2D(filters=nb_filters,kernel_size=(7,1),padding=&#x27;same&#x27;,input_shape=(1,len_w,matrix_size),data_format=&#x27;channels_first&#x27;))\tmodel.add(Activation(&#x27;relu&#x27;))\tmodel.add(MaxPooling2D(pool_size=(3,3)))\tmodel.add(Dropout(dropout1))\tmodel.add(Flatten())\tmodel.add(Dense(100,activation=&#x27;relu&#x27;))\tmodel.add(Dropout(dropout2))\tmodel.add(Dense(n_classes,activation=&#x27;softmax&#x27;))\tmodel.compile(loss=&#x27;categorical_crossentropy&#x27;,optimizer=Adam(),metrics=[&#x27;accuracy&#x27;])   \t\t# 训练模型\tmodel.fit(X_train,Y_train,batch_size=n_batch,epochs=n_echos,verbose=1)\t\t# 保存模型\tmodel.save(ref_Data + &#x27;.all.h5&#x27;)\tprint(&quot;the model (&quot; + ref_Data + &quot;.all.h5) has saved!&quot;)\n\nDebug#1第一次跑DeephageTP_model_training.py时遇到的bug\nModuleNotFoundError: No module named &#x27;sklearn.cross_validation&#x27;\n\n解决：\nhttps://blog.csdn.net/qq_35962520/article/details/85295228\n# from sklearn.cross_validation import train_test_split # cross_validation不再使用，移至model_selectionfrom sklearn.model_selection import train_test_split\n\n","categories":["Note"],"tags":["bioinformatics"]},{"title":"读论文笔记 DeephageTP","url":"/2020/11/19/paper-note/","content":"DeephageTP: A Convolutional Neural Network Framework for Identifying Phage-specific Proteins from metagenomic sequencing data Running title: an alignment-free deep learning framework for identifying phage- specific proteins\n参考：原文 &amp; Github https://github.com/chuym726/DeephageTP\n\n目标3 specific proteins of the tailed phage:\n\nPortal (portal protein)\nTerL (large terminase subunit protein) \nTerS (small terminase subunit protein)\n\nDevelop a CNN-based framework to identify these 3 proteins from metagenome data\n数据集train/test set(原文位置：106-127行)\n来源：Uniport(www.uniprot.org)\n预处理过程：\n\n从数据库中获取各类蛋白质序列\n\naccording to the taxonomy in the UniProt database, all proteins in archaea, bacteria and viruses were obtained from the database;\n\n看example_data.fa文件，长这样：\n&gt;UniRef100_A0A017QK57 PBSX family phage terminase large subunit n=1 Tax=Glaesserella parasuis str. Nagasaki TaxID=1117322 RepID=A0A017QK57_HAEPR 1MKIQLNLPPKLIPVFTQQNVRYRGAYGGRGSAKTRTFAKMTAVVAYQRAMQGESGVILCGREFMNSLEDSSLEEIKQAIQSEPWLTDFFEVGEKYVRTKCGRISYIFTGLRHNLDSIKSKARILLAWIDEAESVSEMAWRKLLPTVRENGSEIWLTWNPEKKGSATDLRFRQHQDESMAIVEMNYSDNPWFPDVLEQERLRDKARLDDATYRWIWEGAYLEQSEAQIFRDKFQELEFKPNGDFSGPYFGLDFGFAQDPTAAVKCWVFKDELYIEYEAGKVGLELDDTATFLQKGIVGIEQYVIRADSARPESISYLKRHGLPRIDGVSKWKGSVEDGIAHIKSYKKIYIHPRCQQTLNEFRLYSYKTDRLSGDILPVVLDENNHYIDALRYALEPLMKGRQSWFG&gt;UniRef100_A0A017QKX8 PBSX family phage terminase large subunit n=1 Tax=Glaesserella parasuis str. Nagasaki TaxID=1117322 RepID=A0A017QKX8_HAEPR 1MKIQLNLPPKLIPVFTQQNVRYRGAYGGRGSAKTRTFAKMTAVVAYQRAMQGESGVILCGREFMNSLEDSSLEEIKQAIQSEPWLANFFDVGEKYVHTKCGRISYIFTGLRHNLDSIKSKARILLAWIDEAESVSEMAWRKLLPTVRESGSEIWLTWNPEKKGSATDLRFRQYQDESMAIVEMNYNDNPWFPDVLKQERLRDKARLDDATYRWIWEGDYLEESEAQVFRGKYQELEFKPLPDFEGPYHGLDFGFAQDPTAAIKCWVFKDELYIEYEAGKVGLELDDTATFLQKGIVGIEQYVIRADSARPESISYLKRHGLPRIDGVSKWKGSVEDGIAHIKSYKKIYIHPRCQQTLNEFRLYSYKTDRLSGDVLPTLVDAHNHYIDALRYALNPRIQRKGDFSQNPLKLY...\n\n去除无关数据\n\nthe protein sequences were searched by the keywords (i.e., portal, large terminase subunit, and small terminase subunit), and the noise sequences with the uncertain keywords (e.g., hypothetical, possible, like, predicted) were removed to ensure that the selected protein sequences in the three categories are veracious;\n\n\n其它类过多，随机留一部分\n\n\u0011the remaining sequences without the keywords of interest (portal, large terminase subunit and, small terminase subunit) were labeled as the ‘others’ category. However, the size of the ‘others’ category is more than 75 times larger than that of the three categories. To relieve the class-imbalance problem brought by this situation, we randomly selected 20000 protein sequences  from the remaining sequences and labeled as the ‘others’ category;\n\n\n去除不正常长度的序列\n\nto further guarantee that the sequences from the database with the three categories are veracious, we calculated length distribution of these sequences (see Fig. S1), then manually checked the sequences with the abnormal length (&lt;5% and &gt; 95%) using Blastp (https://blast.ncbi.nlm.nih.gov/Blast.cgi) against NCBI nr database, and the sequences without hitting to the targeted references were filtered out (almost all the sequences with abnormal length) and labeled as the ‘others’ category.\n\n\n\n最终结果：\n\n\nmimic metagenomic dataset(原文位置：128-140行)\n来源：UniRef100 (https://www.uniprot.org/uniref/)\n处理过程和上面类似\n且：2个数据库有重合，手动删除重合部分\n用这组数据测试了模型在不同数据集大小上的表现效果\nvirome dataset(原文位置：141-147行)\n用于测试模型在真实数据集上的结果\n这组是原始数据，自行获取蛋白质序列\n3个数据集的用途(原文位置：193-197行 + Fig.1A)\n\n用train/test set训练模型，分析可行性\n用mimic dataset测试cutoff value\n用virome dataset测试真实效果\n\n\nIn summary, as shown in Fig. 1A, in this study, the proposed DeephageTP framework was firstly implemented on the training dataset for feasibility analysis, and then the trained model was applied on the mimic dataset for test and the cutoff value of each category of interest was determined according to the responding loss values distributions; finally, we applied the trained model on the real metagenomic datasets for examining the performance of our framework.\n\n\n\n蛋白质序列编码(原文位置：148-161行)\n方法：one-hot\n对20个氨基酸进行one-hot编码，1个氨基酸占20位\n\n\nL个氨基酸的蛋白质序列将被编码成 L * 20 的矩阵\n输入需要固定，故设置最大长度为900，多了砍掉，少了填0\n最终每个蛋白质序列都被编码成 900 * 20 的矩阵，作为输入\n模型结构(原文位置：163-170行)\n\n输入层 (ReLu)\n\n卷积层\n\n最大池化层 (dropout)\n\n全连接层1 (ReLu) (dropout)\n\n全连接层2\n\n输出层 (SoftMax)\n\n\n\n\n超参数选择(原文位置：171-189行)\n全连接单元数量、dropout rate、learning rate等的取值，大部分是常用的默认值；一些用5-fold cross-validation确定\n20个氨基酸分成7组（根据dipole moments &amp; side-chain）： {A,G,V}, {I,L,F,P}, {Y,M,T,S}, {H,N,Q,W}, {R,K}, {D,E} and {C} -&gt; 卷积层filter大小设置为 7 * 1\n模型评估指标(原文位置：198-213行)\n\nAccuracy\nPrecision\nRecall\nF1-score\n\nLoss计算(原文位置：214-234行)\n\n\nyk 第k维的序列的真实标签\npk 第k维的序列的预测标签\n实现(原文位置：190-192行)\nPython 3.6\nKeras\nhttps://github.com/chuym726/DeephageTP\n没看懂的\ncutoff value是做什么的？怎么算的？\nloss怎么算的？\n\n","categories":["Note"],"tags":["bioinformatics"]},{"title":"Unity笔记 Project01 Basic","url":"/2020/11/30/note-unity/","content":"\nhttps://www.youtube.com/watch?v=pwZpJzpE2lQ&amp;t=4178s&amp;ab_channel=Imphenzia\n\n\n\n实现\n人物跳跃，左右移动\n\n跳跃速度与重量无关 -&gt; ForceMode.VelocityChange\n\n跳跃时保持左右速度 -&gt; rigidbodyComponent.velocity\n\n不可在空中跳跃 -&gt; 检查Physics.OverlapSphere()\n\n左右移动同时检查←→AD -&gt; Input.GetAxis(“Horizontal”)\n\n碰到墙壁不会因为长按D贴在墙上 -&gt; 添加物理材质，摩擦力为0\n\n\n\n摄像头跟随角色 -&gt; 层级放在角色下即可\n\n收集硬币\n\n不发生碰撞 -&gt; 勾选是触发器\n检测碰撞 -&gt; OnTriggerEnter()\n碰到后消除 -&gt; Destroy(other.gameObject);\n\n\n\n注意\n在Update()中获取输入，在FixedUpdate()中apply physics\n用[SerializeField] private，不要用public\n减少不必要的Collider，提高效率\n多用Prefab，善用Layer\n\n代码using System.Collections;using System.Collections.Generic;using UnityEngine;public class Player : MonoBehaviour&#123;    [SerializeField] private Transform groundCheckTransform = null;    [SerializeField] private LayerMask playerMask;    private bool jumpKeyPressed;    private float horizontalInput;    private Rigidbody rigidbodyComponent;    // Start is called before the first frame update    void Start() &#123;        rigidbodyComponent = GetComponent&lt;Rigidbody&gt;();    &#125;    // Update is called once per frame    void Update() &#123;        horizontalInput = Input.GetAxis(&quot;Horizontal&quot;);        // Avoid jumping in the air (always colliding with the capsule collider)        if(Physics.OverlapSphere(groundCheckTransform.position, 0.1f, playerMask).Length == 0)&#123;            return;        &#125;        if(Input.GetKeyDown(KeyCode.Space))&#123;            jumpKeyPressed = true;        &#125;    &#125;        // FixedUpdate is called once every physic update (Default 100/s)    private void FixedUpdate() &#123;        if(jumpKeyPressed)&#123;            rigidbodyComponent.AddForce(Vector3.up * 5,ForceMode.VelocityChange);            jumpKeyPressed = false;        &#125;        rigidbodyComponent.velocity = new Vector3(horizontalInput * 2, rigidbodyComponent.velocity.y, 0);    &#125;    private void OnTriggerEnter(Collider other) &#123;        // Collide with 9.Coin layer        if(other.gameObject.layer == 9)&#123;            Destroy(other.gameObject);        &#125;    &#125;&#125;","categories":["Note"],"tags":["unity"]},{"title":"Unity笔记 Project03 第一人称移动","url":"/2020/12/02/unity-note-1/","content":"\nhttps://www.youtube.com/watch?v=_QajrabyTJc&amp;ab_channel=Brackeys\n\n\n\n层级\nPlayer（空物体）-&gt; 加Character Controller；PlayerMovement（Script）\nBody（圆柱）-&gt; 删除Collider\nMain Camera -&gt; 放在人物头部的位置；MouseLook（Script）\n\n\n\n旋转x轴横向旋转，转动Player和Camera\ny轴纵向旋转，只转动Camera\n移动使用Character Controller的方法\n重力Character Controller不能使用Rigidbody🤪，只能代码解决\n还需要通过GroundCheck和Layer来解决碰到地面时下落速度清零的问题\nTips\nUpdate()中Time.deltaTime获取从上次调用Update()至今的时间\n\n控制爬楼梯跨度&amp;斜坡角度 -&gt; Character Controller中设置\n\n\n\n\n看教程里的总结，用Character Controller和用RigidBody来控制确实挺不一样的，后面得看看用哪个更合适\n代码using System.Collections;using System.Collections.Generic;using UnityEngine;public class MouseLook : MonoBehaviour&#123;    public float mouseSensitivity = 100f;    // 在Unity中把Player拖过来    public Transform playerBody = null;    private float xRotation = 0f;    // Start is called before the first frame update    void Start()    &#123;            &#125;    // Update is called once per frame    void Update()    &#123;        // Get Input        float mouseX = Input.GetAxis(&quot;Mouse X&quot;) * mouseSensitivity * Time.deltaTime;        float mouseY = Input.GetAxis(&quot;Mouse Y&quot;) * mouseSensitivity * Time.deltaTime;        // 纵向旋转Camera        xRotation -= mouseY;        // 不直接用Rotate，因为要先限制旋转角度        xRotation = Mathf.Clamp(xRotation, -30f, 30f);        transform.localRotation = Quaternion.Euler(xRotation, 0f, 0f);        // 横向旋转Player        playerBody.Rotate(Vector3.up * mouseX);        Debug.Log(mouseX);        Debug.Log(&quot;R:&quot;+playerBody.transform.rotation);        Debug.Log(&quot;LR:&quot;+playerBody.transform.localRotation);    &#125;&#125;\n\nusing System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerMovement : MonoBehaviour&#123;    public CharacterController controller;    public float speed = 12f;    public float gravity = -9.81f;    public float jumpHeight = 3f;    public Transform groundCheck;    public float groundDistance = 0.4f;    public LayerMask groundMask;    Vector3 velocity;    bool isGrounded;    // Update is called once per frame    void Update()    &#123;        // 防止向下的速度无限增大        isGrounded = Physics.CheckSphere(groundCheck.position, groundDistance, groundMask);        if(isGrounded &amp;&amp; velocity.y &lt; 0)&#123;            velocity.y = -2f;        &#125;        // 移动        float x = Input.GetAxis(&quot;Horizontal&quot;);        float z = Input.GetAxis(&quot;Vertical&quot;);        // 这样写是全局坐标，不管Player面对什么方向        // Vector3 move = new Vector3(x, 0f, z);        Vector3 move = transform.right * x + transform.forward * z;        controller.Move(move * speed * Time.deltaTime);        // 跳跃        if(Input.GetButtonDown(&quot;Jump&quot;) &amp;&amp; isGrounded)&#123;            velocity.y = Mathf.Sqrt(jumpHeight * -2f * gravity);        &#125;        // 模拟重力        velocity.y += gravity * Time.deltaTime;        controller.Move(velocity * Time.deltaTime);    &#125;&#125;\n\n","categories":["Note"],"tags":["unity"]},{"title":"Unity笔记 Project04 点击移动+旋转摄像头","url":"/2020/12/02/unity-note-2/","content":"想做成点击移动，并且摄像头可以根据鼠标位置有限制的旋转\nStep 1 - 点击移动参照Project02\n\n\n完成~\n\n\nusing System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.AI;public class PlayerMovement : MonoBehaviour&#123;    public NavMeshAgent agent;    // Start is called before the first frame update    void Start()    &#123;        agent = GetComponent&lt;NavMeshAgent&gt;();    &#125;    // Update is called once per frame    void Update()    &#123;        // Click to Move        if(Input.GetMouseButtonDown(0))&#123;            RaycastHit hit;            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);            if(Physics.Raycast(ray, out hit, Mathf.Infinity))&#123;                agent.SetDestination(hit.point);            &#125;        &#125;    &#125;&#125;\n\nStep 2 - 旋转摄像头参照Project03\n\n\n鼠标转向不是很方便，顺便加了方向键旋转\nusing System.Collections;using System.Collections.Generic;using UnityEngine;public class CameraLook : MonoBehaviour&#123;    public float mouseSensitivity = 100f;    public float keySensitivity = 100f;    public Transform player = null;    private float xRotation = 0f;    // Start is called before the first frame update    void Start()    &#123;            &#125;    // Update is called once per frame    void Update()    &#123;        // Get mouse position        float mouseX = Input.GetAxis(&quot;Mouse X&quot;) * mouseSensitivity * Time.deltaTime;        float mouseY = Input.GetAxis(&quot;Mouse Y&quot;) * mouseSensitivity * Time.deltaTime;        // Get key inout        float keyX = Input.GetAxis(&quot;Horizontal&quot;) * keySensitivity * Time.deltaTime;        Debug.Log(mouseX);        Debug.Log(keyX);        // Rotate camera up and down        xRotation -= mouseY;        xRotation = Mathf.Clamp(xRotation, -30f, 30f);        transform.localRotation = Quaternion.Euler(xRotation, 0f, 0f);        // Rotate player left and right        player.Rotate(Vector3.up * (mouseX + keyX));    &#125;&#125;\n\n\n耶(＾－＾)V\n目前这个移动方式很满意，暂时就这样\n下一步可以搭场景啦~\n","categories":["Note"],"tags":["unity"]},{"title":"Unity笔记 Project05 地形&Asset","url":"/2020/12/02/unity-note-3/","content":"\nhttps://www.youtube.com/watch?v=ddy12WHqt-M&amp;ab_channel=UGuruz\n\n试了试地形\n\n\n加入人物，按Project04的方式移动\n\n\n找了一组模型，能用！\n\n\n感觉要起飞了🤩\n","categories":["Note"],"tags":["unity"]},{"title":"Unity笔记 Project02 点击移动","url":"/2020/12/02/unity-note/","content":"\nClick To Move with NavMesh - Unity 3D\n\n选中地面\n窗口 → AI → 导航: Static &amp; Walkable\n\n\n烘焙 → Bake\n\n\nPlayer加组件Nav Mesh Agent\nusing System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.AI;public class Player : MonoBehaviour&#123;    NavMeshAgent agent;    // Start is called before the first frame update    void Start()    &#123;        agent = GetComponent&lt;NavMeshAgent&gt;();    &#125;    // Update is called once per frame    void Update()    &#123;        if(Input.GetMouseButtonDown(0))&#123;            RaycastHit hit;            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);            if(Physics.Raycast(ray, out hit, Mathf.Infinity))&#123;                agent.SetDestination(hit.point);            &#125;        &#125;    &#125;&#125;","categories":["Note"],"tags":["unity"]},{"title":"Notion Offline记录","url":"/2021/02/12/notionn/","content":"Notion的app突然Offline了\n直接访问显示DNS_PROBE_FINISHED_NXDOMAIN\n根据↓尝试\n\nhttps://linmi.cc/6133.html\n\n1.加hostcmd中 open /etchost中加一行 104.18.23.110 notion.so此时可以ping通notion.so，但app仍是offline\n2.改DNS加119.29.29.29114.114.114.114没有用，改回默认\n暂时还是不能用，等修复吧哎，失去notion仿佛失去了半个脑子\n更新：然后发现github.io也访问不了了，是运营商的问题DNS改成114.114.114.114后解决\n再更新：notion好了！我活了！\n","categories":["Memo"],"tags":["tool"]},{"title":"Unity Note - Project06 DoTween","url":"/2021/02/14/unity-note/","content":"\nCreating Dynamic animations with DOTween for Unity3d\n\n\nDoTween Documentation\n\n\nAdd asset DOTween (HOTween v2)\n\nAdd 3D Objects\n\n\n\n\n\nMove one way\n\nusing System.Collections;using System.Collections.Generic;using UnityEngine;using DG.Tweening;public class DoTweenController : MonoBehaviour&#123;    [SerializeField]    private Vector3 targetLocation = Vector3.zero;    [SerializeField, Range(1.0f, 10.0f)]    private float moveDuration = 1.0f;    [SerializeField]    private Ease moveEase = Ease.Linear;    [SerializeField]    private DoTweenType doTweenType = DoTweenType.MovementOneWay;    // Different types of animation    private enum DoTweenType    &#123;        MovementOneWay    &#125;    // Start is called before the first frame update    void Start()    &#123;        if(doTweenType == DoTweenType.MovementOneWay)&#123;            if(targetLocation == Vector3.zero)&#123;                // stay at original position                targetLocation = transform.position;            &#125;            transform.DOMove(targetLocation, moveDuration).SetEase(moveEase);        &#125;    &#125;&#125;\n\n\n\n\nMore types\n\nusing System.Collections;using System.Collections.Generic;using UnityEngine;using DG.Tweening;public class DoTweenController : MonoBehaviour&#123;    [SerializeField]    private Vector3 targetLocation = Vector3.zero;    [SerializeField, Range(1.0f, 10.0f)]    private float moveDuration = 1.0f;    [SerializeField]    private Ease moveEase = Ease.Linear;    [SerializeField]    private Color targetColor;    [SerializeField, Range(1.0f, 10.0f)]    private float colorChangeDuration = 1.0f;    [SerializeField, Range(0.1f, 10.0f)]    private float scaleMultiplier = 3.0f;    [SerializeField]    private DoTweenType doTweenType = DoTweenType.MovementOneWay;    // Different types of animation    private enum DoTweenType    &#123;        MovementOneWay,        MovementTwoWay,        MovementOneWayColorChange,        MomementOneWayColorChangeScaleChange    &#125;    // Start is called before the first frame update    void Start()    &#123;        if(targetLocation == Vector3.zero)&#123;                // stay at original position                targetLocation = transform.position;            &#125;        if(doTweenType == DoTweenType.MovementOneWay)&#123;            transform.DOMove(targetLocation, moveDuration).SetEase(moveEase);        &#125;        else if(doTweenType == DoTweenType.MovementTwoWay)&#123;            StartCoroutine(MoveWithBothWays());        &#125;        else if(doTweenType == DoTweenType.MovementOneWayColorChange)&#123;            // another way            DOTween.Sequence()                .Append(transform.DOMove(targetLocation, moveDuration).SetEase(moveEase))                .Append(transform.GetComponent&lt;Renderer&gt;().material.DOColor(targetColor, colorChangeDuration).SetEase(moveEase));        &#125;        else if(doTweenType == DoTweenType.MomementOneWayColorChangeScaleChange)&#123;            DOTween.Sequence()                .Append(transform.DOMove(targetLocation, moveDuration).SetEase(moveEase))                .Append(transform.GetComponent&lt;Renderer&gt;().material.DOColor(targetColor, colorChangeDuration).SetEase(moveEase))                .Append(transform.DOScale(scaleMultiplier, moveDuration).SetEase(moveEase));        &#125;    &#125;    private IEnumerator MoveWithBothWays()&#123;        // save original position        Vector3 originalLocation = transform.position;        // go to traget location        transform.DOMove(targetLocation, moveDuration).SetEase(moveEase);        // wait        yield return new WaitForSeconds(moveDuration);        // go to original location        transform.DOMove(originalLocation, moveDuration).SetEase(moveEase);    &#125;&#125;\n\n","categories":["Note"],"tags":["unity"]},{"title":"Unity Note - Project07 Scroll","url":"/2021/02/14/unity/","content":"Test open animationusing System.Collections;using System.Collections.Generic;using UnityEngine;using DG.Tweening;public class ReelController : MonoBehaviour&#123;    [SerializeField]    private float radius = 0.1f; // Cylinder radius    [SerializeField]    private float length = 8.0f; // Quad length    [SerializeField]    private float innerHeight = 1.0f; // Quad height    [SerializeField]    private float outerHeight = 0.8f; // Cylinder height    [SerializeField]    private float openDuration = 1.0f;    [SerializeField]    private Ease moveEase = Ease.Linear;    [SerializeField]    private Transform leftCylinderTransform = null;    [SerializeField]    private Transform middleQuadTransform = null;    [SerializeField]    private Transform rightCylinderTransform = null;    void Start()    &#123;        // set original position        middleQuadTransform.localScale = new Vector3(radius*2,innerHeight,0);        middleQuadTransform.position = new Vector3(0,0,radius);        leftCylinderTransform.localScale = new Vector3(radius*2,outerHeight,radius*2);        leftCylinderTransform.position = new Vector3(-radius,0,0);        rightCylinderTransform.localScale = new Vector3(radius*2,outerHeight,radius*2);        rightCylinderTransform.position = new Vector3(radius,0,0);        OpenReel();    &#125;    void OpenReel()    &#123;        // open canvas        middleQuadTransform.DOScaleX(length + radius*2, openDuration).SetEase(moveEase);        // move cylinders        leftCylinderTransform.DOMoveX(leftCylinderTransform.position.x - length/2, openDuration).SetEase(moveEase);        rightCylinderTransform.DOMoveX(rightCylinderTransform.position.x + length/2, openDuration).SetEase(moveEase);    &#125;&#125;\n\n\n\nDisplay imageDrag images to asset folder -&gt; Set type to Sprite -&gt; Apply\nCanvas -&gt; Set Render Mode to World Space\nMake sure all objects are positioned at (0, 0, 0)\n\n\nTest size\nRectTransform rectTransfrom = GetComponentInChildren&lt;Image&gt;().GetComponent&lt;RectTransform&gt;();Debug.Log(&quot;rectTransfrom: &quot;+rectTransfrom);Debug.Log(&quot;rectTransfrom.rect: &quot;+rectTransfrom.rect);Debug.Log(&quot;rectTransfrom.sizeDelta: &quot;+rectTransfrom.sizeDelta);Rect rect = rectTransfrom.rect;rectTransfrom.sizeDelta = new Vector2(rect.width/rect.height*canvasHeight,canvasHeight);Debug.Log(&quot;rectTransfrom: &quot;+rectTransfrom);Debug.Log(&quot;rectTransfrom.rect: &quot;+rectTransfrom.rect);Debug.Log(&quot;rectTransfrom.sizeDelta: &quot;+rectTransfrom.sizeDelta);\n\n\n\nSet scroll sizeusing System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;using DG.Tweening;public class ReelController : MonoBehaviour&#123;    [SerializeField]    private float canvasHeight = 1000;    [SerializeField]    private float cylinderHeight = 600;    [SerializeField]    private float cylinderRadius = 30;    [SerializeField]    private float openDuration = 1.0f;    [SerializeField]    private Ease moveEase = Ease.Linear;    [SerializeField]    private Transform leftCylinderTransform = null;    [SerializeField]    private Transform rightCylinderTransform = null;    void Start()    &#123;        // get image rectTransfrom        RectTransform rectTransfrom = GetComponentInChildren&lt;Image&gt;().GetComponent&lt;RectTransform&gt;();        // get original image size        Rect rect = rectTransfrom.rect;        // scale to default height        float canvasWidth = rect.width / rect.height * canvasHeight;        rectTransfrom.sizeDelta = new Vector2(canvasWidth, canvasHeight);        // set original position        leftCylinderTransform.localScale = new Vector3(cylinderRadius*2, cylinderHeight, cylinderRadius*2);        leftCylinderTransform.position = new Vector3(-cylinderRadius - canvasWidth/2,0,0);        rightCylinderTransform.localScale = new Vector3(cylinderRadius*2, cylinderHeight, cylinderRadius*2);        rightCylinderTransform.position = new Vector3(cylinderRadius + canvasWidth/2,0,0);    &#125;&#125;\n\n\n\nScroll animationusing System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;using DG.Tweening;public class ScrollController : MonoBehaviour&#123;    [SerializeField]    private float canvasHeight = 1000;    [SerializeField]    private float cylinderHeight = 600;    [SerializeField]    private float cylinderRadius = 30;    [SerializeField]    private float openDuration = 1.0f;    [SerializeField]    private Ease moveEase = Ease.Linear;    [SerializeField]    private Transform leftCylinderTransform = null;    [SerializeField]    private Transform rightCylinderTransform = null;    void Start()    &#123;        // Open();        OpenAnimation();    &#125;    private void Open()    &#123;        // get image rectTransfrom        RectTransform rectTransfrom = GetComponentInChildren&lt;Image&gt;().GetComponent&lt;RectTransform&gt;();        // get original image size        Rect rect = rectTransfrom.rect;        // scale to default height        float canvasWidth = rect.width / rect.height * canvasHeight;        rectTransfrom.sizeDelta = new Vector2(canvasWidth, canvasHeight);        // set original position        leftCylinderTransform.localScale = new Vector3(cylinderRadius*2, cylinderHeight, cylinderRadius*2);        leftCylinderTransform.position = new Vector3(-cylinderRadius - canvasWidth/2,0,0);        rightCylinderTransform.localScale = new Vector3(cylinderRadius*2, cylinderHeight, cylinderRadius*2);        rightCylinderTransform.position = new Vector3(cylinderRadius + canvasWidth/2,0,0);        Debug.Log(&quot;Scroll opened: &quot; + rectTransfrom.rect);    &#125;    void OpenAnimation()    &#123;        // get image rectTransfrom        RectTransform rectTransfrom = GetComponentInChildren&lt;Image&gt;().GetComponent&lt;RectTransform&gt;();        // get original image size        Rect rect = rectTransfrom.rect;        // set width to 0        rectTransfrom.DOScaleX(0, 0).SetEase(moveEase);        // scale to default height        float canvasWidth = rect.width / rect.height * canvasHeight;        // open canvas        float scaleX = canvasWidth/rect.width;        float scaleY = canvasHeight/rect.height;        rectTransfrom.DOScale(new Vector2(scaleX, scaleY), openDuration).SetEase(moveEase);        // move cylinders        leftCylinderTransform.localScale = new Vector3(cylinderRadius*2, cylinderHeight, cylinderRadius*2);        leftCylinderTransform.DOMoveX(leftCylinderTransform.position.x - canvasWidth/2, openDuration).SetEase(moveEase);        rightCylinderTransform.localScale = new Vector3(cylinderRadius*2, cylinderHeight, cylinderRadius*2);        rightCylinderTransform.DOMoveX(rightCylinderTransform.position.x + canvasWidth/2, openDuration).SetEase(moveEase);        Debug.Log(&quot;Scroll opened with animation: &quot; + rectTransfrom.rect);    &#125;&#125;\n\n","categories":["Note"],"tags":["unity"]},{"title":"Unity Note - Project09 Movement","url":"/2021/02/15/unity-09/","content":"最终想要做的移动方式：\n\n点击地面导航\n拖拽旋转\n缩放平移\n点击画导航\n\n交互方式参考：\n\nhttps://sketchfab.com/3d-models/richards-art-gallery-audio-tour-0e3e19faa6474fd5974e6a7ed1b221d8\n\n搭建点击移动参考Project02，AI导航+NavMeshAgent\nif(Input.GetMouseButtonDown(0))&#123;  RaycastHit hit;  Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);  if(Physics.Raycast(ray, out hit, Mathf.Infinity))&#123;    agent.SetDestination(hit.point);  &#125;&#125;\n\n判断落点，只有是地面才移动（地面打Tag）\nif(Input.GetMouseButtonDown(0))&#123;\tRaycastHit hit;\tRay ray = Camera.main.ScreenPointToRay(Input.mousePosition);\tif(Physics.Raycast(ray, out hit, Mathf.Infinity))&#123;\t\tif(hit.transform.tag == &quot;Floor&quot;)&#123;\t\t\tagent.SetDestination(hit.point);\t\t&#125; \t&#125;&#125;\n\n点击特效\n// click to navigateif(Input.GetMouseButtonDown(0))&#123;    RaycastHit hit;    Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);    if(Physics.Raycast(ray, out hit, Mathf.Infinity))&#123;        // move when hit floor        if(hit.transform.tag == &quot;Floor&quot;)&#123;            agent.SetDestination(hit.point);            // click effect            GameObject clickEffectObject = Instantiate(clickEffect);            clickEffectObject.transform.position = hit.point;            Destroy(clickEffectObject, 0.5f);        &#125;     &#125;&#125;\n\n拖拽旋转视角// get mouse positionfloat mouseX = Input.GetAxis(&quot;Mouse X&quot;) * mouseSensitivity * Time.deltaTime;float mouseY = Input.GetAxis(&quot;Mouse Y&quot;) * mouseSensitivity * Time.deltaTime;// rotate camera up and downcameraRotation -= mouseY;cameraRotation = Mathf.Clamp(cameraRotation, -30f, 30f);cameraTransform.localRotation = Quaternion.Euler(cameraRotation, 0f, 0f);// rotate player left and righttransform.Rotate(Vector3.up * (mouseX));\n\n此时长按拖拽和点击寻路会混，加一个mouseDownCount计数\n缩放前后移动// stop navigationagent.ResetPath();// scroll to move forward and backwardVector3 move = transform.forward * Input.GetAxis(&quot;Mouse ScrollWheel&quot;) * scrollSensitivity;agent.Move(move * Time.deltaTime);\n\n！这里一定要先停止寻路，否则会乱抖\n最终using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerController : MonoBehaviour&#123;    [SerializeField, Range(0f,100f)]    private float scrollSensitivity = 10f;    [SerializeField, Range(0f,500f)]    private float mouseSensitivity = 200f;    [SerializeField]    private Transform cameraTransform = null;    private float cameraRotation = 0f;    private int mouseDownCount = 0;    UnityEngine.AI.NavMeshAgent agent;    GameObject clickEffect;    void Start()    &#123;        agent = GetComponent&lt;UnityEngine.AI.NavMeshAgent&gt;();        clickEffect = Resources.Load&lt;GameObject&gt;(&quot;Prefabs/ClickEffect&quot;);    &#125;    void Update()    &#123;        if(Input.GetMouseButtonUp(0))&#123;            // if is click            if(mouseDownCount &lt; 2)&#123;                // click to navigate                RaycastHit hit;                Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);                if(Physics.Raycast(ray, out hit, Mathf.Infinity))&#123;                    // move when hit floor                    if(hit.transform.tag == &quot;Floor&quot;)&#123;                        agent.SetDestination(hit.point);                        // click effect                        GameObject clickEffectObject = Instantiate(clickEffect);                        clickEffectObject.transform.position = hit.point;                        Destroy(clickEffectObject, 1);                    &#125;                 &#125;            &#125;            mouseDownCount = 0;        &#125;else if(Input.GetAxis(&quot;Mouse ScrollWheel&quot;) != 0)&#123;            // stop navigation            agent.ResetPath();            // scroll to move forward and backward            Vector3 move = transform.forward * Input.GetAxis(&quot;Mouse ScrollWheel&quot;) * scrollSensitivity;            agent.Move(move * Time.deltaTime);        &#125;else if(Input.GetMouseButton(0))&#123;            // stop navigation            agent.ResetPath();            // get mouse position            float mouseX = Input.GetAxis(&quot;Mouse X&quot;) * mouseSensitivity * Time.deltaTime;            float mouseY = Input.GetAxis(&quot;Mouse Y&quot;) * mouseSensitivity * Time.deltaTime;            // rotate camera up and down            cameraRotation -= mouseY;            cameraRotation = Mathf.Clamp(cameraRotation, -30f, 30f);            cameraTransform.localRotation = Quaternion.Euler(cameraRotation, 0f, 0f);            // rotate player left and right            transform.Rotate(Vector3.up * (mouseX));            mouseDownCount++;        &#125;    &#125;&#125;\n\n点击寻路\n\n\n滚动前后平移\n\n\n拖拽旋转视角\n\n\n且寻路过程中，滚动或拖拽均打断寻路\n","categories":["Note"],"tags":["unity"]},{"title":"Unity Note - Project08 Gallery","url":"/2021/02/15/unity/","content":"\nCreate a Personal 3D Gallery Project with Unity\n\n\nUse the [first person controller](First Person All-in-One) in asset store\n\nModel scale ~= Cube 40*40\n\n\n\n\n\nAdd Component-&gt;Physic-&gt;Mesh Collider to models\n\nLight: turn off shadow &amp; increase range to 20\n\nSound effect for different walking materials\nChange Material in Mesh Collider, not Mesh Renderer\n\n\n\n\n\nAdd UI-&gt;Text\nWhen setting Rect Transform, press Alt(Option) to set position as well\n\nAdd Tag to Text\n\nAdd Image: Drag jpg onto Plane\n\nClose to display text\n\n\ndrag script onto image\nusing System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class Proximity : MonoBehaviour&#123;    public string newTitle;    public string newAuthor;    public string newDesc;    private Transform other;    private Text myTitle;    private Text myAuthor;    private Text myDesc;    private float dist;    private GameObject player;    private GameObject message1;    private GameObject message2;    private GameObject message3;    private bool check;    // Start is called before the first frame update    void Start()    &#123;        player = GameObject.FindWithTag(&quot;Player&quot;);        other = player.GetComponent&lt;Transform&gt;();        message1 = GameObject.FindWithTag(&quot;ArtTitle&quot;);        message2 = GameObject.FindWithTag(&quot;ArtAuthor&quot;);        message3 = GameObject.FindWithTag(&quot;ArtDescription&quot;);        myTitle = message1.GetComponent&lt;Text&gt;();        myTitle.text = &quot;&quot;;        myAuthor = message2.GetComponent&lt;Text&gt;();        myAuthor.text = &quot;&quot;;        myDesc = message3.GetComponent&lt;Text&gt;();        myDesc.text = &quot;&quot;;        check = false;    &#125;    // Update is called once per frame    void Update()    &#123;        if (other)        &#123;            dist = Vector3.Distance(transform.position, other.position);            print(&quot;Distance to player: &quot; + dist);            if (dist &lt; 4)            &#123;                myTitle.text = newTitle;                myAuthor.text = newAuthor;                myDesc.text = newDesc;                check = true;            &#125;            if (dist &gt; 4 &amp;&amp; check == true)            &#123;                Start();            &#125;        &#125;    &#125;&#125;\n\n","categories":["Note"],"tags":["unity"]},{"title":"Project V0.1 Record","url":"/2021/02/16/unity/","content":"做了个初版试试水~😃\n功能点击寻路\n\n靠近显示介绍\n\n鼠标滚动前后平移\n\n键盘前后左右平移\n\n鼠标拖拽旋转视角\n\n项目结构\n\n代码PlayerControllerusing System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerController : MonoBehaviour&#123;    [SerializeField, Range(0f,500f)]    private float mouseLookSensitivity = 200f;    [SerializeField, Range(0f,100f)]    private float mouseMoveSensitivity = 10f;    [SerializeField, Range(0f,10f)]    private float keyMoveSensitivity = 5f;    [SerializeField]    private Transform cameraTransform = null;    private float cameraRotation = 0f;    private int mouseDownCount = 0;    UnityEngine.AI.NavMeshAgent agent;    GameObject clickEffect;    void Start()    &#123;        agent = GetComponent&lt;UnityEngine.AI.NavMeshAgent&gt;();        clickEffect = Resources.Load&lt;GameObject&gt;(&quot;Prefabs/ClickEffect&quot;);    &#125;    void Update()    &#123;        if(Input.GetMouseButtonUp(0))&#123;            // if is click            if(mouseDownCount &lt; 2)&#123;                // click to navigate                RaycastHit hit;                Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);                if(Physics.Raycast(ray, out hit, Mathf.Infinity))&#123;                    // move when hit floor                    if(hit.transform.tag == &quot;Floor&quot;)&#123;                        agent.SetDestination(hit.point);                        // click effect                        GameObject clickEffectObject = Instantiate(clickEffect);                        clickEffectObject.transform.position = hit.point;                        Destroy(clickEffectObject, 1);                    &#125;                 &#125;            &#125;            mouseDownCount = 0;        &#125;else if(Input.GetMouseButton(0))&#123;            // stop navigation            agent.ResetPath();            // get mouse position            float mouseX = Input.GetAxis(&quot;Mouse X&quot;) * mouseLookSensitivity * Time.deltaTime;            float mouseY = Input.GetAxis(&quot;Mouse Y&quot;) * mouseLookSensitivity * Time.deltaTime;            // rotate camera up and down            cameraRotation -= mouseY;            cameraRotation = Mathf.Clamp(cameraRotation, -30f, 30f);            cameraTransform.localRotation = Quaternion.Euler(cameraRotation, 0f, 0f);            // rotate player left and right            transform.Rotate(Vector3.up * (mouseX));            mouseDownCount++;        &#125;else if(Input.GetAxis(&quot;Mouse ScrollWheel&quot;)!=0 || Input.GetAxis(&quot;Horizontal&quot;)!=0 || Input.GetAxis(&quot;Vertical&quot;)!=0)&#123;            // stop navigation            agent.ResetPath();            // mouse scroll input            float mouseV = Input.GetAxis(&quot;Mouse ScrollWheel&quot;);            // keyborad input            float keyV = Input.GetAxis(&quot;Vertical&quot;);            float keyH = Input.GetAxis(&quot;Horizontal&quot;);            Vector3 move = transform.forward * (mouseV * mouseMoveSensitivity + keyV * keyMoveSensitivity)                        + transform.right * keyH * keyMoveSensitivity;            agent.Move(move * Time.deltaTime);        &#125;    &#125;&#125;\n\nArtTextControllerusing System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class ArtTextController : MonoBehaviour&#123;    [SerializeField]    private string title;    [SerializeField]    private string description;    [SerializeField, Range(0f,10f)]    private float displayTextDistance = 5f;    private Transform playerTransform;    private Text displayArtTitle;    private Text displayArtDescription;    private float dist;    private bool check;    void Start()    &#123;        // get player transform        playerTransform = GameObject.FindWithTag(&quot;Player&quot;).GetComponent&lt;Transform&gt;();        // get UI text        displayArtTitle = GameObject.FindWithTag(&quot;ArtTitle&quot;).GetComponent&lt;Text&gt;();        displayArtDescription = GameObject.FindWithTag(&quot;ArtDescription&quot;).GetComponent&lt;Text&gt;();        // set default text        displayArtTitle.text = &quot;&quot;;        displayArtDescription.text = &quot;&quot;;        check = false;    &#125;    // Update is called once per frame    void Update()    &#123;        if(playerTransform)        &#123;            // distance between art and player            dist = Vector3.Distance(transform.position, playerTransform.position);            if (dist &lt; displayTextDistance)            &#123;                displayArtTitle.text = title;                displayArtDescription.text = description;                check = true;            &#125;            // turn off display            if (dist &gt; displayTextDistance &amp;&amp; check == true)            &#123;                Start();            &#125;        &#125;    &#125;&#125;\n\n构建测试MacOS 没问题\nAndroid 试了一下，场景没问题，操作混乱\n​    安卓导出参考AR Foundation笔记01 安卓Setup\n​    目前的操作方式针对电脑，手机端以后再看要不要做\nWebGL 整了半天\n​    参考WebGL Export in Unity 2020\n​    成功发布到itch.io，但是靠近显示介绍没有了？\n​    本地Firefox打开，也没有\nWebGL DebugUnity里跑没问题\nDebug.Log人物和画的距离，可以显示，所以可能是\n​    UI显示出了问题\n​    文字没有赋值成功\n​    位置偏了\n给Text设了默认值，再试\n\n\n默认值显示了\n\n\n靠近没有了\n所以应该是位置不对\n不过后面准备改显示方法，暂时MARK，以后放UI的时候也有可能碰到这个问题\n","categories":["Note"],"tags":["unity"]},{"title":"Project V0.1.1 Record - UI,Event","url":"/2021/02/17/unity/","content":"Canvas大小\nhttps://www.youtube.com/watch?v=OKK69bmjmJE&amp;ab_channel=Creagines\n\nCanvas Scaler-&gt; 缩放模式 -&gt; 屏幕大小缩放\n解决了上次文字飞掉的问题\n可以下一步啦\n\n\n点击按钮\nhttps://www.cnblogs.com/Peng18233754457/p/7792442.html\n\n一开始事件用的是Button的onClick()\n发现Event System更好用\n\n\n\nButton上鼠标单击()里+ （其它事件可以添加组件触发）\nEventTest.cs中 public void A()\n\nButton这样就可以了\n3D物体要使用，还要先给Main Camera加一个Physics Raycaster组件\n点击寻路Player监听点击实现，更改寻路\n\nhttps://www.youtube.com/watch?v=wlo-ZvV3ovg&amp;ab_channel=JasonWeimann\n\n参考↑通过Action实现，避免到处reference\n寻路转向寻路完成后转向board\n设置了一个isNavigating变量，记录状态\n到达后用DOTWeen转向\n寻路打断每次有输入时，打断寻路，同时将设置成false\n一个小问题是，第一次点击board时将isNavigating设成true，但同时Input.GetMouseButtonUp(0)也会为true，所以额外用了一个firstClick判断是否为第一次点击\n最后相关代码：\nprivate bool isNavigating = false;private bool firstClick = true;private Vector3 turnPosition;void Update()&#123;  if(Input.GetMouseButtonUp(0))&#123;    if(isNavigating)&#123;      if(firstClick)&#123;        firstClick = false;      &#125;else&#123;        isNavigating = false;      &#125;    &#125;else&#123;      firstClick = true;       // 这里可能有点点问题，isNavigating设成false之后，要下一次Update才能检测到，但是Update调得很快，基本感觉不到，所以暂时就这样写了，看着舒服些。但MARK一下，以后如果有问题，再把这里拆出去单独判断。    &#125;\t\t// ...  &#125;else if(Input.GetMouseButton(0))&#123;    isNavigating = false;   // ...  &#125;else if(Input.GetAxis(&quot;Mouse ScrollWheel&quot;)!=0 || Input.GetAxis(&quot;Horizontal&quot;)!=0 || Input.GetAxis(&quot;Vertical&quot;)!=0)&#123;    isNavigating = false;    // ...    &#125;  &#125;&#125;private void SetNewDestination(Vector3 destination, Vector3 boardPosition) &#123;  // set new destination  agent.SetDestination(destination);  // set turn destination  turnPosition = boardPosition;  isNavigating = true;&#125;\n\n02.19 update后续做导游时发现，点击UI寻路按钮时，事件发生的顺序是：\n\nGetMouseButton\nSet Destination\nGetMouseButtonUp\n\n而再次GetMouseButton和GetMouseButtonUp都需要打断，用之前的方法很混乱\n于是改成三种状态，只能按顺序切换\n\nGuideStatus.Static 默认状态\n\nGuideStatus.Ready 设置寻路后，Static-&gt;Ready\n\nGuideStatus.On\n\nReady状态获取到一次GetMouseButtonUp，变成On\nOn状态时，GetMouseButton或GetMouseButtonUp均会打断寻路，变成Static\nOn状态到达目的地后，变成Static\n\n\n\n测试目前没什么问题\nprivate Vector3 turnPosition;private GuideStatus currentGuideStatus = GuideStatus.Static;private enum GuideStatus&#123;  Static,  Ready,  On&#125;void Update()&#123;  if(Input.GetMouseButtonUp(0))&#123;    // if is click    if(mouseDownCount &lt; 2)&#123;      if(currentGuideStatus == GuideStatus.Ready)&#123;        currentGuideStatus = GuideStatus.On;      &#125;else if(currentGuideStatus == GuideStatus.On)&#123;        currentGuideStatus = GuideStatus.Static;        Debug.Log(&quot;[guide] disrupted by GetMouseButtonUp-Click&quot;);      &#125;      // ...    mouseDownCount = 0;  &#125;else if(Input.GetMouseButton(0))&#123;    if(currentGuideStatus==GuideStatus.On)&#123;      currentGuideStatus = GuideStatus.Static;      Debug.Log(&quot;[guide] disrupted by GetMouseButton&quot;);    &#125;    // ...    mouseDownCount++;  &#125;else if(Input.GetAxis(&quot;Mouse ScrollWheel&quot;)!=0 || Input.GetAxis(&quot;Horizontal&quot;)!=0 || Input.GetAxis(&quot;Vertical&quot;)!=0)&#123;      if(currentGuideStatus==GuideStatus.On)&#123;        currentGuideStatus = GuideStatus.Static;        Debug.Log(&quot;[guide] disrupted by Movement&quot;);      &#125;            // ...      &#125;else&#123;    if(currentGuideStatus==GuideStatus.On &amp;&amp; agent.remainingDistance==0)&#123;      Debug.Log(&quot;[guide] look at &quot;+turnPosition);      transform.DOLookAt(turnPosition,turnDuration,AxisConstraint.Y);      currentGuideStatus = GuideStatus.Static;      Debug.Log(&quot;[guide] end&quot;);    &#125;  &#125;&#125;private void SetNewDestination(Vector3 destination, Vector3 destination2) &#123;  Debug.Log(&quot;[guide] start&quot;);  currentGuideStatus = GuideStatus.Ready;  // set new destination  agent.SetDestination(destination);  // set turn destination  turnPosition = destination2;&#125;\n\n\n\n\n\nUI遮盖Raycast加完导航寻路的UI之后，发现raycast仍可以穿透UI，同时点击寻路\n看到一种解决是用EventSystem.current.IsPointerOverGameObject()\n但是Canvas是全屏大小，点击哪里都是true\nCanvas Group也没有用\n\nhttps://stackoverflow.com/questions/52654002/unity-not-ignoring-button-click-in-ignore-raycast-layer\n\n最后参考这个\n\nhttps://gameinstitute.qq.com/community/detail/129017\n\n给所有的Button加了tag来判断\nprivate bool IsPointerOverUIObject()&#123;    // get mouse position    PointerEventData eventDataCurrentPosition = new PointerEventData(EventSystem.current);    eventDataCurrentPosition.position = new Vector2(Input.mousePosition.x, Input.mousePosition.y);    // get all raycast result    List&lt;RaycastResult&gt; results = new List&lt;RaycastResult&gt;();    EventSystem.current.RaycastAll(eventDataCurrentPosition, results);        // check UI tag    foreach(RaycastResult r in results)&#123;        if(r.gameObject.tag == &quot;UI&quot;)&#123;            return true;        &#125;    &#125;    return false;&#125;\n\n脚本执行顺序问题做了导航栏之后，发现初始化顺序有点问题\n导航栏要使用Board上的数字和名字，有时会为默认值\n选中任意一个script，调整Inspector-&gt;Execution Order，解决\n","categories":["Note"],"tags":["unity"]},{"title":"Unity Note - Project10 Wave","url":"/2021/02/21/unity/","content":"尝试做个波浪动画，最后效果：\n\n\n\nstrip做成Prefab\nusing System.Collections;using System.Collections.Generic;using UnityEngine;using DG.Tweening;public class Strip : MonoBehaviour&#123;    public void Activate(float waitSecond, float moveDistance, float moveDuration)    &#123;        StartCoroutine(ActivateMovement(waitSecond, moveDistance, moveDuration));    &#125;     private IEnumerator ActivateMovement(float waitSecond, float moveDistance, float moveDuration)    &#123;        // wait for some time        yield return new WaitForSeconds(waitSecond);                // set movement        DOTween.Sequence()            .Append(transform.DOMoveY(moveDistance, moveDuration).SetEase(Ease.InOutSine))            .SetLoops(-1,LoopType.Yoyo);    &#125;&#125;\n\n加一个controller\nusing System.Collections;using System.Collections.Generic;using UnityEngine;public class StripController : MonoBehaviour&#123;    // object setting    [SerializeField] private int stripNum = 10;    [SerializeField] private Vector3 stripScale = new Vector3(0.2f,5,0.01f);    [SerializeField] private Vector3 stripInterval = new Vector3(0.25f,0,0);    // movement setting    [SerializeField] private float moveDistance = 2f;    [SerializeField] private float moveDuration = 2f;    [SerializeField] private float moveInterval = 0.1f;    private Strip stripPrefab;    private Strip[] strips;        void Start()    &#123;        stripPrefab = Resources.Load&lt;Strip&gt;(&quot;strip&quot;);        CreateStrips();    &#125;    private void CreateStrips()    &#123;        strips = new Strip[stripNum];        for(int i=0; i&lt;stripNum; i++)&#123;            // create cube            Strip obj = Instantiate(stripPrefab);            // set position            obj.transform.position = transform.position + stripInterval * i;            obj.transform.localScale = stripScale;            // activate movement            obj.Activate(moveInterval*(i+5), moveDistance, moveDuration);            // add to array            strips[i] = obj;        &#125;    &#125;&#125;\n\n奇怪的一点，前几个条的起始时间总是有点问题，暂时找不出来为什么，先把所有起始时间往后挪一点 MARK\n\n\n这样就没问题了\n\n\n\n关于WaitForSeconds()\n\nhttps://forum.unity.com/threads/waitforseconds-in-c.75411/\n\nprivate void executeWait()&#123;  Debug.Log(&quot;wait start&quot;);  StartCoroutine(Wait(20.0f));  Debug.Log(&quot;This gets called after starting the Coroutine&quot;);&#125;private IEnumerator Wait(float seconds)&#123;  Debug.Log(&quot;waiting&quot;);  yield return new WaitForSeconds(seconds);  Debug.Log(&quot;wait end&quot;);&#125;\n\n\n现在这个波浪效果一个问题是DOTWeen消耗太大\n\n\n也许还是直接用波浪形物体平移？\n\n一个很喜欢的chrome插件几枝是用noise做的波浪，试一下Mathf.PerlinNoise()\n参考：\n\nhttps://blog.csdn.net/FumikiSAMA/article/details/80212432\nhttps://docs.unity3d.com/ScriptReference/Mathf.PerlinNoise.html\n\n网格拓扑绘制图形\n\nhttps://www.jianshu.com/p/1f79e33308a6\n\n试着画了一个四面体\n\n\nVector3[] vertices = new Vector3[4];vertices[0] = new Vector3(0, 0, 0);vertices[1] = new Vector3((float)System.Math.Sqrt(3), 1, 0);vertices[2] = new Vector3(0, 2, 0);vertices[3] = new Vector3((float)System.Math.Sqrt(1/3), 1, (float)System.Math.Sqrt(8/3));int[] triangle = new int[12] &#123;0,2,1,0,1,3,1,2,3,2,0,3&#125;;// get meshMesh mesh = GetComponent&lt;MeshFilter&gt;().mesh;// clear original meshmesh.Clear();// set new verticesmesh.vertices = vertices;// set new trianglesmesh.triangles = triangle;// calculate meshmesh.RecalculateNormals();\n\n下次用这个画波浪试试\n","categories":["Note"],"tags":["unity"]},{"title":"Unity Note - Project11 Wave2","url":"/2021/03/08/unity/","content":"按照上次的设想：\n\nPerlinNoise生成波浪\n\nhttps://docs.unity3d.com/cn/current/ScriptReference/Mathf.PerlinNoise.html\n\n\n用Mesh绘制\n\n随时间更新\n\n\n\n\n效果还不错\n加了几个，调下参数\n\n\nusing System.Collections;using System.Collections.Generic;using UnityEngine;public class WaveCreator : MonoBehaviour&#123;    [SerializeField] private int waveLength = 100; // length of wave    [SerializeField] private float segLen = 0.2f; // length of each segment    [SerializeField] private float samplingInterval = 20f;    [SerializeField] private float maxHeight = 10f;    [SerializeField] private string colorHex = &quot;#45b787&quot;;    [SerializeField] private float colorAlpha = 0.8f;    private Color waveColor;    private float seedX = 0;    private float seedY = 0;        void Start()    &#123;        // generate random seed        seedX = Random.value * 100f;        seedY = Random.value * 100f;        // set material        GetComponent&lt;MeshRenderer&gt;().material = InitMaterial();    &#125;    void Update() &#123;        float[] arr = GenerateNoiseArray(waveLength);        DrawWave(arr);    &#125;    private float[] GenerateNoiseArray(int len)&#123;        // generate wave height array        float[] arr = new float[len];        for(int i=0; i&lt;arr.Length; i++)&#123;            float x = (i + seedX + Time.time) / samplingInterval;            float y = (i + seedY) / samplingInterval;            // noise between 0.0 and 1.0            arr[i] = Mathf.PerlinNoise(x, y) * maxHeight;        &#125;        return arr;    &#125;    private void DrawWave(float[] arr)&#123;        int n = arr.Length;        Vector3[] vertices = new Vector3[2*n];        List&lt;int&gt; triangleList = new List&lt;int&gt;();        // add vertices        for(int i=0; i&lt;n; i++)&#123;            vertices[2*i] = new Vector3(segLen*(i+1), 0, 0);            vertices[2*i + 1] = new Vector3(segLen*(i+1), arr[i], 0);        &#125;        // add triangles        for(int i=0;i&lt;n-1;i++)&#123;            // clockwise order            triangleList.Add(2*i);            triangleList.Add(2*i + 1);            triangleList.Add(2*i + 2);            triangleList.Add(2*i + 2);            triangleList.Add(2*i + 1);            triangleList.Add(2*i + 3);        &#125;        int[] triangles = triangleList.ToArray();        // get mesh        Mesh mesh = GetComponent&lt;MeshFilter&gt;().mesh;        // clear original mesh        mesh.Clear();        // set new vertices        mesh.vertices = vertices;        // set new triangles        mesh.triangles = triangles;        // calculate mesh        mesh.RecalculateNormals();    &#125;    private Material InitMaterial()&#123;        Material material = new Material(Shader.Find(&quot;Standard&quot;));        // set rendering mode        SetFade(material);        // set color        ColorUtility.TryParseHtmlString(colorHex, out waveColor);        waveColor.a = colorAlpha;        material.SetColor(&quot;_Color&quot;, waveColor);        return material;    &#125;    private void SetFade(Material material)&#123;        // set rendering mode to fade to show alpha        material.SetInt(&quot;_SrcBlend&quot;, (int)UnityEngine.Rendering.BlendMode.SrcAlpha);        material.SetInt(&quot;_DstBlend&quot;, (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);        material.SetInt(&quot;_ZWrite&quot;, 0);        material.DisableKeyword(&quot;_ALPHATEST_ON&quot;);        material.EnableKeyword(&quot;_ALPHABLEND_ON&quot;);        material.DisableKeyword(&quot;_ALPHAPREMULTIPLY_ON&quot;);        material.renderQueue = 3000;    &#125;&#125;\n\n","categories":["Note"],"tags":["unity"]},{"title":"Project V0.2 Record","url":"/2021/03/16/unity/","content":"重新搭建了场景，unity中运行没问题\nDebug构建后遇到一些bug\n按钮文字缺失构建mac版本后，按钮上的文字消失了，但是其它地方（详情、场景中）都正常\n发现原本的按钮使用了TextMeshPro，但是没有必要，改成了用Text的\n代码也修改成\n// [SerializeField] private TextMeshProUGUI guideText = null;    [SerializeField] private Text guideText = null;\n\n重新构建，就没有问题了\n顺便上一版中第一次点开详情没有文字的bug也消失了\nunityFramework is not defined构建webgl版本后，firefox浏览器加载时进度条卡在80%左右，控制台报错\nUncaught ReferenceError: unityFramework is not defined\n（但是发布到itch.io后可以正常显示）\nhttps://forum.unity.com/threads/uncaught-referenceerror-unityframework-is-not-defined-at-htmlscriptelement-script-onload-webgl.803967/\n参考↑中一个回答：Try to disable compression\n解决😄\n之前看教程的时候应该是调过这个参数的，这次搞忘了\nV0.2.1新标签页打开网页mac版本中，点查看大图会打开浏览器新页面\nwebgl版本中，点查看大图会直接在当前页跳转\n想改成新标签页\n参考https://stackoverflow.com/questions/62348214/how-to-open-a-link-on-a-new-tab-using-webgl-c-through-unity\n\nusing .jslib file\nAssets/plugins/plugin.jslib\nvar plugin = &#123;    OpenNewTab : function(url)    &#123;        url = Pointer_stringify(url);        window.open(url,&#x27;_blank&#x27;);    &#125;,&#125;;mergeInto(LibraryManager.library, plugin);\n\nYour C# script\nusing System.Collections;using System.Collections.Generic;using UnityEngine;using System.Runtime.InteropServices;public class OpenURL : MonoBehaviour&#123;    [DllImport(&quot;__Internal&quot;)]    private static extern void OpenNewTab(string url);    public void openIt(string url)    &#123;#if !UNITY_EDITOR &amp;&amp; UNITY_WEBGL             OpenNewTab(url);#endif    &#125;    void Update()    &#123;        if (Input.GetKeyDown(KeyCode.Return))        &#123;            openIt(&quot;www.wateverurluwant.com&quot;);        &#125;    &#125;&#125;\n\nfirefox和itch.io测试均可~\n帮助按钮还需要把帮助按钮加回来\n并且默认首次打开程序时弹出显示\nV0.2.2图片模糊问题把所有图片加进去了\n发现千里江山图导入之后很模糊\n\n\n发现可以调最大尺寸，就清晰了\n\n\n\n测试发布的时候V0.2.2，build里面data文件有235.4MB，itch.io无法加载\n将图片全体降了一个清晰度，变成114MB，可以加载了，但还是很大\n将5种花删成2种，变成104.7MB\n把波浪长椅换成和其它地方一样的竹椅，墙外的竹子叶子全删到最少，变成102.1MB\n墙外竹子全删掉，变成91.3MB\nV0.2.1的时候是42.3MB，看来还是画最占空间\n","categories":["Note"],"tags":["unity"]},{"title":"Unity Debug WebGL播放视频","url":"/2021/04/02/unity-debug/","content":"Unity内运行时播放视频没问题，导出后用火狐打开就放不了，看控制台报错是\n已拦截跨源请求：同源策略禁止读取位于 file:///Users/.../unity/Backups/WebV0.3/sharedassets0.resource 的远程资源。（原因：CORS 请求不是 http）。\n\n解决方法\nWebGL只能通过URL播放视频\n\nUnity2019在WebGL下播放视频\n\n\n火狐浏览器设置允许跨域\nsecurity.fileuri.strict_origin_policy改false\n\nFirefox火狐浏览器访问本地文件-提示跨域问题\n\n\n火狐浏览器设置允许播放视频\n\nUnity2018发布webgl视频无法播放\n\n\n\n各种失败尝试记录1.\n\nhttps://blog.kongregate.com/unity-html5-cors-and-you/\n\n写了问题原因，但是没看到针对Unity怎么解决\n2.\n\nhttps://www.jianshu.com/p/78904381ba32\n\n说把privacy.file_unique_origin改成false，但是它已经是false了\n3.\n发现Unity中Video Player的视频源有视频剪辑和URL两种方式\n之前用的是视频剪辑，直接把mp4文件拖进去\n改用URL试试，从浏览中找到同一个文件，测试也可以播放。试了一个网络上的mp4的URL，测试也可以\n那或许可以尝试把mp4上传，然后用URL访问\n\nhttps://blog.csdn.net/weixin_33912453/article/details/94087306?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.baidujs&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.baidujs\n\n试试这个用爱奇艺开放平台的\n发现注册应用必须有url\n4.\n再找一下有没有视频托管网站\nhttps://www.zhihu.com/question/23036186/answer/1716470191\n找了一个酷播云，视频要审核，等会再看（似乎不能直接拿到URL，可能要凉）\nhttp://www.stonepoll.com/helpcenter/hc/kb/article/fcc34c50-301a-822a-df8c-e690f5af5bb5/\n腾讯云要买服务，算了先\n又传了一个优酷的，等会看审核\n得，拿不到mp4的URL\n5.\n还是从浏览器入手吧，试试允许跨域\nhttps://blog.csdn.net/nju_zjy/article/details/108870385\n参考这个，装一个火狐插件\n没用\n多试了几个插件，都没用\n6.\n有找到一个调浏览器设置的\nhttps://blog.csdn.net/qq_28867949/article/details/99890103?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&amp;spm=1001.2101.3001.4242\n把security.fileuri.strict_origin_policy改成false\n【重启后不报错了！】\n但是视频还是播放不了\n7.\nhttps://blog.csdn.net/qq_38229886/article/details/103139228?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-2&amp;spm=1001.2101.3001.4242\nWebGL不支持mp4？！…\n转成ogv。没用\n8.\n找了一个在线的mp4地址，本地ok\n导出WebGL运行，不报错，播放不了\n9.\nhttps://blog.csdn.net/weixin_43779625/article/details/103410836\n改用Render Texture的方式（以前是材质覆盖）\n不行（甚至本地都显示不了视频，只有声音）\n10.\nhttps://blog.csdn.net/JLX_Sir/article/details/82684491?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.baidujs&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.baidujs\n说WebGL不支持高分辨率\n试试在检查器里设置转码 1/4分辨率，比特率模式低，空间质量低\n导出，不行\n11.\nhttps://blog.csdn.net/qq_34243277/article/details/114398872?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&amp;spm=1001.2101.3001.4242\n火狐还有阻止音视频的默认设置？？关掉\nmp4和ogv都不行\n12.\nhttps://blog.csdn.net/s1314_JHC/article/details/80618252\n还有说是WebGL不支持MovieTexture的，用插件\n导出后是黑的，疯狂报错\n13.\nhttps://blog.csdn.net/wuyt2008/article/details/107592492?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161752087116780265448826%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=161752087116780265448826&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~times_rank-10-107592492.first_rank_v2_pc_rank_v29&amp;utm_term=unity+webgl+%E8%A7%86%E9%A2%91%E9%BB%91%E5%B1%8F\n这个说WebGL只能通过url播放\n现在调过火狐的设置了，再试试url吧\n!!!!!!!!!!!!成功了😭!!!!!!!!!!!!\n","categories":["Note"],"tags":["unity"]},{"title":"Project V0.1.2 Record","url":"/2021/03/09/unity/","content":"描述部分给导航栏加了一个按钮，点击显示描述\n以及一个查看大图的按钮，打开一个新页面\n查看大图关于图画细节的浏览，设想过几种方案：\n\n在Unity内放大图，通过移动人物或滚动图片来查看细节\n但是移动的操作会比较复杂，和现有的控制冲突\n滚动图片的话，各张图的大小差别太大，也不好放\n还有一个是图片的版权问题，下载大图放在工程里感觉还是不太好\n\n内嵌网页\n寻找了一些实现方式，但是都比较局限，没有官方的解决方案\n\n打开新页面\n简单粗暴，虽然要跳出一下，但是专业的网站看图也好操作\n\n\n于是暂且就这样了\n图画信息和展板管理以前是直接把文字信息放在展板的Object上\n但是随着以后展厅的引入，会很麻烦\n于是将主要信息存到了csv里，并且新增了一个单例的ArtManager，用于管理所有的文本信息和模型中展板的引用。其它Board以及GuideBar中要用到这些信息时，直接通过ArtManager获得。\nusing System.Collections;using System.Collections.Generic;using UnityEngine;public class ArtManager : MonoBehaviour&#123;    public static ArtManager instance;    // reference to each board in each hall    [SerializeField] private Board[] boardsInHall0 = null;    [SerializeField] private Board[] boardsInHall1 = null;    // number of halls    private int numOfHalls = 2;    // store art info in each hall    private Dictionary&lt;int, ArtInfo&gt;[] artInfoStore;    void Start()    &#123;        if(instance != null)&#123;            GameObject.Destroy(this.gameObject);            return;        &#125;        instance = this;        // load art info        artInfoStore = new Dictionary&lt;int, ArtInfo&gt;[numOfHalls];        for(int i=0; i&lt;artInfoStore.Length; i++)&#123;            artInfoStore[i] = new Dictionary&lt;int, ArtInfo&gt;();        &#125;        ArtInfoLoader.LoadArtInfo(artInfoStore);    &#125;    // ---------- Functions for Board &amp; GuidBar ----------    public ArtInfo GetArtInfo(int hall, int index)&#123;        return artInfoStore[hall][index];    &#125;    // ---------- Functions for GuideBar ----------    public string getGuideMenuText(int hall, int index)&#123;        return artInfoStore[hall][index].title;    &#125;    public int getBoardNumInHall(int hall)&#123;        return artInfoStore[hall].Count;    &#125;    public Vector3[] getDestination(int hall, int index)&#123;        Vector3[] ret = null;        if(hall == 0)&#123;            ret = boardsInHall0[index - 1].GetDesitination(); // index begin with 1        &#125;else if(hall == 1)&#123;            ret = boardsInHall1[index - 1].GetDesitination();        &#125;        return ret;    &#125;&#125;\n\n这里不同展厅的展板分了不同的数组，因为二维数组没法在Unity里拖引用，只好退而求其次了\n还有一个细节是，画的index都是从1开始，这个也统一在ArtManager中处理了，其它类中就不用管了\n生成构建Debug生成WebGL后，部分文字显示不全\n查到一种解决方式：把颜色空间改成Linear，有错误提示，然后又把自动API取消勾选了。Graphics API变成了WebGL2.0。没用\npopup和按钮中的中文都没有了，难道是字体的问题？\n改了字体，重新生成，可以显示\n但是，每次第一次打开总是没有？要先点过一次左或者右，后续才有显示。也许是加载顺序的问题？\n调了几次顺序，还是不行\n不仅是文字显示，有时刚开始滚动条也没有，后面慢慢解决吧\nMARK 未解决的Bug：\n新加载后，第一次点更多，无文字\n点一次左/右后，有文字，但无法显示滚动条\n重新点开更多，有滚动条\n寻路转向Debug有的时候寻路到了终点不会自动转向\n发现设置GuideStatus为Ready后，有时Agent的remainingDistance仍是0（也许是有延迟），于是就直接到了stop状态\n于是改成在Update()中修改状态，当前为Ready且remainingDistance!=0，状态改为On\n当前为On且remainingDistance==0，设置转向，状态改为Static\n但是这样又出现一个问题，即在原地点击寻路，状态无法变成On\n于是在SetNewDestination()中先做一次判断，如果当前位置已经是目的位置，直接将状态设置成On\n之前Ready和On状态是为了处理鼠标点击的一些问题，目前关于鼠标：\n\n途中 OK\n原地（已经到达，测试转向）\n导航栏 OK\n展板\n快点【被打断】\n慢点 OK\n\n\n\n\n\n就很迷惑，先这样吧\n","categories":["Note"],"tags":["unity"]},{"title":"Unity Project 版本记录","url":"/2021/03/21/unity-project-memo/","content":"02.16 V0.1新增基础移动操作\n点击寻路\n\n\n靠近显示介绍\n\n鼠标滚动前后平移\n\n键盘前后左右平移\n\n\n鼠标拖拽旋转视角\n\n\n02.19 V0.1.1新增介绍牌\n删除靠近显示介绍\n\n介绍牌鼠标移入高亮\n\n点击介绍牌寻路\n\n\n\n寻路中任意操作打断\n到达目的地后转向介绍牌\n\n\n\n新增导游栏\n点击中间按钮寻路\n\n点击左右按钮更新导游栏并寻路\n\n\n\n最左/最右时按钮不可用\n\n\n\n新增菜单栏\n点击帮助按钮弹出介绍\n\n03.09 V0.1.2新增介绍\n点击导航栏中按钮，显示简介\n\n文字超出时显示滚动条\n\n\n\n\n点击查看大图打开新页面\n\n\n\n03.11 V0.2重建展厅\n初始放入隋到五代的8张画\n\n调整介绍牌样式\n\n加入天花板和灯\n\n\n\n\n03.16 V0.2.1加入帮助按钮\n点击显示操作说明\n\n\n\n\n调整\n点击查看大图时，在新窗口打开页面\n调整点击寻路粒子效果\n\n03.20 V0.2.2HallA搭建基本完成\n共28张画作\n\n\n设置座椅、绿植、花瓶等\n\n\n\n\n03.25 V0.2.3\n修改导航栏高亮效果\n\n新增装饰效果\n\n\n\n\n新增音乐\n移动时添加脚步音效\n千里江山图走廊中添加流水音效\n\n03.31 V0.2.4修改UI\n\n修改导航栏图标为文字，避免左右箭头与移动方向不一致影响体验\n\n新增上下左右移动按钮\n\n\n导航栏初始显示0展览介绍，此时只有下一幅按钮可点击\n\n\n修改展厅\n\n新增展览介绍，默认进入场景时面向展览介绍，点下一幅来到第一幅画作\n调整朝代介绍位置，使导航到画作时能完整浏览\n新增出口\n新增方向指示牌，将部分地上的花瓶移动到指示牌平台上\n\n修改导航模块\n\n点击画作也可导航\n\n04.02 V0.3新增影厅\n\n开始和暂停视频\n\n\n\n\n导航栏新增展开按钮\n\n点击展开去影厅和回起点按钮\n去影厅导航到影厅\n会起点导航到展厅介绍\n\n","categories":["Memo"],"tags":["unity"]},{"title":"记录anki卡片","url":"/2021/04/21/anki/","content":"打算用anki背法语单词，用Fast Word Query加发音\n字段：\n\n\n卡片：\n正面模板\n&lt;/br&gt;&lt;center&gt;&lt;div class=&quot;background&quot;&gt;\t&lt;div&gt;&#123;&#123;word&#125;&#125;&lt;/div&gt;&lt;/br&gt;&lt;/div&gt;&lt;/center&gt;\n\n背面模板\n&lt;center&gt;&lt;div class=&quot;background&quot;&gt;\t&#123;&#123;FrontSide&#125;&#125;\t&lt;hr id=answer&gt;\t&lt;div&gt;&#123;&#123;pronunciation&#125;&#125;&lt;/div&gt;\t&lt;div&gt;&#123;&#123;explanation&#125;&#125;&lt;/div&gt;\t&lt;div&gt;&#123;&#123;example&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;/center&gt;&lt;script&gt;var initVoice = function () &#123;    var player = document.getElementById(&#x27;dictVoice&#x27;);    document.addEventListener(&#x27;click&#x27;, function (e) &#123;        var target = e.target;        if (target.hasAttribute(&#x27;role&#x27;) &amp;&amp; target.getAttribute(&#x27;role&#x27;).indexOf(&#x27;dict_audio_js&#x27;) &gt;= 0) &#123;            var url = target.getAttribute(&#x27;data-rel&#x27;);            player.setAttribute(&#x27;src&#x27;, url);            player.volume = 1;            player.play();            e.preventDefault();        &#125;    &#125;, false);&#125;;initVoice();&lt;/script&gt;\n\nFast Word Query配置：\n\n\n试了一下法语助手只能查到发音，没有解释，于是解释用了有道\n此时效果：\n\n\n翻面自动发音，例句的语音也可以点\n但有个问题是，查到的例句是白色，背景也是白色\n选中example框，在编辑html中找到了这几个div的class，卡片中改样式\n.card &#123;font-family: arial;font-size: 20px;&#125;.background&#123;max-width: 800px;&#125;.mcols-layout&#123; background-color:#333335&#125;.trans-container&#123;background-color: #333335;&#125;\n\n搞定~\n\n\n\n又加了个pre字段，可以放le la之类的，显示时在word之前 \n查的时候忽略（在Fast Word Query中Ignore掉），仍只查word，避免查不到解释\n","categories":["Memo"],"tags":["tool"]},{"title":"DA project0 test record","url":"/2021/10/19/DA-project-test/","content":"Project0要求实现Perfect Link，给了测试用的tc.py用来修改网络情况，stress.py模拟发消息。（Distributed Algorithms 2021-2022 Project Validation.pdf）\n想测一下试试。\n注：以下几个测试都没有改tc.py的参数，即↓\n\n\nRound 1参数如图：\ntestConfig = &#123;        &#x27;concurrency&#x27; : 8, # How many threads are interferring with the running processes        &#x27;attempts&#x27; : 8, # How many interferring attempts each threads does        &#x27;attemptsDistribution&#x27; : &#123; # Probability with which an interferring thread will            &#x27;STOP&#x27;: 0.48,          # select an interferring action (make sure they add up to 1)            &#x27;CONT&#x27;: 0.48,            &#x27;TERM&#x27;:0.04        &#125;\n\npython3 stress.py -r ../template_java/run.sh -t perfect -l output -p 10 -m 10\n\ntestConfig在stress.py最后，这里全是默认，10个process，每个发10条消息（config中只有一行 10 1）\n理论上来说，应该是2-9号都要给1号发10条，总共90条\n但是出来的数据不完全是90\n\n\n（这里统计输出写了个简单工具，见最后）\n根据后面测试的结果推测，问题在testConfig这里。concurrency和attempts数值都是8，也就是有8个捣乱线程各干预8次。STOP和CONT只是暂停和继续，不会干扰最后的结果。但是这里还有0.04的概率会发TERM，直接把正在干活的process杀了。所以最后有的只发了79、80\nRound 2&#x27;concurrency&#x27; : 16&#x27;attempts&#x27; : 16&#x27;attemptsDistribution&#x27; :             &#x27;STOP&#x27;: 0.48,            &#x27;CONT&#x27;: 0.48,            &#x27;TERM&#x27;:0.04-p 20 -m 20\n\n试了几次这个参数，情况差不多。应该有19*20=380条，但是结果分别是：267、299、360、319\n突然经另一位当值的昆虫馆管理员提醒，测试进程数是有上限的\n\n\n对不起我的CPU🙇‍♂️\n（但是这里到底是在说9 100是上限，还是举个例子说如果9 100，让跑25分钟？？？）\nRound 3于是就把p和m直接设成9和100\n意识到TERM可能会对correctness有影响，这里把TERM也调成了0\n&#x27;concurrency&#x27; : 8&#x27;attempts&#x27; : 8&#x27;attemptsDistribution&#x27; :             &#x27;STOP&#x27;: 0.5,            &#x27;CONT&#x27;: 0.5,            &#x27;TERM&#x27;:0.0-p 9 -m 100\n\n\n\n输出没毛病\nRound 4然后把TERM改回去\n&#x27;concurrency&#x27; : 8&#x27;attempts&#x27; : 8&#x27;attemptsDistribution&#x27; :             &#x27;STOP&#x27;: 0.48,            &#x27;CONT&#x27;: 0.48,            &#x27;TERM&#x27;:0.04-p 9 -m 100\n\n\n\n左边是运行中部分输出\n可以发现有的process被SIGTERM杀掉了，第一次SIGTERM多一些，最后收到的少一些。第二次最后才有一个SIGTERM，此时已经发完了\n符合预期\nTool由于输出长得实在没眼看，不好debug，写了个工具统计一下\n这两放一个目录下：\n\ncount.py\noutput.txt\n\noutput.txt是stress.py的输出（只是process 1的output，全是deliver没有broadcast的，长这样↓）\nd 2 81d 2 87d 2 85d 6 48d 6 58d 6 86d 6 90d 6 93d 6 95d 6 99d 6 94d 2 11d 2 61d 2 92d 2 2d 2 9d 6 54d 2 21d 2 14...\n\ncount.py\nwith open(&quot;output.txt&quot;,&quot;r&quot;) as f:\tdata = f.readlines()\tdict = &#123;&#125;\tcount = 0\t\tfor line in data:\t\tsplited = line.split(&quot; &quot;)\t\tsender = int(splited[1])\t\tseq = int(splited[2])\t\t\t\tdict.setdefault(sender,[]).append(seq)\t\tcount += 1\t\t\tprint(&quot;\\nTotal number of senders: &quot; , len(dict), &quot;\\n&quot;)\tprint(&quot;Total number of messages: &quot;,  count, &quot;\\n&quot;)\tprint(&quot;Details (S: sender id; T: total message received, Q: seq)\\n&quot;)\t\t\tkeys = []\tfor sender in dict.keys():\t\tkeys.append(int(sender))\tkeys.sort()\t\tfor sender in keys:\t\tdict[sender].sort()\t\tprint(&quot;S:&quot;, format(sender,&quot;&lt;4&quot;), &quot; T:&quot;, format(len(dict[sender]),&quot;&lt;5&quot;), &quot; Q:&quot;, dict[sender])\t\t# print(&quot;S:&quot;, format(sender,&quot;&lt;4&quot;), &quot; T:&quot;, format(len(dict[sender]),&quot;&lt;5&quot;))\n\n后面输出多了，可以把具体的SEQ删掉掉，前面少的时候可以看看有没有重复\n","categories":["Memo"],"tags":["distributed_algorithm"]},{"title":"CountSketch Matrix","url":"/2021/10/27/countsketch/","content":"Drew a simple example to help understanding what I learned in class.\n\n","categories":["Note"],"tags":["sublinear_algorithm"]},{"title":"Summary on basic register reductions","url":"/2021/10/31/register/","content":"\n","categories":["Note"],"tags":["distributed_algorithm"]},{"title":"sync example note1","url":"/2021/11/13/concurrent/","content":"Cync example for C concurrent programing\nThreads#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;assert.h&gt;#define RUNS (4096 * 256)#define THREADS 4static int counter = 0;void *count(void* null) &#123;  printf(&quot;New thread created\\n&quot;);    // do something&#125;int main() &#123;  // declare an array of 4 threads  pthread_t handlers[THREADS];  for (intptr_t i = 0; i &lt; THREADS; i++) &#123;    int res = pthread_create(&amp;handlers[i], NULL, count, NULL);    assert(!res);  &#125;  for (int i = 0; i &lt; THREADS; i++) &#123;    int res = pthread_join(handlers[i], NULL);    assert(!res);  &#125;  if (counter != RUNS * THREADS) &#123;    printf(&quot;Didn&#x27;t count so well. :/, found %d\\n&quot;, counter);  &#125; else &#123;    printf(&quot;Counted up to %d.\\n&quot;, counter);  &#125;&#125;\n\nLock#include &quot;lock.h&quot;void* count(void* null) &#123;  for (int r = 0; r &lt; RUNS; r++) &#123;    lock_acquire(&amp;lock);    counter++;    lock_release(&amp;lock);  &#125;  return NULL;&#125;\n\nBetter version: use lock_wait(&amp;lock) and lock_wake_up(&amp;lock) to prevent bucy wait, but rely on a notification.\nAtomic  variableAtomic variables (~atomic registers) do not enforce atomic operation blocks.\nNeed to use atomic operation.\nstatic atomic_int counter = 0;void* count(void* null) &#123;  for (int r = 0; r &lt; RUNS; r++) &#123;    atomic_fetch_add(&amp;counter, 1);  &#125;  return NULL;&#125;\n\nAnother example\nint expected = 0;if (atomic_compare_exchange_strong(&amp;leader[r], &amp;expected, tid)) &#123;\tatomic_fetch_add(&amp;nb_leaders[r], 1); // used to check correctness&#125;\n\nDebug当有include .h时，报错\nclang: error: linker command failed with exit code 1\n\n可以在Terminal\ngcc election2.c lock.c -o ekection2.o./election2.o\n","categories":["Note"],"tags":["concurrent_algorithm"]},{"title":"sync example note2：memory order","url":"/2021/11/13/concurrent2/","content":"Producer consumer example\nThere might be conflict on buffer[], but consumed_until and produced_until prevent that (if used correctly).\nSo, only need to make sure consumed_until and produced_until accessed correctly under concurrency.\nUsing locksIn each round of produce()\nwhile (true) &#123;  lock_acquire(&amp;lock);  if (consumed_until + BUFFER_SIZE &gt; r) break;  lock_release(&amp;lock);&#125;produced[r] = ...buffer[r % BUFFER_SIZE] = produced[r];produced_until++;lock_release(&amp;lock);\n\nTwo locks:\n\ncheck if can produce: conflict on consumed_until\nconflict on produced_until\n\nIn each round of consume()\nwhile (true) &#123;  lock_acquire(&amp;lock);  if (produced_until &gt; r) break;  lock_release(&amp;lock);&#125;consumed[r] = buffer[r % BUFFER_SIZE];consumed_until++;lock_release(&amp;lock);\n\nTwo locks:\n\ncheck if can consume: conflict on produced_until\nconflict on consumed_until\n\nUsing atomic vairablesIn produce, two locks can be modified:\n\ncheck if can produce: conflict on consumed_until\nno ordering constraints -&gt; memory_order_relaxed\n\nconflict on produced_until\nstore produced_until should happen after all operations -&gt; load-store + store-store = release\n\n\nwhile (true) &#123;  // The memory order can be relaxed as we don&#x27;t read anything &quot;produced&quot; by the consumer.  int local_cu = atomic_load_explicit(&amp;consumed_until, memory_order_relaxed);  if (local_cu + BUFFER_SIZE &gt; r) break;&#125;    produced[r] = ...buffer[r % BUFFER_SIZE] = produced[r];// We want to increment &quot;produced_until&quot; after the buffer has been written.// By using memory_order_release, we prevent the STOREs on buffer from being// reordered after the atomic operation.atomic_fetch_add_explicit(&amp;produced_until, 1, memory_order_release);\n\nIn consume, two locks can be modified:\n\ncheck if can consume: conflict on produced_until\nload produced_until should happen before all operations -&gt; load-load + load-store = acquire\n\nconflict on consumed_until\nstore consumed_until should happen after all operations -&gt; load-store + store-store = release\n\n\nwhile (true) &#123;  // We don&#x27;t want to access the buffer before checking the atomic variable.  // The memory_order_acquire prevents this reordering.  int local_pu = atomic_load_explicit(&amp;produced_until, memory_order_acquire);  if (local_pu &gt; r) break;&#125;consumed[r] = buffer[r % BUFFER_SIZE];atomic_fetch_add_explicit(&amp;consumed_until, 1, memory_order_release);\n\n\n\nMemory barriers\nstd::memory_order\nFences are Memory Barriers\nMemory Barriers - Learn Modern C++\n\n\nmemory_order_relaxed: no ordering constraints\n\nmemory_order_consume\n\nmemory_order_acquire: load-load + load-store\n\n\nmemory_order_release: load-store + store-store\n\n\nmemory_order_acq_rel\n\nmemory_order_seq_cst\n\n\n\n\n\n\n\n","categories":["Note"],"tags":["concurrent_algorithm"]},{"title":"更改主题记录","url":"/2021/11/16/theme/","content":"之前一直用的Ayer主题，突然发现搜索不能用，debug了一早上解决不了，决定干脆换个主题\n尝试过三个主题后Aomorisukakeep\n决定用keep太优雅了，搜索也没有bug，妙\n","categories":["Memo"],"tags":["tool"]},{"title":"CA project 思路笔记","url":"/2021/11/28/ca-project/","content":"看Project description里给的Dual-versioned transactional memory的一些记录\n关于access set情况分析假设当前A是readable copy，B是writable copy，某一个位置可能出现的一些情况：\n\n小明读，成功，加入set\n张三读，成功，加入set\n小明写，发现张三也在set，失败 只要set里有别人，就不能写了\n\n\n张三写，发现小明已经在set，失败 只要set里有别人，就不能写了\n小明写，set里只有自己，成功\n小明读，发现已经被写过了，自己在set里，成功，读B\n张三读，发现已经被写过了，自己不在set里，失败\n\n\n\n\n\n什么时候可以加入？\n读成功的时候 什么时候可以读？\n没人写过，随便读，读A\n自己写过，可以读，读B 如果是别人写的，自己不可能在set里，不能读\n\n\n写成功的时候 什么时候可以写？\n没人写过，且set里没别人 只可能有一个人是通过写加入set的\n自己写过\n\n\n\n从而保证：\n\n只可能有一个人写\n写过的地方只有写的人能读\n没写过的地方都可以读\n\nset可以只记第一个set里可以只记录第一个加入set的人，因为：\n\n如果第一个加入set是通过写加入的\n后面可以通过set判断自己写过，可以继续读写\n其他人发现写过，且不是自己写的，读写都不可以\n\n\n如果第一个加入set是通过读加入的，\n别人不能写，因为虽然没人写过，但set里已经有人了\n别人可以读\n自己可以写，自己写过之后，别人也不可以读了这个第一个加入set的，可以视为所有者\n\n\n\n🧐project description里面说不要implement an actual set，那么按这个逻辑，只存一个值应该就足够了\n结论也就是说，一个位置是否可以读写有以下几种状态：\n以上都是针对读写事务，只读事务可以直接读，不影响\n其它问题Q：可能有写成功的，但后续操作失败，如何处理？A：这样的TX不会到commit()，而只有在commit()中可以更改valid copy，因此下一轮中有效的仍是旧的值\n关于batcher什么时候调？\n1. 事务开始，调enter() -&gt; 即在tm_begin()中\n2. 最后一个操作结束时，调leave() -&gt; 即在tm_end()中情况分析\n初始时，remaining=0\n第一个人enter()，remaining变成1\n后面的人enter()，都被挂到blocked\n第一个人leave()，remaining变成0\ncounter+1  相当于进入下一轮\nremaining重设为blocked的长度\n叫醒所有blocked里的线程\n清空blocked\n\n\n此时上一轮中被blocked的线程，在这一轮中一起开始工作。当有新线程调enter()，又会被挂到blocked里，等待下一轮\n\n遗留问题Q：为什么commit()中交换valid copy要推迟到两轮交替的间隙进行？\nQ：get_epoch()什么时候用到？是干什么用的？\n关于tx_t一个事务需要记录的东西：\n\nboolean 是否成功 如果已经失败了，后面读写的时候可以直接返回\nboolean 是否只读 读的时候可以直接读\n\n","categories":["Note"],"tags":["concurrent_algorithm"]},{"title":"DA project 2 validation tool","url":"/2021/11/30/validate/","content":"为了测试submission2(Localized Causal Broadcast)的输出写了个简陋工具，仅有限情况下测试用仅！供！参！考！不！保！证！对！\n思路如，process 1依赖2、3，和4、5没关系，会找出1的输出里所有1、2、3deliver的消息，作为参考。然后遍历其它process的输出，也找到1、2、3deliver的消息，二者完全一样视为正确。\n1的输出可以比其它多，此时多的不考虑，只比较前面的部分。\n可能的bug：按照定义，如果某条来自1的消息之前，有1条来自2的和1条来自3的，另一个process在deliver这条1的消息之前，也需要2和3的消息各一条，但是2和3的顺序可以不一样。测试没有处理这个问题，但是目前跑的时候结果没毛病，可能是测试环境的reorder还没有导致这种问题。\n使用基本和给的validate_fifo.py差不多把代码、config、output放在同一个文件夹内（即stress.py的所有输出，有多余的没关系）带参数–proc_num运行\n流程示例\ncd到tools\n把validate_lcausal.py放到tools中\nrun stresspython3 stress.py -r ../template_java/run.sh -t lcausal -l output -p 4 -m 100\n\nrun validatepython validate_lcausal.py --proc_num 4\n\n\n\n\n代码import argparseconfig_path = &#x27;./output/config&#x27;output_path = &#x27;./output/proc0&#x27;   # append id.output later, id&lt;=9def read_config():    f = open(config_path,&quot;r&quot;)    data = f.readlines()    m = 0    dict = &#123;&#125;    count = 0    for line in data:        splited = line.split(&quot; &quot;)        if count == 0:            m = int(splited[0]) # how many messages each process should broadcast        else:\t        sender = int(splited[0])\t        for i in range(len(splited)):\t            dict.setdefault(sender,[]).append(int(splited[i])) # dependency (including sender itself)        count+=1    return dict# find all &#x27;d sender seq&#x27; in output_id, where sender is in depent setdef getDependentList(id, dset):    cur_output_path = output_path+str(id)+&#x27;.output&#x27;    f = open(cur_output_path,&quot;r&quot;)    data = f.readlines()        sequence = []    for line in data:        splited = line.split(&quot; &quot;)        if splited[0] == &quot;d&quot;: # only consider diliver            if int(splited[1]) in dset: # only consider sender in depent set                sequence.append(line)    print(&#x27;#d msg of&#x27;,str(id),&#x27;:&#x27;,len(sequence))    return sequence# check if dependency of id is satisfied in all other processdef checkProcessId(id, dset):    print(&#x27;checing process&#x27;, str(id), &#x27;,depend on&#x27;, dset)        # sequence of currrent process    ref_sequence = getDependentList(id, dset)        for i in range(proc_num):        cur_id = i+1        if cur_id != id:            # sequence of other process            sequence = getDependentList(cur_id, dset)            # number should be less of equal            if len(sequence)!=len(ref_sequence):                print(&#x27;Number exceeds!&#x27;)                return False            # trim ref sequence according to the number of sequence            ref_sequence_cut = ref_sequence[:len(sequence)]            # output should be the same with ref_sequence            for a,b in zip(sequence, ref_sequence):                if a!=b:                    print(&#x27;Message not match!&#x27;)                    return False    return True# check output of all processesdef checkProcess(proc_num):    depend = read_config()    print(&#x27;dependency:&#x27;,depend,&#x27;\\n&#x27;)        for i in range(proc_num):        id = i+1        if checkProcessId(id, depend[id])==False:            return False        print(&#x27;validate process&#x27;,str(id),&#x27;OK\\n&#x27;)    return Trueif __name__ == &quot;__main__&quot;:    parser = argparse.ArgumentParser()    parser.add_argument(        &quot;--proc_num&quot;,        required=True,        dest=&quot;proc_num&quot;,        help=&quot;Total number of processes&quot;,    )    results = parser.parse_args()        proc_num = int(results.proc_num)    if checkProcess(proc_num):        print(&quot;Validation OK&quot;)    else:        print(&quot;Validation failed!&quot;)","categories":["Note"],"tags":["distributed_algorithm"]},{"title":"DA project 总结","url":"/2021/11/30/project-review/","content":"目标基于UDP Socket，实现Perfect Links -&gt; Uniform Reliable Broadcast -&gt; FIFO Broadcast application和Localized Causal Broadcast\nPerfect Links层点对点的通信，测试时跑n个process，给其中一个发m条消息。\n需要满足的性质：\n\nReliable delivery -&gt; 如果发送、接收方都正确，每一条发出的消息最终都会被接收方deliver\nNo duplication -&gt; 不重复deliver\nNo creation -&gt; 不凭空产生消息主要的几个类\n\n\nPerfectLinks\n调用SocketClient发消息\n检查并deliver，向上(URB)indicate\n\n\nSocketClient\n创建并发送Socket（包括普通消息和ACK）\n\n\nSocketServer（单独的线程）\n监听Socket，收到消息时，交给SocketServerHandler处理\n\n\nSocketServerHandler（单独的线程）\n处理收到的消息，向上(PerfectLinks)indicate\n\n\nMessageResender（单独的线程）\n定时检查并重发消息保证Reliable delivery通过ACK实现。PerfectLinks发送消息后，维持一个pending集合，用于存所有已经发送、但还没有收到ACK的消息，收到ACK后将消息移出。MessageResender定时检查这个集合，重发其中的所有消息。保证No duplication维持一个delivered集合即可。线程池SocketServerHandler用到线程池，防止同时收到消息太多时炸掉。并发控制可能会出现冲突的是pending和delivered，用ConcurrentHashMap实现。SEQ细节上层的消息有一个SEQ，创建之后不会改变，且在后面的广播中，发送给每一个process的SEQ都是一样的。而PL层需要区分发给不同process的SEQ，于是加入了PSEQ。PerfectLinks有一个AtomicInteger，每次创建消息时getAndIncrement得到PSEQ。Uniform Reliable Broadcast层每个process对其他所有process广播m条消息，需满足的性质：\n\n\n\n\nValidity -&gt; 如果一个正确的process广播了一条消息，它最终会deliver这条消息\nNo duplication\nNo creation\nAgreement -&gt; 如果某个正确的process deliver了一条消息，最终所有的process都会deliver这条消息思路UniformReliableBroadcast类调用PerfectLinks对每一个process发送消息。保证Agreement测试环境保证了至少一半的process是正确的，基于这个假设，只要确保大多数process收到消息即可。\n\n每次broadcast或收到一条新消息后，加入pending。收到新消息还需要转发，即再次广播这条消息，此时SEQ是不变的，消息中需要含有creator id和sender id。\n对pending中的每一条消息，统计从哪些不同的sender处收到了这条消息（此处收到消息，类似PL层收到ACK），如果总数过半，即可deliver。\n实现细节上述统计用到BitSet实现。对pending中的每条消息，用一个BitSet记录从哪些id收到了这条消息。\n当总数过半，deliver之后，消息可以从pending中移出。转而加入delivered中，此时不需要保留之前的统计信息，记录一个SEQ就够了。\nFIFO Broadcast application层性质：在URB的基础上，还需保证按序deliver\n思路用一个AtomicInteger数组next，记录对于每一个process，当前以及deliver的消息的SEQ。一开始用了PriorityQueue，每次比较顶部和next。后面发现PriorityQueue并发得加锁，于是还是改成了用set记录收到的SEQ，可并发的set通过ConcurrentHashMap.newKeySet()得到。\n检查deliver细节每次收到消息后，检查pending中来自这条消息creator的，有没有符合要求可以deliver的消息。用到这样一句：\nwhile(currentPending.remove(currentNext.get()))&#123;\t// ...\tcurrentNext.getAndIncrement();&#125;\ncurrentPending是一个ConcurrentSet，只有remove成功时才会返回true，可以避免并发访问时的冲突。\n至此，从PerfectLinks到FIFO，都不用加synchronized。\nUML activity graph 1\n\nLocalized Causal Broadcast层","categories":["Review"],"tags":["distributed_algorithm"]}]