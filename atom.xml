<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CoCoNutNut&#39;s NoteBook</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://coconutnutx.github.io/"/>
  <updated>2022-01-14T16:26:21.000Z</updated>
  <id>https://coconutnutx.github.io/</id>
  
  <author>
    <name>coconutnut</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Snapshot总结</title>
    <link href="https://coconutnutx.github.io/2022/01/14/snapshot/"/>
    <id>https://coconutnutx.github.io/2022/01/14/snapshot/</id>
    <published>2022-01-14T16:26:21.000Z</published>
    <updated>2022-01-14T16:26:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>重点：关于实现Wait-free Atomic Snapshot时，为什么要判断2次/n次更新</p><p>相关slides: The Power of Registers, Computing with anonymous processes</p><h1 id="实现Snapshot"><a href="#实现Snapshot" class="headerlink" title="实现Snapshot"></a>实现Snapshot</h1><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/screencapture2022-01-14 PM5.34.04.jpg"                                     ><p>当无同步更新时，scan返回的是当前所有寄存器中的值</p><p>当有同步更新时，返回的是last written value或concurrent update value</p><p>类似于regular</p><h1 id="实现Atomic"><a href="#实现Atomic" class="headerlink" title="实现Atomic"></a>实现Atomic</h1><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/screencapture2022-01-14 PM5.32.39.jpg"                                     ><p>思路：通过两个相同的collect，确保这两次操作期间没有更新，从而找到一个linearization point</p><p>注意：“相同的collect”不仅指值相同，还需要timestamp相同，否则反例见<a href="https://coconutnutx.github.io/2022/01/12/snapshot/">Snapshot的timestamp</a></p><h1 id="实现Wait-free"><a href="#实现Wait-free" class="headerlink" title="实现Wait-free"></a>实现Wait-free</h1><p>上面的算法不是wait-free，因为当有多个进程同步调用scan时，可能发生这样的情况：</p><ul><li>p1特别快，不停地更新</li><li>p2很慢，想要scan，但每次由于p1的更新，temp1总不等于temp2，无法返回</li></ul><p>解决思路通常是，让快的进程多做点事。这里如果让p1每次更新时，还要scan，那么p2即使自己无法完成scan，但可以直接抄p1 scan的结果，就有机会返回，从而达到整体的wait-free。具体算法如下：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/screencapture2022-01-14 PM5.43.28.jpg"                                     ><p>这里 if( t3=t2 ) 比较的是自己这次和上次的结果，如果一样，可以返回</p><p>而 if( t3[j,2] ≥ t1[j,2]+2 ) 比较的是其它进程，它这次的结果有没有比第一次新？如果是，则说明这两个时间点之间有过一次完整的scan，可以抄过来直接用</p><h2 id="为什么≥2（一个反例）"><a href="#为什么≥2（一个反例）" class="headerlink" title="为什么≥2（一个反例）"></a>为什么≥2（一个反例）</h2><p>如果将( t3[j,2] ≥ t1[j,2]+2 )变成( t3[j,2] ≥ t1[j,2]+1 )，无法保证一次完整的scan，可能发生这样的情况：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/IMG_FA11786ABCC8-1.jpeg"                                     ><p>即，虽然有一次更新，但这个更新可能开始于很久很久以前。如果是≥2，则可以避免。</p><h1 id="实现Anonymous"><a href="#实现Anonymous" class="headerlink" title="实现Anonymous"></a>实现Anonymous</h1><p>几个不同：</p><ul><li>上面是一个process对应一个Reg（如process1只会更新Reg1）；这里不必一一对应，从而保证anonymous</li><li>上面每个process有自己的local timestamp，每次加1；这里用一个共享的weak counter</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/screencapture2022-01-14 PM6.36.08.jpg"                                     ><p>（这里写的是n+1，后来TA说其实n就够了）</p><h2 id="为什么n（一个反例）"><a href="#为什么n（一个反例）" class="headerlink" title="为什么n（一个反例）"></a>为什么n（一个反例）</h2><p>（from last exercise session）</p><p>如果2个相同的collect就返回，假设：</p><ul><li><p>N个process同时开始，都拿到了相同的timestamp t1</p></li><li><p>process N想要scan</p></li><li><p>process 1 ~ N-1想要update（在write之前，都进行了scan，记为s1。s1=s0）</p></li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/IMG_B1316757EE80-1.jpeg"                                     ><ul><li>PN两次扫描得到了相同的[0,1]，会返回这个值</li><li>但是观察整个过程中X和Y位置的值，从来没有出现过[0,1]。这个scan无法linearize到一个时间点，违背Atomic</li><li>如果等N次相同的更新，可以避免该问题（因为其它N-1个process相同的timestamp已经用完了）</li></ul><h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><p><strong>非Anonymous情况：</strong></p><ol><li><p>process和Reg一一对应</p></li><li><p>非weak counter，每次操作都有唯一的timestamp</p></li><li><p>判断自己的collect是否可以返回 (连续2次collect相同)</p><ul><li><p>连续2次collect，所有值相同，所有timestamp相同</p></li><li><p>即可保证这两次collect之间有一次完整的scan</p></li></ul></li><li><p>判断能否抄别人的scan (某人的ts ≥ 自己开始时的ts+2)</p><ul><li>ts是每个process本地的，至少2才能保证没有“睡了很久刚醒”的情况</li></ul></li></ol><p><strong>Anonymous情况：</strong></p><ol><li><p>process和Reg并非一一对应，一个Reg可能同时被N个process更新</p></li><li><p>weak counter，N个process可能同时获得相同的timestamp</p></li><li><p>判断自己的collect是否可以返回 (连续n次collect相同)</p><ul><li><p>连续n次collect，所有值相同，所有timestamp相同</p></li><li><p>为什么是n？极限情况：</p><ul><li>所有N个process拿到了相同的timestamp，写相同值，写到同一个Reg中</li><li>除自己以外，最多可能有N-1个一模一样的更新</li><li>但如果读到了N个相同的结果，说明剩余N-1个process中，至少有一个更新了两次。这两次之间是一个完整的scan</li></ul></li><li><p>What If…?</p><ul><li>把Weak counter改成Strong counter，不会拿到相同的timestamp -&gt; 2次连续collect相同即可</li><li>仍是Weak counter，但最多10个process拿到相同的timestamp -&gt; 10次连续collect相同即可</li></ul></li></ul></li><li><p>判断能否抄别人的scan ( 某处的ts ≥ 自己开始时的ts+1 )</p><ol><li>细节：这里开始时的ts也是从Weak counter获得的，而不是collect()得到的（即，不是update()写入的）</li><li>Weak counter的性质保证，如果ts更大，该操作一定更晚发生，不会有“睡了很久刚醒”的情况<ul><li>甚至可以是 ( 某处的ts ≥ 自己开始时的ts )，只要不小于即可，Weak counter的性质可保证完整的scan（Exercise 8 Problem 2）</li></ul></li></ol></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>判断能否用自己collect的结果，需要比较两个collect是否相同（包括值和timestamp），当timestamp可能重复时，还需要排除重复情况。</p><p>判断能否抄别人的结果，需要确保产生这个结果的scan发生在自己开始之后，根据timestamp获取方式的不同（local和shared weak counter），比较时大多少也有所区别。</p><h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><p>TA的解释</p><p>关于Atomic，和实现linearizable的思路</p><blockquote><p>Weak counter facts (perspective of an individual process):</p><p>- After I get a value (return) from the weak counter by calling wInc(), at most N-1 other processes can <em>still</em> obtain a value less or equal to that.</p><p>This is true because at most N-1 other processes can be concurrently executing with me (there are at most N processes after all, me being one of them), and <em>specifically</em>, executing wInc() on that same counter (e.g. they could have been about to return from wInc()). A weak counter guarantees that if some process calls wInc after I return from wInc (Correctness) that process <em>will</em> get a higher timestamp so adding to the previous fact, at most N-1 processes might still get a lower or equal value to the one I have just obtained.</p><p>Now, the goal of the atomic snapshot (anonymous or not) is to return a read of the entire array that is linearizable. We break correctness if we somehow return an array that is <em>not</em> linearizable. For example, take the following history (sequence of states) for an array of size 2:</p><p>S1: [0, 0] -&gt; S2: [1, 0] -&gt; S3: [1, 1] -&gt; S4: [1, 0] -&gt; S5: [0, 0]</p><p>At no point in time did the array ever have the state [0, 1]. If we ever were to return that state in the scan() operation, it would break correctness. However, this could happen if we were doing a naive approach where we simply collected once (read e.g. left to right): We read the first register at S1, sleep during S2, read the second register at S3, and finally return [0, 1].</p><p>The key point is that this problem arises only if some other process writes while we are reading: if we could guarantee that, when we collect, no process wrote on any register of the array, we would be free to return the result of that collect.</p><p>The <strong>non-anonymous</strong> snapshot solves this problem in two manners:</p><p>- We add timestamps to each register</p><p>- We collect twice and only return the result if and only if the timestamps of all registers have not changed.</p><p>This implies that no register wrote on the array between the first and second collect (and that is the scan’s linearization point). Why? Because each process has its own register, therefore each register’s timestamp is <em>monotonically</em> increasing. If there is a write to the register, the timestamp necessarily increases (by one). By negation, if the timestamp did not increase, there was no write.</p><p>Can we make the same argument for the anonymous snapshot’s algorithm? The answer is no. The difficulty comes because the model is different: the anonymous snapshot allows any process to update any register. If we constrained or assigned processes to a few or their own register, we would break anonymity. The consequence is that, for each register, its timestamp is no longer monotonically increasing (because of counter is weak), so even if two reads return the same value for that register there might have been a write in between.</p><p>However, even if it is not <em>monotonically</em> increasing, it <strong>necessarily</strong> <strong>increases</strong> after every N writes (see Weak Counter facts at the beginning of this explanation). So by collecting N+1 times and getting the same timestamps on all registers, there must necessarily be a point between two of the N+1 collects in which no write to any register could have happened, and we can linearize our scan then.</p></blockquote><p>反例2</p><blockquote><p>Consider an anonymous snapshot object with M = 2, i.e. only 2 slots. Suppose process p is performing a scan operation. Suppose also that the scan operation consists of <strong>only</strong> 2 collects, as you mention, and not N as the original algorithm implies, and that process p obtains timestamp <strong>t</strong>. Suppose all other N-1 processes are performing update operations, have all obtained the same timestamp <strong>t’</strong> &lt; <strong>t</strong> and scan <strong>S</strong>, and are about to write to their corresponding register (paused just before writing).</p><p>Since N can be made arbitrarily large (and thus so can N-1), I can use any constant number of processes from this group in my counter example. More specifically, in these conditions I can choose to apply any number of writes of any value to any position of the snapshot at any point during process p’s scan, with the restriction that the timestamp value written is <strong>t’</strong> and the scan is <strong>S</strong>. Taking this into account, consider the following sequence of operations and state of the snapshot:</p><p>[empty, empty]     - initial value</p><p>[(0, t’, S), empty]   - process q1 writes (v = 0, i = 0)</p><p>[(0, t’, S), (0, t’, S)]  - process q2 writes (v = 0, i = 1)</p><p>[(0, t’, S), (0, t’, S)]  - process p reads the first register. first collect -&gt; (0, t’, S)</p><p>[(1, t’, S), (0, t’, S)]  - process q3 writes (v = 1, i = 0)</p><p>[(1, t’, S), (1, t’, S)]  - process q4 writes (v = 1, i = 1)</p><p>[(1, t’, S), (1, t’, S)]  - process p reads the second register. first collect -&gt; (1, t’, S)</p><p>[(1, t’, S), (0, t’, S)]  - process q5 writes (v = 0, i = 1)</p><p>[(0, t’, S), (0, t’, S)]  - process q6 writes (v = 0, i = 0)</p><p>[(0, t’, S), (0, t’, S)]  - process p reads the first register. second collect -&gt; (0, t’, S)</p><p>[(1, t’, S), (0, t’, S)]  - process q7 writes (v = 1, i = 0)</p><p>[(1, t’, S), (1, t’, S)]  - process q8 writes (v = 1, i = 1)</p><p>[(1, t’, S), (1, t’, S)]  - process p reads the second register. second collect -&gt; (1, t’, S)</p><p>In the previous execution, process p returns [0, 1] as the result of the scan operation (2 identical collects). However, at no point in time was the state of the snapshot ever [0, 1] indicating that the read of the snapshot is not linearizable.</p><p>Finally, note that the authors of the paper are not claiming a lower bound on the number of reads that have to be realized to have an atomic snapshot. They are claiming an upper bound (N collects -&gt; N x M reads). Maybe with some other algorithm, a strong counter or the like, you would be able to do it with less reads, but the present algorithm fails for just 2 collects as I’ve show above.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;重点：关于实现Wait-free Atomic Snapshot时，为什么要判断2次/n次更新&lt;/p&gt;
&lt;p&gt;相关slides: The Power of Registers, Computing with anonymous processes&lt;/p&gt;
&lt;h1 id=&quot;实
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="concurrent_algorithm" scheme="https://coconutnutx.github.io/tags/concurrent-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Snapshot的timestamp</title>
    <link href="https://coconutnutx.github.io/2022/01/12/snapshot/"/>
    <id>https://coconutnutx.github.io/2022/01/12/snapshot/</id>
    <published>2022-01-12T10:44:01.000Z</published>
    <updated>2022-01-12T10:44:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>CS-453 Concurrent algorithms，slide: The Power of Registers</p><p>Atomic Snapshot实现的基本思路：</p><ul><li>两次扫描，得到相同的结果</li><li>加timestamp避免ABA情况</li></ul><p>不加timestamp的反例（p19）</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/screencapture2022-01-12 PM12.20.20.jpg"                                     ><p>写了一下具体步骤：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/IMG_A6C8CC987C90-1.jpeg"                                     ><p>可以发现，两次collect得到的都是[0,0,2]，最后返回[0,0,2]<br>但是实际上，并没有一个时间点，寄存器中实际的值是[0,0,2]<br>也就是说，虽然collect了同样的值，但这个值从未存在过</p><p>所以不仅值要相同，还需要timestamp来保证没有发生过更新</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CS-453 Concurrent algorithms，slide: The Power of Registers&lt;/p&gt;
&lt;p&gt;Atomic Snapshot实现的基本思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两次扫描，得到相同的结果&lt;/li&gt;
&lt;li&gt;加timestamp避免
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="concurrent_algorithm" scheme="https://coconutnutx.github.io/tags/concurrent-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Obsidian使用感受</title>
    <link href="https://coconutnutx.github.io/2022/01/12/note/"/>
    <id>https://coconutnutx.github.io/2022/01/12/note/</id>
    <published>2022-01-12T08:56:00.000Z</published>
    <updated>2022-01-12T08:56:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>想要试试带关系图的双链笔记，10月开始尝试Obsidian，到现在差不多三个月，没想到已经这么多了。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/Obsedian2021.jpg"                                     ><p>一开始只是记了些课程笔记，蓝色是Machine Learning，粉色是Sublinear Algorithms，紫色和黄色是Distributed和Concurrent Algorithms。后来又把一些其它的、包括读书笔记都加了进来。看着整个图一点点长大、不同的部分开始有了联系，有种集卡游戏的满足感。</p><p>Obsidian+Github真是太棒了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想要试试带关系图的双链笔记，10月开始尝试Obsidian，到现在差不多三个月，没想到已经这么多了。&lt;/p&gt;
&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg
      
    
    </summary>
    
    
      <category term="Memo" scheme="https://coconutnutx.github.io/categories/Memo/"/>
    
    
      <category term="tool" scheme="https://coconutnutx.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>CA project 状态分析&amp;debug</title>
    <link href="https://coconutnutx.github.io/2021/12/16/ca-condition/"/>
    <id>https://coconutnutx.github.io/2021/12/16/ca-condition/</id>
    <published>2021-12-16T19:49:38.000Z</published>
    <updated>2021-12-16T19:49:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>上次<a href="https://coconutnutx.github.io/2021/11/28/ca-project/">CA project 思路笔记</a>分析一个位置是否可以读写的状态：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-16 PM8.49.01.jpg"                                     ><p>但是在project测试过程中发现有问题。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>按照<a class="link"   href="http://localhost:4000/2021/12/15/ca-control/" >Atomic control<i class="fas fa-external-link-alt"></i></a>的逻辑写了read_align()和write_align()。</p><p>read_align中判断Written==0时，如果没有owner、或者owner是自己，可以写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(owner==<span class="number">0</span> || owner==tr-&gt;id)&#123;</span><br><span class="line">  <span class="keyword">uint_least64_t</span> not_written = owner &lt;&lt; <span class="number">32</span> | epoch | valid;</span><br><span class="line">  <span class="keyword">if</span>(atomic_compare_exchange_strong(cur_control, &amp;not_written, written_and_is_owner))&#123;</span><br><span class="line">    <span class="comment">// write the content at source into the writable copy;</span></span><br><span class="line">    write_writable_copy(source, segment, index);</span><br><span class="line">    <span class="comment">// return the transaction can continue;</span></span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是测试时，transaction量一两千还能过，10000就过不了了。</p><p>反而↓这样可以过：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(atomic_compare_exchange_strong(cur_control, &amp;load_control, written_and_is_owner))&#123;</span><br><span class="line">  <span class="comment">// write the content at source into the writable copy;</span></span><br><span class="line">  write_writable_copy(source, segment, index);</span><br><span class="line">  <span class="comment">// return the transaction can continue;</span></span><br><span class="line">  flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是它并不符合原本的思路，因为可能会将第一个读成功的owner覆盖。就很奇怪。</p><h1 id="重读"><a href="#重读" class="headerlink" title="重读"></a>重读</h1><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-16 PM8.58.31.jpg"                      width=600                ><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-16 PM8.59.01.jpg"                      width=600                ><p>感觉会有问题的很可能是access set，上次分析只用记录第一个读或写成功的id，但是为什么实际中即使写覆盖了读也可以成功呢？</p><p>假设在某一个align，tr1、tr2读了旧值，此时如果tr3写了新值，tr1、tr2以及任何除tr3以外的transaction都不能再读。也就是说，写过的位置，只有写者可读。这其实是符合read_word()伪代码的。并且，如果tr1、tr2后面不再读这个值，可以提交并linearize到tr3开始之前；反之，如果它们后面还要读这个值，就会读失败，进而被abort。所以也是符合linearizable的。</p><p>难道access set只用记录第一个写成功的？上次跟TA确认了一下，access set只用记一个id，似乎确实没仔细问是第一个读成功、还是写成功。</p><p>那么按照新的逻辑分析，第一个读或写成功，还是都记入owner，只不过读成功的owner可以被覆盖。</p><p>可如果能够覆盖，read owner和other还有什么用呢？（其实现在这版代码里面也压根没用到other）如果直接把read_align中设置owner和other的代码注释掉，还能跑吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">⎪ #worker threads:     4</span><br><span class="line">⎪ #TX per worker:      10000</span><br><span class="line">⎪ #repetitions:        7</span><br><span class="line">⎪ Initial #accounts:   128</span><br><span class="line">⎪ Expected #accounts:  1024</span><br></pre></td></tr></table></figure><p>…用↑参数测了几次，多数能过，少数Violated isolation or atomicity。也就是说other还是有用的。</p><p>再看下project description中对access set的描述：</p><blockquote><p>The “access set” of read-write transaction(s) which have accessed the word in the current epoch. Do not implement an actual set in any (optimized) implementation: this set will only be used to tell whether a transaction can write to the word. Namely, if at least one other transaction has accessed (i.e. read or written) this word in the same epoch, the write cannot happen. Said differently, if two transactions are in the access set, it doesn’t matter which one they are.</p></blockquote><p>现在迷惑的点就是：</p><ol><li>如果有另一个transaction也访问过，还能不能写？</li><li>现在的代码里到底判断了other没？</li></ol><p>2应该是没有的，加个输出可以发现，即使有other还是有时写成功了。那为什么可以过呢？难道是意外？多测几次还真偶尔有Violated isolation or atomicity！</p><p>好吧，虽然project又变成了未完成状态，但至少没有逻辑错的代码能跑对、逻辑(以为)对的代码跑不通的尴尬情况了。</p><p>那么接下来的问题就是，为什么逻辑(以为)对的代码跑不通？更准确的是，为什么在transaction量较大时跑不通？</p><h1 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h1><h2 id="CAS-fail-when-equal"><a href="#CAS-fail-when-equal" class="headerlink" title="CAS fail when equal"></a>CAS fail when equal</h2><p>打印了一些tm_begin和tm_end的信息，发现当transaction进行了很多、id很大之后，只有tm_begin没有tm_end了，也就是说后面的都没有commit。并且都是一些read/write transaction，它们的write都没有成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[304850 write align] seg_id=8 index=1 flag=0</span><br><span class="line">[304851 tm_begin] is_ro=0</span><br><span class="line">[304821 write align] seg_id=8 index=1 flag=0</span><br><span class="line">[304852 tm_begin] is_ro=0</span><br><span class="line">[304833 write align] seg_id=8 index=1 flag=0</span><br><span class="line">[304853 tm_begin] is_ro=0</span><br><span class="line">[304836 write align] seg_id=8 index=1 flag=0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>发现有一个CAS中，明明expected值和control中的值是一样的，但是没有换成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atomic_compare_exchange_strong(cur_control, &amp;not_written, written_and_is_owner)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">not_written=5e0cb00000005 load_control=5e0cb00000005 cur_control=5e0cb00000005 equal=1</span><br></pre></td></tr></table></figure><p>这可就太离谱了！</p><blockquote><p><a class="link"   href="https://stackoverflow.com/questions/35534305/compare-exchange-strong-failing-despite-data-matching-expected-value" >compare_exchange_strong failing despite data matching expected value<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://stackoverflow.com/questions/66566810/why-does-compare-exchange-strong-fail-with-stdatomicdouble-stdatomicfloa" >Why does compare_exchange_strong fail with std::atomic, std::atomic in C++?<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>可能是由padding导致的。这就很尴尬了。</p><h3 id="尝试1"><a href="#尝试1" class="headerlink" title="尝试1"></a>尝试1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint_least64_t not_written = owner &lt;&lt; 32 | valid;</span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint_least64_t not_written = load_control &amp; 0xFFFFFFFFFFFFFFF9;</span><br></pre></td></tr></table></figure><p>不行</p><h3 id="尝试2"><a href="#尝试2" class="headerlink" title="尝试2"></a>尝试2</h3><p>这是真的很离谱啊！打印出来的判断就是相等啊！这换不了能怎么办啊？？？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;DEBUG4 not_written=%lx load_control=%lx cur_control=%lx equal=%d test=%d\n&quot;</span>, not_written, load_control, load, not_written==load, atomic_load(cur_control)==not_written);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DEBUG4 not_written=3e1a300000005 load_control=3e1a300000005 cur_control=3e1a300000005 equal=1 test=1</span><br><span class="line">[254371 write align] seg_id=8 index=1 flag=0 cond=4</span><br><span class="line">[254373 tm_begin] is_ro=0</span><br><span class="line">DEBUG4 not_written=3e1a400000005 load_control=3e1a400000005 cur_control=3e1a400000005 equal=1 test=1</span><br><span class="line">[254372 write align] seg_id=8 index=1 flag=0 cond=4</span><br><span class="line">[254374 tm_begin] is_ro=0</span><br><span class="line">DEBUG4 not_written=3e1a500000005 load_control=3e1a500000005 cur_control=3e1a500000005 equal=1 test=1</span><br></pre></td></tr></table></figure><p>难道是uint_least64_t的问题？它和memcpy的比较方法不一样？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_t a = (size_t)not_written;</span><br></pre></td></tr></table></figure><p>强制转成size_t然后比就好了？？？那之前担心位数不对，还特地搞个uint_least64_t，简直是离了个大谱。</p><h2 id="too-long"><a href="#too-long" class="headerlink" title="too long"></a>too long</h2><p>改好上面这个离谱的bug之后，当transaction太多还是会跑不完。打印输出看还是write_align不成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[370371 tm_begin] is_ro=0</span><br><span class="line">[370371 write align] seg_id=8 index=1 flag=0 cond=4 lc=5a6c300000005, cc=5a6c300000005</span><br><span class="line">[370372 tm_begin] is_ro=0</span><br><span class="line">[370372 write align] seg_id=8 index=1 flag=0 cond=4 lc=5a6c400000005, cc=5a6c400000005</span><br><span class="line">[370373 tm_begin] is_ro=0</span><br><span class="line">[370373 write align] seg_id=8 index=1 flag=0 cond=4 lc=5a6c500000005, cc=5a6c500000005</span><br><span class="line">[370374 tm_begin] is_ro=0</span><br><span class="line">[370374 write align] seg_id=8 index=1 flag=0 cond=4 lc=5a6c600000005, cc=5a6c600000005</span><br><span class="line">[370375 tm_begin] is_ro=0</span><br><span class="line">[370375 write align] seg_id=8 index=1 flag=0 cond=4 lc=5a6c700000005, cc=5a6c700000005</span><br></pre></td></tr></table></figure><p>全部都是有other read冲突</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[215647 read align] seg_id=7 index=0 lc=0 cc=34a5f00000000</span><br><span class="line">[215647 read align] seg_id=7 index=1 lc=1 cc=34a5f00000001</span><br><span class="line">[215647 read align] seg_id=8 index=0 lc=0 cc=34a5f00000000</span><br><span class="line">[215647 read align] seg_id=8 index=1 lc=1 cc=34a5f00000001</span><br><span class="line">[215647 read align] seg_id=9 index=0 lc=1 cc=34a5f00000001</span><br><span class="line">[215647 read align] seg_id=9 index=1 lc=0 cc=34a5f00000000</span><br><span class="line">[215647 read align] seg_id=9 index=2 lc=0 cc=34a5f00000000</span><br><span class="line">[215647 read align] seg_id=9 index=3 lc=1 cc=34a5f00000001</span><br><span class="line">[215647 read align] seg_id=8 index=1 lc=34a5f00000001 cc=34a5f00000005</span><br></pre></td></tr></table></figure><p>发现一个逻辑错误，owner是自己时仍设了other。</p><p>这下算是修了一个逻辑上的大bug，再上服务器测测。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-16 PM10.51.17.jpg"                      width=600                ><p>成功！虽然没有变快，但至少逻辑上合理了，不像之前那么虚了。</p><hr><p>所以之前那么大一个bug是怎么过的测试啊就离谱，今天真是满头问号。而且之前逻辑都没对就写优化，那可不是写了个寂寞。幸亏优化的思路现在是很清晰了，毕竟revert、重写都搞了好几遍了。虽然不知道这些优化到底能不能正向优化，但还是想试试，就是很好奇，而且毕竟都花了这么多时间了。</p><p>顺便把<a href="https://coconutnutx.github.io/2021/12/15/ca-control/">Atomic control</a>更新一下。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>reference的逻辑还是很正确的</li><li>bug确实是自己写的bug</li><li>除了c的atomic_compare_exchange_strong，值较大时，期望值和实际值一样但换不成功，是真的离谱</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上次&lt;a href=&quot;https://coconutnutx.github.io/2021/11/28/ca-project/&quot;&gt;CA project 思路笔记&lt;/a&gt;分析一个位置是否可以读写的状态：&lt;/p&gt;
&lt;img  
                     lazy
      
    
    </summary>
    
    
      <category term="Debug" scheme="https://coconutnutx.github.io/categories/Debug/"/>
    
    
      <category term="concurrent_algorithm" scheme="https://coconutnutx.github.io/tags/concurrent-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>CA project Atomic control</title>
    <link href="https://coconutnutx.github.io/2021/12/15/ca-control/"/>
    <id>https://coconutnutx.github.io/2021/12/15/ca-control/</id>
    <published>2021-12-15T16:37:29.000Z</published>
    <updated>2021-12-15T16:37:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>Project中为了标识transactional memory中每一个align的状态，需要一个control structure，这里用了一个64bit的atomic interger来存这些信息。</p><p>通过一次CAS完成对状态的判断和修改，避免加锁。</p><h1 id="Control设计"><a href="#Control设计" class="headerlink" title="Control设计"></a>Control设计</h1><table><thead><tr><th>占用bit</th><th>32</th><th>20</th><th>9</th><th>1</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>名称</td><td>Owner</td><td>Epoch</td><td>留空</td><td>Other</td><td>Written</td><td>Valid</td></tr><tr><td>描述</td><td>本轮第一个read或write成功的transaction的id</td><td>当前轮数</td><td></td><td>是否有其它transaction访问</td><td>是否被写</td><td>A或B哪个有效</td></tr></tbody></table><h1 id="Control-masks"><a href="#Control-masks" class="headerlink" title="Control masks"></a>Control masks</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> VALID_MASK = <span class="number">0x1</span>;         <span class="comment">// 0: A is valid    1: B is valid</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> WRITE_MASK = <span class="number">0x1</span> &lt;&lt; <span class="number">1</span>;    <span class="comment">// 0: not written   1: written</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> OTHER_MASK = <span class="number">0x1</span> &lt;&lt; <span class="number">2</span>;    <span class="comment">// 0: no other read 1: has other read</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> EPOCH_MASK = <span class="number">0xFFFFF000</span>;</span><br></pre></td></tr></table></figure><h1 id="Control-macros"><a href="#Control-macros" class="headerlink" title="Control macros"></a>Control macros</h1><p>有时需要直接读atomic interger。其他时候，先读一次，然后直接对读到的值进行操作，可以减少atomic_load()次数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_FLAG_SIGN(control, flag) ((atomic_load(control) &amp; flag) != 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_FLAG_SIGN_LOADED(load_control, flag) ((load_control &amp; flag) != 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_FLAG_LOADED(load_control, flag) (load_control &amp; flag)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_EPOCH_LOADED(load_control) (load_control &amp; EPOCH_FLAG)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_OWNER(control) ((atomic_load(control)) &gt;&gt; 32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_OWNER_LOADED(load_control) (load_control &gt;&gt; 32)</span></span><br></pre></td></tr></table></figure><h1 id="read-align逻辑"><a href="#read-align逻辑" class="headerlink" title="read_align逻辑"></a>read_align逻辑</h1><ol><li><p>If 已经被写过，只有owner可以读（且Other应该为空，因为Other和Written不肯能同时为1）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expected: Owner==id; Epoch==epoch; Other==0; Written==1; Valid==valid</span><br></pre></td></tr></table></figure></li><li><p>If 没有被写过</p><ol><li><p>If owner==0，尝试抢占（可能会出现竞争而失败）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expected: Owner==0;  Epoch==epoch; Other==0; Written==0; Valid==valid</span><br><span class="line">Desired:  Owner==id; Epoch==epoch; Other==0; Written==0; Valid==valid</span><br></pre></td></tr></table></figure></li><li><p>Else if owner==自己，直接读（owner不会被修改，也只有自己可能写）</p></li><li><p>Else if owner==别人</p><ol><li><p>If 尝试设Other</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expected: Owner==owner; Epoch==epoch; Other==0; Written==0; Valid==valid</span><br><span class="line">Desired:  Owner==owner; Epoch==epoch; Other==1; Written==0; Valid==valid</span><br></pre></td></tr></table></figure></li><li><p>Else if 读到已经被设了Other</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expected: Owner==owner; Epoch==epoch; Other==1; Written==0; Valid==valid</span><br></pre></td></tr></table></figure><p>如果读到Other为1，owner也不能再写这个align了，所以可以放心读。</p></li></ol></li></ol></li></ol><h1 id="write-align逻辑"><a href="#write-align逻辑" class="headerlink" title="write_align逻辑"></a>write_align逻辑</h1><ol><li><p>If 已经被写过，只有owner可以写，且不能有other</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expected: Owner==id; Epoch==epoch; Other==0; Written==1; Valid==valid</span><br></pre></td></tr></table></figure></li><li><p>If 没有被写过</p><ol><li><p>已经是owner可以写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expected: Owner==id; Epoch==epoch; Other==0; Written==0; Valid==valid</span><br><span class="line">Desired:  Owner==id; Epoch==epoch; Other==0; Written==1; Valid==valid</span><br></pre></td></tr></table></figure></li><li><p>抢到owner可以写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expected: Owner==0;  Epoch==epoch; Other==0; Written==0; Valid==valid</span><br><span class="line">Desired:  Owner==id; Epoch==epoch; Other==0; Written==1; Valid==valid</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>Note：如果写成功了，本轮中control的值将不会再发生改变</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Project中为了标识transactional memory中每一个align的状态，需要一个control structure，这里用了一个64bit的atomic interger来存这些信息。&lt;/p&gt;
&lt;p&gt;通过一次CAS完成对状态的判断和修改，避免加锁。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="concurrent_algorithm" scheme="https://coconutnutx.github.io/tags/concurrent-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>CA project 常用操作</title>
    <link href="https://coconutnutx.github.io/2021/12/12/ca-project/"/>
    <id>https://coconutnutx.github.io/2021/12/12/ca-project/</id>
    <published>2021-12-12T22:42:37.000Z</published>
    <updated>2021-12-12T22:42:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>很久没用C了，还有一些同步相关的操作，记录一下。</p><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>分配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">region</span>* <span class="title">region</span> =</span> (struct region*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct region));</span><br><span class="line"><span class="keyword">if</span> (unlikely(!region)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分配（且内存按align排列）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (posix_memalign(&amp;(region-&gt;start), align, size) != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">free</span>(region);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填零</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(region-&gt;start, <span class="number">0</span>, size);</span><br></pre></td></tr></table></figure><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>填值&amp;取值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define index</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> align;</span><br><span class="line">    <span class="keyword">uint8_t</span>* index;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// init index</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;cnt; i++)&#123;</span><br><span class="line">  <span class="keyword">size_t</span>* p = (<span class="keyword">size_t</span>*)(segment-&gt;index + i*align);</span><br><span class="line">  *p = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get index</span></span><br><span class="line"><span class="keyword">size_t</span> index = *(<span class="keyword">size_t</span>*)(address)</span><br></pre></td></tr></table></figure><p>🌰</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find segment and index</span></span><br><span class="line"><span class="keyword">size_t</span> index = *(<span class="keyword">size_t</span>*)(address);</span><br><span class="line"><span class="keyword">size_t</span> offset = index * region-&gt;align + <span class="keyword">sizeof</span>(struct segment);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment</span>* <span class="title">segment</span> =</span> (struct segment*)((<span class="keyword">uint8_t</span>*)address - offset);</span><br></pre></td></tr></table></figure><p>指针的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>** p_addr;</span><br><span class="line">    <span class="keyword">size_t</span>* p_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set</span></span><br><span class="line">*(s-&gt;p_addr + index) = address;    <span class="comment">// void* address</span></span><br><span class="line">*(s-&gt;p_num + index) = size;        <span class="comment">// size_t size</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get</span></span><br><span class="line"><span class="keyword">void</span>* addr = *(p_addr + i);</span><br><span class="line"><span class="keyword">size_t</span> size = *(p_num + i);</span><br></pre></td></tr></table></figure><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>设置mask</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> MASK = <span class="number">0x0001</span> &lt;&lt; <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>获取mask下的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_FLAG(control, mask) ((atomic_load(control) &amp; mask) != 0)</span></span><br></pre></td></tr></table></figure><p>设置高位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control |= id &lt;&lt; <span class="number">32</span>;</span><br></pre></td></tr></table></figure><p>获取高位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint_least64_t</span> id = control &gt;&gt; <span class="number">32</span>;</span><br></pre></td></tr></table></figure><h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h1><h2 id="锁和条件变量"><a href="#锁和条件变量" class="headerlink" title="锁和条件变量"></a>锁和条件变量</h2><blockquote><p>reference “lock.h” “lock.c”</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lock_init</span><span class="params">(struct <span class="keyword">lock_t</span>* lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pthread_mutex_init(&amp;(lock-&gt;mutex), <span class="literal">NULL</span>) == <span class="number">0</span></span><br><span class="line">        &amp;&amp; pthread_cond_init(&amp;(lock-&gt;cv), <span class="literal">NULL</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_cleanup</span><span class="params">(struct <span class="keyword">lock_t</span>* lock)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_destroy(&amp;(lock-&gt;mutex));</span><br><span class="line">    pthread_cond_destroy(&amp;(lock-&gt;cv));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lock_acquire</span><span class="params">(struct <span class="keyword">lock_t</span>* lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pthread_mutex_lock(&amp;(lock-&gt;mutex)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_release</span><span class="params">(struct <span class="keyword">lock_t</span>* lock)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_unlock(&amp;(lock-&gt;mutex));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_wait</span><span class="params">(struct <span class="keyword">lock_t</span>* lock)</span> </span>&#123;</span><br><span class="line">    pthread_cond_wait(&amp;(lock-&gt;cv), &amp;(lock-&gt;mutex));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_wake_up</span><span class="params">(struct <span class="keyword">lock_t</span>* lock)</span> </span>&#123;</span><br><span class="line">    pthread_cond_broadcast(&amp;(lock-&gt;cv));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h2><p><a class="link"   href="https://en.cppreference.com/w/c/atomic/atomic_load" >atomic_load<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://en.cppreference.com/w/cpp/atomic/atomic_store" >atomic_store<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://en.cppreference.com/w/c/atomic/atomic_fetch_add" >atomic_fetch_add<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://en.cppreference.com/w/c/atomic/atomic_compare_exchange" >atomic_compare_exchange<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很久没用C了，还有一些同步相关的操作，记录一下。&lt;/p&gt;
&lt;h1 id=&quot;内存&quot;&gt;&lt;a href=&quot;#内存&quot; class=&quot;headerlink&quot; title=&quot;内存&quot;&gt;&lt;/a&gt;内存&lt;/h1&gt;&lt;p&gt;分配&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;ta
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="concurrent_algorithm" scheme="https://coconutnutx.github.io/tags/concurrent-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>关于Localized Causal Broadcast</title>
    <link href="https://coconutnutx.github.io/2021/12/09/lcb/"/>
    <id>https://coconutnutx.github.io/2021/12/09/lcb/</id>
    <published>2021-12-09T12:33:01.000Z</published>
    <updated>2021-12-09T12:33:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>DA project submission #2 要求实现Localized Causal Broadcast，具体的定义在project repo的README中</p><blockquote><ul><li>You must implement this on top of uniform reliable broadcast (URB).</li><li>The <code>CONFIG</code> command-line argument for this algorithm consists of a file that contains an integer <code>m</code> in its first line. <code>m</code> defines how many messages each process should broadcast.</li><li>For a system of <code>n</code> processes, there are <code>n</code> more lines in the <code>CONFIG</code> file. Each line <code>i</code> corresponds to process <code>i</code>, and such a line indicates the identities of other processes which can affect process <code>i</code>. See the example below.<ul><li>The FIFO property still needs to be maintained by localized causal broadcast. That is, messages broadcast by the same process must not be delivered in a different order then they were broadcast.</li><li>The output format for localized causal broadcast remains the same as before.<br>Example of <code>CONFIG</code> file for a system of <code>5</code> processes, where each one broadcasts <code>m</code> messages:</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m</span><br><span class="line">1 4 5</span><br><span class="line">2 1</span><br><span class="line">3 1 2</span><br><span class="line">4</span><br><span class="line">5 3 4</span><br></pre></td></tr></table></figure><p><em>Note</em>: Lines should end in <code>\n</code>, and numbers are separated by white-space characters.</p><p>In this example we specify that process <code>1</code> is affected by messages broadcast by processes <code>4</code> and <code>5</code>. Similarly, we specify that process <code>2</code> is only affected by process <code>1</code>. Process <code>4</code> is not affected by any other processes. Process <code>5</code> is affected by processes <code>3</code> and <code>4</code>.</p><p>We say that a process <code>x</code> is affected by a process <code>z</code> if all the messages which process <code>z</code> broadcasts and which process <code>x</code> delivers become dependencies for all future messages broadcast by process <code>x</code>. We call these dependencies <em>localized</em>. If a process is not affected by any other process, messages it broadcasts only depend on its previously broadcast messages (due to the FIFO property).</p><p><em>Note</em>:  In the default causal broadcast (this algorithm will be discussed in one of the lectures) each process affects <code>all</code> processes. In this algorithm we can selectively define which process affects some other process.</p></blockquote><h1 id="关于dependency"><a href="#关于dependency" class="headerlink" title="关于dependency"></a>关于dependency</h1><p>process is affected by other processes，但消息的dependency是对每一条消息而言的。</p><p>（当用书上的vector clock方法实现时）也就是说，每一条LCB层消息在broadcast的时间点，需要拿到这个时间点、当前进程的vector clock，作为自己的dependency clock。可以作为消息内容传给其它process。</p><p>其它process收到消息，判断能否deliver，即判断自己的vector clock是否大于消息的dependency clock。</p><h1 id="关于FIFO"><a href="#关于FIFO" class="headerlink" title="关于FIFO"></a>关于FIFO</h1><p>根据sequence number可以保证FIFO。</p><p>基于vector clock也可以保证FIFO。</p><p>对于其它进程，都是在deliver消息时，增加该进程对应的vector clock值。</p><p>对于当前进程，可以做一些调整，在broadcast消息时就修改对应的vector clock值。</p><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># in process 1</span><br><span class="line">b 1 [0 . .]</span><br><span class="line">b 2 [1 . .]</span><br></pre></td></tr></table></figure><p>那么其它进程收到2时，必须先deliver 1。</p><p>可以保证当前进程广播的每一条消息，都有不同的vector clock（即使当前进程没有affected by任何进程），从而保证FIFO。</p><p>这样在deliver的时候，可以统一处理vector clock，而不用管sequence number。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;DA project submission #2 要求实现Localized Causal Broadcast，具体的定义在project repo的README中&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;You must implement this on t
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="distributed_algorithm" scheme="https://coconutnutx.github.io/tags/distributed-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>CA project debug记录</title>
    <link href="https://coconutnutx.github.io/2021/12/06/ca-debug/"/>
    <id>https://coconutnutx.github.io/2021/12/06/ca-debug/</id>
    <published>2021-12-06T10:09:23.000Z</published>
    <updated>2021-12-06T10:09:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="惨痛经验"><a href="#惨痛经验" class="headerlink" title="惨痛经验"></a>惨痛经验</h1><h2 id="Start-easy"><a href="#Start-easy" class="headerlink" title="Start easy"></a>Start easy</h2><p>第一步，加锁，把Transactional Memory的功能写对。</p><ul><li>测试报错Transactional library takes too long to process the transactions，是功能就不对，和线程数量、transaction数量、print没什么关系。</li><li>要把这个报错的阈值调大，修改grading里的slow_factor即可。刚开始可以直接改到1024。</li></ul><p>先不要写什么优化，把基础功能写对，否则debug直接de到吐血</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><ol><li>read_word()和write_write()虽然是照着project desciption写，但还是很容易出错，要很很很小心！</li><li>free的时机需要注意，有时候free后再读并不是一眼就能看出来，bug藏得比较隐蔽。</li></ol><h2 id="Debug-Segmentation-fault"><a href="#Debug-Segmentation-fault" class="headerlink" title="Debug Segmentation fault"></a>Debug Segmentation fault</h2><p>Segmentation fault常用debug操作：core dump（虚拟机环境不同，流程可能不一样，这里用了和DA project一样的ubuntu，最大的坑是找不到core）</p><ol><li><p>设置</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited</span><br><span class="line">ulimit -a</span><br></pre></td></tr></table></figure></li><li><p>run</p></li><li><p>找到core文件</p><blockquote><p><a class="link"   href="https://askubuntu.com/questions/966407/where-do-i-find-the-core-dump-in-ubuntu-16-04lts" >Where do I find the core dump in ubuntu 16.04LTS?<i class="fas fa-external-link-alt"></i></a></p></blockquote></li><li><p>设权限</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /var/lib/apport/</span><br><span class="line">sudo chmod 777 coredump/</span><br></pre></td></tr></table></figure></li><li><p>core移动到grading文件夹</p></li><li><p>debug</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb grading core</span><br></pre></td></tr></table></figure><p> gdb中常用</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where</span><br></pre></td></tr></table></figure></li></ol><hr><p>除了以上悲伤的故事，也有一些可喜可贺的习惯，给debug带了了巨大帮助，要继续保持：</p><ol><li>每一部分debug输出用参数控制，可以很方便的开关。</li><li>经常commit。避免debug变成写bug时，回退都无处可退。</li></ol><hr><p>备注：下文所有TM指的是Transactional Memory，不是口吐芬芳。</p><h1 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h1><p>写完read、write等基础操作，先加了个全局锁，放到虚拟机里测一下逻辑。</p><h2 id="atomic-load时segmentation-fault"><a href="#atomic-load时segmentation-fault" class="headerlink" title="atomic_load时segmentation fault"></a>atomic_load时segmentation fault</h2><p>本地跑没问题，但是虚拟机里make build-libs run就Segmentation fault。一番折腾后，定位到是atomic interger的问题。用atomic_store或者atomic_load的时候就会报错。</p><h3 id="尝试1"><a href="#尝试1" class="headerlink" title="尝试1"></a>尝试1</h3><p>在计算control structure的偏移量时，第一个segment没转(void*)，于是取地址出了问题，atomic_load时就崩了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">void</span>*)segment+segment-&gt;offset_control+CONTROL_SIZE*index</span><br></pre></td></tr></table></figure><p>改成这样本地跑又取不到了，就离谱</p><h3 id="尝试2（结构体指针）"><a href="#尝试2（结构体指针）" class="headerlink" title="尝试2（结构体指针）"></a>尝试2（结构体指针）</h3><p>怀疑是结构体指针的问题，打印了一下相关的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct segment* segment;</span><br><span class="line"></span><br><span class="line">DEBUG segment=0x7fb229405a30</span><br><span class="line">DEBUG (uint8_t*)segment=0x7fb229405a30</span><br><span class="line">DEBUG (void*)segment=0x7fb229405a30</span><br><span class="line">DEBUG &amp;segment=0x7ffedfedf530</span><br></pre></td></tr></table></figure><p>前三个是一样的，符合预期。那么计算偏移量的时候是否也一样？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DEBUG offset=208</span><br><span class="line"></span><br><span class="line">DEBUG segment+offset=0x7fb22940b530</span><br><span class="line">DEBUG (uint8_t*)segment+offset=0x7fb229405b00</span><br><span class="line">DEBUG (void*)segment+offset=0x7fb229405b00</span><br></pre></td></tr></table></figure><p>这里算出来就不一样了</p><p>b530-5a30 = 0x5b00 = 23296 = 208 * 112<br>而112正好是struct segment的大小，所以不转换直接加，单位是struct size</p><p>5b00-5a30 = 0xd0 = 208<br>这样就是对的，所以应该先转换指针类型</p><p>那么尝试1加了(void*)应该方向是对的</p><h2 id="control修改错误"><a href="#control修改错误" class="headerlink" title="control修改错误"></a>control修改错误</h2><p>接上一个bug，改完之后，发现set control owner出现问题，没有set成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[owner=0 v=0 w=0 s=0]</span><br></pre></td></tr></table></figure><p>写内存成功了，在函数内部打印control也是对的，但是结束之后整体print region时，control是空的</p><p>解决：<br>打印发现两次用control时地址不一样。是后面算control起始地址没有改过来，仍是直接算的，没有用定义的宏</p><p>改过来之后顺便检查了一遍，所有计算control地址的位置，都是用宏</p><h2 id="batch间reset-control后segmentation-fault"><a href="#batch间reset-control后segmentation-fault" class="headerlink" title="batch间reset control后segmentation fault"></a>batch间reset control后segmentation fault</h2><p>目前本地测试一轮中的transaction没什么问题，但是tm_end()、调用batcher_cleanup()之后，打印region出错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--------segment1--------</span><br><span class="line">[0] 00000000 | 11111111 [owner=0 v=1 w=0 s=0]</span><br><span class="line">[1] 00000000 | 11111111 [owner=0 v=1 w=0 s=0]</span><br><span class="line">[2] 00000000 | 22222222 [owner=0 v=1 w=0 s=0]</span><br><span class="line">[3] 00000000 | 22222222 [owner=0 v=1 w=0 s=0]</span><br><span class="line">--------segment0--------</span><br><span class="line">zsh: segmentation fault  ./tm.o</span><br></pre></td></tr></table></figure><p>应该是segment2，而不是0</p><h3 id="尝试1-1"><a href="#尝试1-1" class="headerlink" title="尝试1"></a>尝试1</h3><p>在batch_cleanup()中打印了一下segment id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(segment)&#123;</span><br><span class="line">        clean_up_segment(segment);</span><br><span class="line">        segment = segment-&gt;next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>发现第二次是0<br>可能是segment指针的问题<br>但是print_region()里面也有这个循环，没有问题，那边是这样写的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(segment != NULL)&#123;</span><br><span class="line">        print_segment(segment);</span><br><span class="line">        segment = segment-&gt;next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总不能是!=NULL的问题吧<br>试了一下，果然不是</p><h3 id="尝试2"><a href="#尝试2" class="headerlink" title="尝试2"></a>尝试2</h3><p>在batcher_cleanup()的循环里加了强制类型转换，好了一次，再测又不行了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">segment = (struct segment*)(segment-&gt;next);</span><br></pre></td></tr></table></figure><h3 id="尝试3（内存分配）"><a href="#尝试3（内存分配）" class="headerlink" title="尝试3（内存分配）"></a>尝试3（内存分配）</h3><p>打印region和segment的地址都是对的，但是为什么读出来东西就不对呢？</p><p>仔细看了下两块segment的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--------segment1-------- addr=0x7f9bc9c05a30</span><br><span class="line">[0] 00000000 | 11111111 [owner=1 v=0 w=1 s=1]</span><br><span class="line">[1] 00000000 | 11111111 [owner=1 v=0 w=1 s=1]</span><br><span class="line">[2] 00000000 | 22222222 [owner=1 v=0 w=1 s=1]</span><br><span class="line">[3] 00000000 | 22222222 [owner=1 v=0 w=1 s=1]</span><br><span class="line">--------segment2-------- addr=0x7f9bc9c05b30</span><br></pre></td></tr></table></figure><p>a30和b30这才隔了256，肯定会撞吧！难道是一开始分配就有问题？</p><p>初始化时的代码是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment</span>* <span class="title">segment</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> total_size = <span class="keyword">sizeof</span>(struct segment) + size*<span class="number">3</span> + size/align*<span class="keyword">sizeof</span>(<span class="keyword">atomic_uint_least64_t</span>);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(posix_memalign((<span class="keyword">void</span>**)&amp;segment, align, total_size) != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create_segment failed. cannot align memory.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看了下reference代码，先malloc的region，后面才posix_memalign的segment</p><p>改成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> total_size = <span class="keyword">sizeof</span>(struct segment) + size*<span class="number">3</span> + size/align*<span class="keyword">sizeof</span>(<span class="keyword">atomic_uint_least64_t</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">segment</span>* <span class="title">segment</span> =</span> (struct segment*) <span class="built_in">malloc</span>(total_size);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(posix_memalign((<span class="keyword">void</span>**)&amp;segment, align, total_size) != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create_segment failed. cannot align memory.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 成功！</p><p> 现在的地址是<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--------segment1-------- addr=0x7fde98405b20</span><br><span class="line">[0] 00000000 | 11111111 [owner=0 v=1 w=0 s=0]</span><br><span class="line">[1] 00000000 | 11111111 [owner=0 v=1 w=0 s=0]</span><br><span class="line">[2] 00000000 | 22222222 [owner=0 v=1 w=0 s=0]</span><br><span class="line">[3] 00000000 | 22222222 [owner=0 v=1 w=0 s=0]</span><br><span class="line">--------segment2-------- addr=0x7fde98405d10</span><br><span class="line">[0] 00000000 | 00000000 [owner=0 v=0 w=0 s=0]</span><br><span class="line">[1] 00000000 | 00000000 [owner=0 v=0 w=0 s=0]</span><br><span class="line">[2] 00000000 | 00000000 [owner=0 v=0 w=0 s=0]</span><br><span class="line">[3] 00000000 | 00000000 [owner=0 v=0 w=0 s=0]</span><br></pre></td></tr></table></figure><br>d10-b20 = 0x1f0 = 496</p><h2 id="阶段一测试"><a href="#阶段一测试" class="headerlink" title="阶段一测试"></a>阶段一测试</h2><p>丢进虚拟机跑grading<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-06 PM11.54.31.jpg"                      width=600                ><br>用时太久，正常。但是没有segmentation fault了，应该read write操作也没什么问题了，第一步完成！耶！</p><p>停掉了一些print，减少不必要的时间浪费，测TM相关函数</p><h2 id="malloc错误"><a href="#malloc错误" class="headerlink" title="malloc错误"></a>malloc错误</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[batcher_cleanup] region addr=0x7f1bc8000b20</span><br><span class="line">[batcher_cleanup] clean segment 1, addr=0x7f1bc8001530</span><br><span class="line">grading: malloc.c:2401: sysmalloc: Assertion `(old_top == initial_top (av) &amp;&amp; old_size == 0) || ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp; prev_inuse (old_top) &amp;&amp; ((unsigned long) old_end &amp; (pagesize - 1)) == 0)&#x27; failed.</span><br><span class="line">Makefile:40: recipe for target &#x27;run&#x27; failed</span><br></pre></td></tr></table></figure><p>像是个和内存分配有关的bug</p><blockquote><p>Why do I get a C malloc assertion failure?<br>检查clean_up_segment里的循环</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;segment-&gt;size; i++)</span><br></pre></td></tr></table></figure><p>终止条件写成了segment-&gt;size，应该是size/align<br>解决！</p><h2 id="时间太长"><a href="#时间太长" class="headerlink" title="时间太长"></a>时间太长</h2><p>现在grading输出是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[write]tx_id=1 seg_id=1 index=63 size=8</span><br><span class="line">[write]tx_id=1 seg_id=1 index=64 size=8</span><br><span class="line">[write]tx_id=1 seg_id=1 index=65 size=8</span><br><span class="line">[write]tx_id=1 seg_id=1 index=66 size=8</span><br><span class="line">[tm_end] id=1</span><br><span class="line"></span><br><span class="line">[batcher_cleanup]region addr=0x7f3a18000b20</span><br><span class="line">transaction created. id=2 addr=0x7f3a18001e30</span><br><span class="line">[read]tx_id=2 seg_id=1 index=3 size=8</span><br><span class="line">⎪ *** EXCEPTION ***</span><br><span class="line">⎩ Transactional library takes too long to process the transactions</span><br></pre></td></tr></table></figure><p>可能是用时太长，也可能是read有问题，先检查后者</p><p>单独打了一下read的输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[read align]tx_id=2 seg_id=1 index=64</span><br><span class="line">[read align]tx_id=2 seg_id=1 index=65</span><br><span class="line">[read align]tx_id=2 seg_id=1 index=66</span><br><span class="line">⎪ *** EXCEPTION ***</span><br><span class="line">⎩ Transactional library takes too long to process the transactions</span><br></pre></td></tr></table></figure><p>可以跑，那应该就是用时太长的问题，而不是逻辑问题<br>那么接下来就可以开始改并发相关的代码了</p><h1 id="虚假的阶段二"><a href="#虚假的阶段二" class="headerlink" title="虚假的阶段二"></a>虚假的阶段二</h1><p>前面基本测试了TM的read、write、alloc功能，现在把全局锁换成batcher</p><h2 id="时间太长-1"><a href="#时间太长-1" class="headerlink" title="时间太长"></a>时间太长</h2><p>现在的问题是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">⎪ *** EXCEPTION ***</span><br><span class="line">⎩ Transactional library takes too long to process the transactions</span><br><span class="line">Makefile:40: recipe for target &#x27;run&#x27; failed</span><br></pre></td></tr></table></figure><h3 id="尝试1-2"><a href="#尝试1-2" class="headerlink" title="尝试1"></a>尝试1</h3><p>把参数调小了还是很慢<br>看了下具体输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">transaction created. id=32 addr=0x7f35dc00d3d0 log_size=100</span><br><span class="line">[enter] current blocking length=1</span><br><span class="line">[read]tx_id=32 seg_id=1 index=3 size=8</span><br><span class="line">transaction created. id=33 addr=0x7f35dc00da40 log_size=100</span><br><span class="line">[enter] current blocking length=1</span><br></pre></td></tr></table></figure><p>似乎batcher的enter有问题，blocking length不对</p><p>…<br>一开始初始化把1写成0了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> const_zero = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> const_one = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="尝试2（逻辑错误）"><a href="#尝试2（逻辑错误）" class="headerlink" title="尝试2（逻辑错误）"></a>尝试2（逻辑错误）</h3><p>改batcher、换回锁，总是第一个transaction可以跑到batcher cleanup，第二批就不行，也许是中间清理有问题<br>但是本地测试并打印region，应该没问题</p><p>在虚拟机里加入了具体的R/W输出，发现第二轮的read卡住了<br>继续查发现read没问题，但是read之后write就写不进去了<br>发现是逻辑问题：写的时候，如果还没写过，会尝试gain_owner，但是如果自己已经读过了，需要判断owner是自己</p><p>但是虚拟机里跑还是不对，第一次read align返回了，但是没有后续了<br>发现是tm_read()最后应该return flag，写成了return false🤪</p><p>现在报错变成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">⎩ Violated isolation or atomicity</span><br></pre></td></tr></table></figure><p>终于可以进行下一步了</p><h1 id="阶段一’"><a href="#阶段一’" class="headerlink" title="阶段一’"></a>阶段一’</h1><h2 id="Violated-isolation-or-atomicity"><a href="#Violated-isolation-or-atomicity" class="headerlink" title="Violated isolation or atomicity"></a>Violated isolation or atomicity</h2><p>现在还是直接加锁，atomicity有问题只能是逻辑问题，一夜回到阶段一，又得开始找read、write、alloc的bug</p><p>多次测试，报错有2种，一个是violate atomicity，另一个是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[tm_begin 2]</span><br><span class="line">[tm_end 2]</span><br><span class="line">[tm_begin 3]</span><br><span class="line">[tm_end 3]</span><br><span class="line">[tm_begin 4]</span><br><span class="line">[tm_end 4]</span><br><span class="line">⎪ *** EXCEPTION ***</span><br><span class="line">⎩ Transactional library takes too long to process the transactions</span><br></pre></td></tr></table></figure><h3 id="尝试1-3"><a href="#尝试1-3" class="headerlink" title="尝试1"></a>尝试1</h3><p>怀疑是segment的问题，因为本地没怎么测alloc、free<br>但是加了输出，发现并没有调过这两个函数</p><h3 id="尝试2-1"><a href="#尝试2-1" class="headerlink" title="尝试2"></a>尝试2</h3><p>奇怪了，看输出没什么问题，到底是哪卡住了？<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-09 AM10.17.59.jpg"                      width=600                ><br>另一种情况是，可以继续跑，跑到最后violate atomicity</p><p>定位到一个bug！先read再write没有写write_flag！<br>但是对这里影响不大</p><h3 id="尝试3（逻辑错误）"><a href="#尝试3（逻辑错误）" class="headerlink" title="尝试3（逻辑错误）"></a>尝试3（逻辑错误）</h3><p>定位到yigebug！先write再read，读的是旧值！这个问题比较严重<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-09 AM10.48.06.jpg"                      width=600                ></p><p>现在的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read the writable copy into target</span></span><br><span class="line">read_readable_copy(target, segment, index);</span><br></pre></td></tr></table></figure><p> 这明显调的函数都和注释写的意思不一样啊🤪</p><h2 id="时间太长-2"><a href="#时间太长-2" class="headerlink" title="时间太长"></a>时间太长</h2><p> 现在的报错都是时间太长，会不会是其它线程被堵太久了？</p><p>把线程减到1个，大部分还是时间太长，有一个跑完了！感动！<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-09 AM11.03.47.jpg"                      width=600                ></p><p>把Slow trigger factor从8调到1024，都跑完了！感动！<br>也就是说，单线程的时候，read write没问题了！（测试里好像没有alloc free？）</p><p>改到2个线程，也可以跑！呜呜呜呜呜</p><p>一波未平一波又起，此时虚拟机出现了bug<br>罢了，做饭去</p><p>下午。<br>把grading的参数全部调回默认，除了slow_factor设成1024<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-09 PM2.43.00.jpg"                      width=600                ><br>对了对了！可以开始写batcher了！</p><h1 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h1><p>开始测batcher，这次要一步、一步、一步来</p><h2 id="Too-long"><a href="#Too-long" class="headerlink" title="Too long"></a>Too long</h2><p>开四个线程时，有时会卡住<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-10 PM4.45.21.jpg"                      width=600                ><br>感觉是某个transaction时间太长导致的</p><p>发现问题！如果有操作abort了，用户不会调tm_end</p><p>在read write失败时调leave()，解决</p><h2 id="没有core文件"><a href="#没有core文件" class="headerlink" title="没有core文件"></a>没有core文件</h2><p>想用coredump debug，运行显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make: *** [run] Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure><p>但是没有core文件</p><p>最后在↓的最后一个回答找到解决<br><a class="link"   href="https://askubuntu.com/questions/966407/where-do-i-find-the-core-dump-in-ubuntu-16-04lts" >Where do I find the core dump in ubuntu 16.04LTS?<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>found the core dunp in /var/lib/apport/coredump/</p></blockquote><p>core在不同文件夹，想移到同一个文件夹比较方便，拖的时候permission denied，先改了下权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 coredump/</span><br></pre></td></tr></table></figure><p>然后就可以debug了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb grading core</span><br></pre></td></tr></table></figure><p>发现是leave()的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#0  0x00007f13e809812c in leave ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br><span class="line">[Current thread is 1 (Thread 0x7f13e929c700 (LWP 1903))]</span><br></pre></td></tr></table></figure><p>但是没有显示行号，在编译时加-g（改Makefile）也不行</p><h2 id="Violated-isolation-or-atomicity-1"><a href="#Violated-isolation-or-atomicity-1" class="headerlink" title="Violated isolation or atomicity"></a>Violated isolation or atomicity</h2><p>添加了read log、write log、transaction log，加锁测试通过，改成batcher后报错</p><p>发现1或2个线程时，结果正确，4个线程会出错</p><p>发现竟然是因为开着DEBUG_READ和DEBUG_WRITE，可能是写debug output时同时访问，但是没有做同步控制，导致出错。关掉输出就好了</p><h2 id="Violated-consistency"><a href="#Violated-consistency" class="headerlink" title="Violated consistency"></a>Violated consistency</h2><p>现在大部分时间没问题，有时会出这个错</p><p>重新读了一下consistency的定义。难道是如果process读了一个值，后面这个值被改了，也得abort？但是如果被读过，这个值后面应该不能修改了。</p><h3 id="尝试1-4"><a href="#尝试1-4" class="headerlink" title="尝试1"></a>尝试1</h3><p>也许是因为read align和write align中，有时有多个判断，这些判断单独都是atomic的，但是合在一起就不是了。<br>改了一些逻辑，合并判断和交换，还是不对。</p><h3 id="尝试2-2"><a href="#尝试2-2" class="headerlink" title="尝试2"></a>尝试2</h3><p>在workload.hpp里加了一堆输出，打印具体是哪里出错，发现一个常见问题是check()中counter!=0<br>可是这个counter是什么鬼？</p><figure class="highlight hpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shared&lt;<span class="keyword">size_t</span>&gt; counter&#123;tx, tm.<span class="built_in">get_start</span>()&#125;;</span><br></pre></td></tr></table></figure><p> 找到定义<br> <figure class="highlight hpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">       Shared&lt;<span class="keyword">size_t</span>&gt;         count; <span class="comment">// Number of allocated accounts in this segment</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">/** Binding constructor.</span></span><br><span class="line"><span class="comment">        * @param tx      Associated pending transaction</span></span><br><span class="line"><span class="comment">        * @param address Block base address</span></span><br><span class="line"><span class="comment">       **/</span></span><br><span class="line">       <span class="built_in">AccountSegment</span>(Transaction&amp; tx, <span class="keyword">void</span>* address): count&#123;tx, address&#125;, next&#123;tx, count.<span class="built_in">after</span>()&#125;, parity&#123;tx, next.<span class="built_in">after</span>()&#125;, accounts&#123;tx, parity.<span class="built_in">after</span>()&#125; &#123;&#125;</span><br></pre></td></tr></table></figure><br>好像和transaction数量有关，会不会是最后没有free？<br>并不是。</p><p>1或2个线程的时候没事，3个以上出错，难道是OTHER的问题？<br>又检查了一遍逻辑感觉也没什么毛病</p><h3 id="尝试3"><a href="#尝试3" class="headerlink" title="尝试3"></a>尝试3</h3><p>现有的2个报错分别是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">------WL5------ counter=16</span><br><span class="line">[1011 leave]&#123;979&#125; committed=1 remain=0 blocked=0</span><br><span class="line">[1011 tm_end]</span><br><span class="line">⎩ Violated consistency</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">------WL1------ sum=61</span><br><span class="line">------WL1------ init_balance=10</span><br><span class="line">------WL1------ count=6</span><br><span class="line">Violated isolation or atomicity</span><br></pre></td></tr></table></figure><p>后者似乎导致了前者，需要先解决。<br>一个现象是，每次差的值都是1，而不会更大<br>加到8个线程会出现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">------WL1------ sum=637</span><br><span class="line">------WL1------ init_balance=10</span><br><span class="line">------WL1------ count=64</span><br></pre></td></tr></table></figure><p>总之基本偏差不大，像是哪里有个细节不对，但是到底在哪啊💥</p><p>但是counter最后的的偏差又很大…</p><p>把transaction数量减小之后，只发现Violated consistency，而没有Violated isolation or atomicity，不会是哪里溢出了吧？<br>就10和100的区别，也不至于啊。</p><h3 id="尝试4"><a href="#尝试4" class="headerlink" title="尝试4"></a>尝试4</h3><p>又开始读workload.hpp，这个count应该就是所有segment里面account值的和，加起来应该等于预期。那么这个值错了，其实还是read、write的问题。</p><p>给read、write加锁，还是同样的报错。那么难道是batcher的问题？</p><p>又多打了一点输出，上面Violated isolation or atomicity这个问题都是出现在 Long read-only transaction, summing the balance of each account中，其实也就是在检查实际进行操作的short transaction的结果是否正确。</p><p>再想想，参数小的时候，出错误一，参数大的时候，出一和二，那么还是应该一是更根本的。而一的关键在于counter，最后应该为0。那么这个counter到底是个什么啊？？？</p><h3 id="尝试5（CAS条件）"><a href="#尝试5（CAS条件）" class="headerlink" title="尝试5（CAS条件）"></a>尝试5（CAS条件）</h3><p>仔细读输出，找到了一个bug！！！一下午了，终于见到实际的bug在哪了！！！第一次见到bug这么激动。</p><p>有write之后，竟然又读成功，还改了owner，简直离谱。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-12 PM5.57.15.jpg"                      width=600                ></p><p>多加了一些输出，轻松复现这个bug。都是有2个transaction，A读写位置1、位置2，B在A之后读写位置3、位置2。正确情况应该是B读写位置2失败，但是现在 成功了。</p><p>问题在于read_align()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if the word has not been written in the current epoch then</span></span><br><span class="line"><span class="comment">// add the transaction into the “access set” (if not already in); </span></span><br><span class="line"><span class="comment">// try set owner</span></span><br><span class="line"><span class="keyword">uint_least64_t</span> read_and_set_owner = tr-&gt;id &lt;&lt; <span class="number">32</span> | valid;</span><br><span class="line"><span class="keyword">if</span>(atomic_compare_exchange_strong(cur_control, &amp;load_control, read_and_set_owner))</span><br></pre></td></tr></table></figure><p>比较的expected值不应该是load到的值！而是判断如果owner是自己，应该是的值。</p><h2 id="Reset错误"><a href="#Reset错误" class="headerlink" title="Reset错误"></a>Reset错误</h2><p>改完这个又发现一个bug<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-12 PM7.41.39.jpg"                      width=600                ><br>A写了位置9，之后B也想写位置9但没写成功，最后没有交换valid。<br>也就是说，B先退出，调用clean flag，此时由于B没有成功，直接将control清空了，9写的WRITE_FLAG也没有了。<br>加一个判断，只有自己是owner时才reset，应该可以解决问题。</p><p>现在没有Violated isolation or atomicity的问题了（或者没碰到）。<br>暂时测试可以正常跑完了。</p><h1 id="阶段三"><a href="#阶段三" class="headerlink" title="阶段三"></a>阶段三</h1><p>batcher的功能写对了（但愿），接下来尝试在服务器上跑通（20 threads和10000 transaction per worker）。</p><h2 id="Floating-point-exception"><a href="#Floating-point-exception" class="headerlink" title="Floating point exception"></a>Floating point exception</h2><p>为了避免每次clean segments遍历整个内存，将修改过的地方记了log，但是上服务器log会爆掉。<br>改成了overflow的时候realloc四倍空间</p><p>然后就出现了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make: *** [run] Floating point exception (core dumped)</span><br></pre></td></tr></table></figure><h3 id="尝试1-5"><a href="#尝试1-5" class="headerlink" title="尝试1"></a>尝试1</h3><p>gdb grading core一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[New LWP 2519]</span><br><span class="line">[New LWP 2518]</span><br><span class="line">[New LWP 2509]</span><br><span class="line">Core was generated by `./grading 453 ../reference.so ../338094.so&#x27;.</span><br><span class="line">Program terminated with signal SIGSEGV, Segmentation fault.</span><br><span class="line">#0  0x00007f34bc478f31 in ?? ()</span><br><span class="line">[Current thread is 1 (LWP 2517)]</span><br><span class="line">(gdb) where</span><br><span class="line">#0  0x00007f34bc478f31 in ?? ()</span><br><span class="line">#1  0x0000000000000387 in ?? ()</span><br><span class="line">#2  0x00007f34b8000b20 in ?? ()</span><br><span class="line">#3  0x0000000000000006 in ?? ()</span><br></pre></td></tr></table></figure><p>…说了个寂寞</p><h3 id="尝试2（free之后）"><a href="#尝试2（free之后）" class="headerlink" title="尝试2（free之后）"></a>尝试2（free之后）</h3><p>发现是上次设置的core dump参数在虚拟机重启后没有了，需要重新再来一遍。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited</span><br><span class="line">ulimit -a</span><br></pre></td></tr></table></figure><p>权限也要重设。<br>然后就可以看core dump文件了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Program terminated with signal SIGFPE, Arithmetic exception.</span><br><span class="line">#0  0x00007f8a4a5c30d8 in tm_read ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br><span class="line">[Current thread is 1 (Thread 0x7f8a4b7c6700 (LWP 2112))]</span><br><span class="line">(gdb) where</span><br><span class="line">#0  0x00007f8a4a5c30d8 in tm_read ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br><span class="line">#1  0x00005582a6470496 in TransactionalMemory::read (this=&lt;optimized out&gt;, </span><br><span class="line">    this=&lt;optimized out&gt;, target=0x7f8a4b7c47c0, size=8, </span><br><span class="line">    source=0x7f8a44008210, tx=&lt;optimized out&gt;) at transactional.hpp:231</span><br><span class="line">#2  Transaction::read (target=0x7f8a4b7c47c0, size=8, source=0x7f8a44008210, </span><br><span class="line">    this=0x7f8a4b7c47d0) at transactional.hpp:312</span><br><span class="line">#3  Shared&lt;unsigned long&gt;::read (this=&lt;synthetic pointer&gt;)</span><br><span class="line">    at transactional.hpp:394</span><br><span class="line">#4  Shared&lt;unsigned long&gt;::operator unsigned long (this=&lt;synthetic pointer&gt;)</span><br><span class="line">    at transactional.hpp:398</span><br></pre></td></tr></table></figure><p>竟然是read里面浮点异常？read里面浮点都没有啊哪来的异常？？？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Core was generated by `./grading 453 ../reference.so ../338094.so&#x27;.</span><br><span class="line">Program terminated with signal SIGFPE, Arithmetic exception.</span><br><span class="line">#0  0x00007f7533dfd9c8 in clean_log ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br><span class="line">[Current thread is 1 (Thread 0x7f754080d700 (LWP 3303))]</span><br><span class="line">(gdb) where</span><br><span class="line">#0  0x00007f7533dfd9c8 in clean_log ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br><span class="line">#1  0x00007f7533dfdaae in clean_transaction ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br><span class="line">#2  0x00007f7533dfdb23 in batcher_cleanup ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br><span class="line">#3  0x00007f7533dfdbf8 in leave ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br><span class="line">#4  0x00007f7533dfde2d in tm_end ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br></pre></td></tr></table></figure><p>这次在clean_log()里，还靠谱点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[clean_log] size=8</span><br><span class="line">[clean_log] align=0</span><br></pre></td></tr></table></figure><p>好家伙！真是除0啊！</p><p>打印发现segment id是0，明显是访问到了不该访问的segment，要么是起始地址算错了，要么是遍历错了。</p><p>会不会是clean了已经被free的segment啊？<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-12 PM9.55.00.jpg"                      width=600                ><br>果然！</p><p>所以是因为，read、write的时候写了log，一轮结束的时候根据log里的地址去重设control。但是可能其中有的segment已经被free掉了。</p><p>改成defer到tm_destroy再free segment，成功！<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-12 PM11.17.52.jpg"                                      ></p><h2 id="Segmentation-fault"><a href="#Segmentation-fault" class="headerlink" title="Segmentation fault"></a>Segmentation fault</h2><p>上服务器跑一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ERROR] write log overflow!⎪ *** EXCEPTION ***</span><br><span class="line">⎩ Transactional library takes too long to process the transactions</span><br></pre></td></tr></table></figure><p>log写死512不够。</p><p>试图在虚拟机里复现bug，参数调到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto const nbworkers = 4;</span><br><span class="line">auto const nbtxperwrk    = 160000ul / nbworkers;</span><br><span class="line">auto const nbaccounts    = 32 * nbworkers;</span><br><span class="line">auto const expnbaccounts = 256 * nbworkers;</span><br></pre></td></tr></table></figure><p>时，又出现了Segmentation fault，查看core</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Program terminated with signal SIGSEGV, Segmentation fault.</span><br><span class="line">#0  0x00007fe97e5faa00 in clean_log ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br><span class="line">[Current thread is 1 (Thread 0x7fe97ffff700 (LWP 1476))]</span><br></pre></td></tr></table></figure><p>是log的问题</p><p>奇怪的是，打开clean的debug输出后，报错变成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[batcher_cleanup] total=2</span><br><span class="line">[3 clean #write=1 #read=0]</span><br><span class="line">[2 clean #write=129 #read=0]</span><br><span class="line">[batcher_cleanup] total=1</span><br><span class="line">[5 clean #write=0 #read=2]</span><br><span class="line">[batcher_cleanup] total=1</span><br><span class="line">[6 clean #write=0 #read=2]</span><br><span class="line">⎪ *** EXCEPTION ***</span><br><span class="line">⎩ Transactional library takes too long to process the transactions</span><br></pre></td></tr></table></figure><p>先把slow factor调成1024</p><p>发现有时候read log满了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[78516 clean #write=0 #read=512]</span><br><span class="line">[batcher_cleanup] done.</span><br><span class="line">batch round -&gt; 32924</span><br><span class="line">[batcher_cleanup] total=1</span><br><span class="line">[78517 clean #write=0 #read=512]</span><br><span class="line">[batcher_cleanup] done.</span><br><span class="line">batch round -&gt; 32925</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">batch round -&gt; 56620</span><br><span class="line">[77895 tm_begin] is_ro=0</span><br><span class="line">[ERROR] read log overflow! tr_id=77894 is_ro=1</span><br><span class="line">[77896 tm_begin] is_ro=1</span><br><span class="line">[ERROR] read log overflow! tr_id=77893 is_ro=1</span><br><span class="line">[77897 tm_begin] is_ro=1</span><br></pre></td></tr></table></figure><p>不是设置过read only不写log吗？发现代码里没有，可能是前面哪次debug回退删掉了🤪</p><p>重新加入判断：is_ro时不写log、不清理，成功！</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-13 AM11.45.34.jpg"                      width=600                ><p>现在跑↑这个参数可以过了！可喜可贺！</p><h2 id="log-overflow"><a href="#log-overflow" class="headerlink" title="log overflow"></a>log overflow</h2><p>上服务器！</p><p>write log overflow😭</p><p>512，不够<br>1024，不够<br>2048，不够！</p><p>虚拟机调成相同的参数试试。至少有一个好消息，虚拟机的报错现在和服务器一样了！也就是说， 可以直接在虚拟机上测试一下log的大小。</p><p>可是虚拟机2048够了啊？见鬼。</p><p>等等…刚才上服务器改了参数忘记重新打包zip了…2048重新试一次</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-13 PM12.03.39.jpg"                      width=600                ><p>啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊！！！！！！！！！！！！！！！！</p><p>虚拟机1024也能过，要不上服务器再试一次。果不其然！过了！哈哈哈哈哈！</p><h1 id="Milestone"><a href="#Milestone" class="headerlink" title="Milestone"></a>Milestone</h1><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-13 PM12.16.39.jpg"                      width=600                ><p>太感动了！</p><p>第一次过，绿色，竟然有1.6！活过来了！</p><p>从11/28开始写这个版本，断断续续写到今天12/13，差不多两周，终于，及格了😭😭😭<br>（虽然中间还写了个DA project submission3，DA可真是太友善了，我爱Java）</p><h1 id="阶段四"><a href="#阶段四" class="headerlink" title="阶段四"></a>阶段四</h1><p>尝试改进，提高性能。</p><p>-&gt; <a href="https://coconutnutx.github.io/2021/12/16/ca-condition/">CA project 状态分析&amp;debug</a></p><h2 id="BoundedOverrun"><a href="#BoundedOverrun" class="headerlink" title="BoundedOverrun"></a>BoundedOverrun</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terminate called after throwing an instance of &#x27;Exception::BoundedOverrun&#x27;</span><br></pre></td></tr></table></figure><p>发现是优化逻辑后read_only transaction没有free</p><h1 id="Memcheck"><a href="#Memcheck" class="headerlink" title="Memcheck"></a>Memcheck</h1><p>下面主要是用Valgrind检查内存泄漏时的问题。</p><p>解决上面的问题后还有泄露：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">==2068== 32 bytes in 1 blocks are still reachable in loss record 1 of 2</span><br><span class="line">==2068==    at 0x4C33B25: calloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">==2068==    by 0x4E3F7F4: _dlerror_run (dlerror.c:140)</span><br><span class="line">==2068==    by 0x4E3F050: dlopen@@GLIBC_2.2.5 (dlopen.c:87)</span><br><span class="line">==2068==    by 0x10DEE7: TransactionalLibrary::TransactionalLibrary(char const*) (in /home/dcl/Desktop/CS453-2021-project-main/grading/grading)</span><br><span class="line">==2068==    by 0x10B25C: main (in /home/dcl/Desktop/CS453-2021-project-main/grading/grading)</span><br><span class="line">==2068== </span><br><span class="line">==2068== 2,448 bytes in 51 blocks are definitely lost in loss record 2 of 2</span><br><span class="line">==2068==    at 0x4C31B0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">==2068==    by 0x859A0D9: ???</span><br><span class="line">==2068==    by 0x10E12D: Transaction::Transaction(TransactionalMemory const&amp;, Transaction::Mode) (in /home/dcl/Desktop/CS453-2021-project-main/grading/grading)</span><br><span class="line">==2068==    by 0x10F425: auto transactional&lt;WorkloadBank::long_tx(unsigned long&amp;) const::&#123;lambda(Transaction&amp;)#1&#125;&gt;(TransactionalMemory const&amp;, Transaction::Mode, WorkloadBank::long_tx(unsigned long&amp;) const::&#123;lambda(Transaction&amp;)#1&#125;&amp;&amp;) [clone .constprop.125] (in /home/dcl/Desktop/CS453-2021-project-main/grading/grading)</span><br><span class="line">==2068==    by 0x110A7A: WorkloadBank::run(unsigned long, unsigned long) const (in /home/dcl/Desktop/CS453-2021-project-main/grading/grading)</span><br><span class="line">==2068==    by 0x10D376: measure(Workload&amp;, unsigned int, unsigned int, unsigned long, unsigned long, unsigned long, unsigned long)::&#123;lambda(unsigned int)#1&#125;::operator()(unsigned int) const (in /home/dcl/Desktop/CS453-2021-project-main/grading/grading)</span><br><span class="line">==2068==    by 0x531E6DE: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.25)</span><br><span class="line">==2068==    by 0x50496DA: start_thread (pthread_create.c:463)</span><br><span class="line">==2068==    by 0x5CC171E: clone (clone.S:95)</span><br></pre></td></tr></table></figure><p>应该是read only在read失败时，不会调用tm_end，所以应该就地free。</p><p>果然。迅速解决！耶！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;惨痛经验&quot;&gt;&lt;a href=&quot;#惨痛经验&quot; class=&quot;headerlink&quot; title=&quot;惨痛经验&quot;&gt;&lt;/a&gt;惨痛经验&lt;/h1&gt;&lt;h2 id=&quot;Start-easy&quot;&gt;&lt;a href=&quot;#Start-easy&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Debug" scheme="https://coconutnutx.github.io/categories/Debug/"/>
    
    
      <category term="concurrent_algorithm" scheme="https://coconutnutx.github.io/tags/concurrent-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>DA project 总结</title>
    <link href="https://coconutnutx.github.io/2021/12/01/project-review/"/>
    <id>https://coconutnutx.github.io/2021/12/01/project-review/</id>
    <published>2021-12-01T07:06:31.000Z</published>
    <updated>2021-12-01T07:06:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>基于UDP Socket，实现Perfect Links -&gt; Uniform Reliable Broadcast -&gt; FIFO Broadcast application和Localized Causal Broadcast</p><h1 id="Perfect-Links层"><a href="#Perfect-Links层" class="headerlink" title="Perfect Links层"></a>Perfect Links层</h1><p>点对点的通信，测试时跑n个process，给其中一个发m条消息。</p><p>需要满足的性质：</p><ul><li>Reliable delivery -&gt; 如果发送、接收方都正确，每一条发出的消息最终都会被接收方deliver</li><li>No duplication -&gt; 不重复deliver</li><li>No creation -&gt; 不凭空产生消息<h2 id="主要的几个类"><a href="#主要的几个类" class="headerlink" title="主要的几个类"></a>主要的几个类</h2></li></ul><ol><li>PerfectLinks<ul><li>调用SocketClient发消息</li><li>检查并deliver，向上(URB)indicate</li></ul></li><li>SocketClient<ul><li>创建并发送Socket（包括普通消息和ACK）</li></ul></li><li>SocketServer（单独的线程）<ul><li>监听Socket，收到消息时，交给SocketServerHandler处理</li></ul></li><li>SocketServerHandler（单独的线程）<ul><li>处理收到的消息，向上(PerfectLinks)indicate</li></ul></li><li>MessageResender（单独的线程）<ul><li>定时检查并重发消息<h2 id="保证Reliable-delivery"><a href="#保证Reliable-delivery" class="headerlink" title="保证Reliable delivery"></a>保证Reliable delivery</h2>通过ACK实现。PerfectLinks发送消息后，维持一个pending集合，用于存所有已经发送、但还没有收到ACK的消息，收到ACK后将消息移出。MessageResender定时检查这个集合，重发其中的所有消息。<h2 id="保证No-duplication"><a href="#保证No-duplication" class="headerlink" title="保证No duplication"></a>保证No duplication</h2>维持一个delivered集合即可。<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2>SocketServerHandler用到线程池，防止同时收到消息太多时炸掉。<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2>可能会出现冲突的是pending和delivered，用ConcurrentHashMap实现。<h2 id="SEQ细节"><a href="#SEQ细节" class="headerlink" title="SEQ细节"></a>SEQ细节</h2>上层的消息有一个SEQ，创建之后不会改变，且在后面的广播中，发送给每一个process的SEQ都是一样的。而PL层需要区分发给不同process的SEQ，于是加入了PSEQ。PerfectLinks有一个AtomicInteger，每次创建消息时getAndIncrement得到PSEQ。<h1 id="Uniform-Reliable-Broadcast层"><a href="#Uniform-Reliable-Broadcast层" class="headerlink" title="Uniform Reliable Broadcast层"></a>Uniform Reliable Broadcast层</h1>每个process对其他所有process广播m条消息，需满足的性质：</li></ul></li></ol><ul><li>Validity -&gt; 如果一个正确的process广播了一条消息，它最终会deliver这条消息</li><li>No duplication</li><li>No creation</li><li>Agreement -&gt; 如果某个正确的process deliver了一条消息，最终所有的process都会deliver这条消息<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2>UniformReliableBroadcast类调用PerfectLinks对每一个process发送消息。<h2 id="保证Agreement"><a href="#保证Agreement" class="headerlink" title="保证Agreement"></a>保证Agreement</h2>测试环境保证了至少一半的process是正确的，基于这个假设，只要确保大多数process收到消息即可。</li></ul><p>每次broadcast或收到一条新消息后，加入pending。收到新消息还需要转发，即再次广播这条消息，此时SEQ是不变的，消息中需要含有creator id和sender id。</p><p>对pending中的每一条消息，统计从哪些不同的sender处收到了这条消息（此处收到消息，类似PL层收到ACK），如果总数过半，即可deliver。</p><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>上述统计用到BitSet实现。对pending中的每条消息，用一个BitSet记录从哪些id收到了这条消息。</p><p>当总数过半，deliver之后，消息可以从pending中移出。转而加入delivered中，此时不需要保留之前的统计信息，记录一个SEQ就够了。</p><h1 id="FIFO-Broadcast-application层"><a href="#FIFO-Broadcast-application层" class="headerlink" title="FIFO Broadcast application层"></a>FIFO Broadcast application层</h1><p>性质：在URB的基础上，还需保证按序deliver</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>用一个AtomicInteger数组next，记录对于每一个process，当前以及deliver的消息的SEQ。一开始用了PriorityQueue，每次比较顶部和next。后面发现PriorityQueue并发得加锁，于是还是改成了用set记录收到的SEQ，可并发的set通过ConcurrentHashMap.newKeySet()得到。</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>用一个AtomicInteger统计当前process发出、但还没有deliver的消息数量。该数量超过阈值时，暂停发送新消息。</p><h2 id="检查deliver细节"><a href="#检查deliver细节" class="headerlink" title="检查deliver细节"></a>检查deliver细节</h2><p>每次收到消息后，检查pending中来自这条消息creator的，有没有符合要求可以deliver的消息。用到这样一句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(currentPending.remove(currentNext.get()))&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">currentNext.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>currentPending是一个ConcurrentSet，只有remove成功时才会返回true，可以避免并发访问时的冲突。</p><p>至此，从PerfectLinks到FIFO，都不用加synchronized。</p><h1 id="UML-activity-graph-1"><a href="#UML-activity-graph-1" class="headerlink" title="UML activity graph 1"></a>UML activity graph 1</h1><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/DA_fifo_v2.jpg"                                     ><h1 id="Localized-Causal-Broadcast层"><a href="#Localized-Causal-Broadcast层" class="headerlink" title="Localized Causal Broadcast层"></a>Localized Causal Broadcast层</h1><p>性质：在URB的基础上，还需保证causal order<br>例如，1依赖2、3，则当1deliver了2、3的消息m1、m2后，再broadcast新消息m3，那么其它所有process在deliver m3之前，都必须已经deliver了2、3的消息m1、m2。<br>无依赖的消息仍需保证FIFO。</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>用2个AtomicInteger数组，一个是vector clock，当deliver一条消息后，对应的位置+1；另一个是dependency clock，当deliver依赖的消息后，对应的位置+1。发送消息时，同时发送当前的dependency clock。收到消息时，需先解析出消息附带的clock，判断这条消息的所有依赖是否满足，是才可以deliver，否则加入pending。</p><h2 id="2个clock"><a href="#2个clock" class="headerlink" title="2个clock"></a>2个clock</h2><p>区分不同的vector clock和dependency clock，是考虑到以下情况：<br>对于某一个process i，可能broadcast了很多条消息，但都还没有deliver，那么此时vector clock还没有更新。但是对于其它接收消息的process，它们在deliver来自i的消息时，要保证顺序。通过dependency clock可以统一的处理顺序和依赖。<br>（实际上只用一个vector clock记录也行，但是打包和更新有点麻烦，于是干脆就分开了，也只占用process总数个AtomicInteger，可以接受）</p><h2 id="检查deliver"><a href="#检查deliver" class="headerlink" title="检查deliver"></a>检查deliver</h2><p>类似FIFO，仍然是在收到每条消息后，检查对应的creator，是否有来自改creator的消息可以deliver，不同的是需要比较dependency。<br>这里用深度优先遍历的方法，从左到右比较消息的clock和当前的vector clock，如果全部满足，deliver该消息并返回true。如果缺少依赖，先看能否解决依赖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkDeliver</span><span class="params">(<span class="keyword">int</span> createrId)</span></span>&#123;</span><br><span class="line">        ConcurrentHashMap&lt;Integer, URBMessage&gt; currentPending = pending.get(createrId);</span><br><span class="line">        <span class="keyword">boolean</span> hasDeilivered = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// traverse according to SEQ of this creator</span></span><br><span class="line">        <span class="keyword">while</span>(currentPending.containsKey(vectorClock[createrId-<span class="number">1</span>].get()+<span class="number">1</span>))&#123;</span><br><span class="line">            URBMessage urbMessage = currentPending.get(vectorClock[createrId-<span class="number">1</span>].get()+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// check dependency</span></span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=totalHost; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vectorClock[i-<span class="number">1</span>].get() &lt; urbMessage.vectorClock[i-<span class="number">1</span>])&#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="keyword">false</span>)&#123;</span><br><span class="line">                <span class="comment">// has dependency</span></span><br><span class="line">                System.out.println(<span class="string">&quot;depend on &quot;</span>+i);</span><br><span class="line">                <span class="comment">// check if dependency can be solved</span></span><br><span class="line">                <span class="keyword">if</span>(createrId==myId || checkDeliver(i)==<span class="keyword">false</span>)&#123;</span><br><span class="line">                    <span class="comment">// nothing delivered</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                deliver(urbMessage);</span><br><span class="line">                hasDeilivered = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hasDeilivered;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="UML-activity-graph-2"><a href="#UML-activity-graph-2" class="headerlink" title="UML activity graph 2"></a>UML activity graph 2</h1><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/DA_lcb.jpg"                                     >]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h1&gt;&lt;p&gt;基于UDP Socket，实现Perfect Links -&amp;gt; Uniform Reliable Broadcast -&amp;gt; FI
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="distributed_algorithm" scheme="https://coconutnutx.github.io/tags/distributed-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>DA project 2 validation tool</title>
    <link href="https://coconutnutx.github.io/2021/11/30/validate/"/>
    <id>https://coconutnutx.github.io/2021/11/30/validate/</id>
    <published>2021-11-30T08:40:52.000Z</published>
    <updated>2021-11-30T08:40:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h1><p>‼️ Dependency bug fixed. (10/12)</p><p>‼️ 不测试FIFO</p><p>‼️ 最多9个线程（若要测10+可修改拼接文件名代码）</p><hr><p>为了测试submission2(Localized Causal Broadcast)的输出写了个简陋工具，仅<strong>有限情况</strong>下<strong>测试</strong>用<br>仅！供！参！考！不！保！证！对！</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>如，process 1依赖2、3，和4、5没关系，先找出所有process输出中关于1、2、3的消息，然后统计1 broadcast每条消息时的vector clock，以及其它process deliver每条消息时的vector clock，后者的&gt;=前者。1的输出可以比其它多，此时多的不考虑，只比较前面的部分。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>基本和给的validate_fifo.py差不多<br>把代码、config、output放在同一个文件夹内（即stress.py的所有输出，有多余的没关系）<br>带参数–proc_num运行</p><h2 id="流程示例"><a href="#流程示例" class="headerlink" title="流程示例"></a>流程示例</h2><ol><li>cd到tools</li><li>把validate_lcausal.py放到tools中</li><li>run stress<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python stress.py -r ../template_java/run.sh -t lcausal -l output -p 4 -m 100</span><br><span class="line"></span><br><span class="line">// VM</span><br><span class="line">python3 stress.py -r ../template_java/run.sh -t lcausal -l output -p 4 -m 100</span><br></pre></td></tr></table></figure><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-11-30 AM9.51.22.jpg"                      width='400px'                ></li><li>run validate<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python validate_lcausal.py --proc_num 4</span><br><span class="line"></span><br><span class="line">// VM</span><br><span class="line">python3 validate_lcausal.py --proc_num 4</span><br></pre></td></tr></table></figure><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-01 PM3.03.46.jpg"                      width='600px'                ></li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">config_path = <span class="string">&#x27;./output/config&#x27;</span></span><br><span class="line">output_path = <span class="string">&#x27;./output/proc0&#x27;</span>   <span class="comment"># append id.output later, id&lt;=9</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_config</span>():</span></span><br><span class="line">    f = <span class="built_in">open</span>(config_path,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">    data = f.readlines()</span><br><span class="line">    m = <span class="number">0</span></span><br><span class="line">    <span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> data:</span><br><span class="line">        splited = line.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">            m = <span class="built_in">int</span>(splited[<span class="number">0</span>]) <span class="comment"># how many messages each process should broadcast</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        sender = <span class="built_in">int</span>(splited[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(splited)):</span><br><span class="line">            <span class="built_in">dict</span>.setdefault(sender,[]).append(<span class="built_in">int</span>(splited[i])) <span class="comment"># dependency (including sender itself)</span></span><br><span class="line">        count+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dict</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># find all &#x27;d sender seq&#x27; in output_id, where sender is in depent set</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDependentList</span>(<span class="params"><span class="built_in">id</span>, dset</span>):</span></span><br><span class="line">    cur_output_path = output_path+<span class="built_in">str</span>(<span class="built_in">id</span>)+<span class="string">&#x27;.output&#x27;</span></span><br><span class="line">    f = <span class="built_in">open</span>(cur_output_path,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">    data = f.readlines()</span><br><span class="line">    </span><br><span class="line">    sequence = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> data:</span><br><span class="line">        splited = line.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> splited[<span class="number">0</span>] == <span class="string">&quot;d&quot;</span>: <span class="comment"># only consider diliver</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(splited[<span class="number">1</span>]) <span class="keyword">in</span> dset: <span class="comment"># only consider sender in depent set</span></span><br><span class="line">                sequence.append(line)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(<span class="built_in">id</span>),<span class="string">&#x27;#msg:&#x27;</span>,<span class="built_in">len</span>(sequence))</span><br><span class="line">    <span class="keyword">return</span> sequence</span><br><span class="line"></span><br><span class="line"><span class="comment"># find all &#x27;b seq&#x27; and relevent delivered message in output_id, where sender is in depent set</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDependentListOfCreator</span>(<span class="params"><span class="built_in">id</span>, dset</span>):</span></span><br><span class="line">    cur_output_path = output_path+<span class="built_in">str</span>(<span class="built_in">id</span>)+<span class="string">&#x27;.output&#x27;</span></span><br><span class="line">    f = <span class="built_in">open</span>(cur_output_path,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">    data = f.readlines()</span><br><span class="line">    </span><br><span class="line">    sequence = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> data:</span><br><span class="line">        splited = line.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> splited[<span class="number">0</span>] == <span class="string">&quot;b&quot;</span>:</span><br><span class="line">            sequence.append(line)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(splited[<span class="number">1</span>]) <span class="keyword">in</span> dset:</span><br><span class="line">                sequence.append(line)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(<span class="built_in">id</span>),<span class="string">&#x27;#msg:&#x27;</span>,<span class="built_in">len</span>(sequence))</span><br><span class="line">    <span class="keyword">return</span> sequence</span><br><span class="line">    </span><br><span class="line"><span class="comment"># get vector clock associated with each message created by id from sequence</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getVectorClock</span>(<span class="params">sequence, <span class="built_in">id</span>, proc_num</span>):</span></span><br><span class="line">    clock = []</span><br><span class="line">    msg_clock_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(proc_num+<span class="number">1</span>):</span><br><span class="line">        clock.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> msg <span class="keyword">in</span> sequence:</span><br><span class="line">        splited = msg.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        sender = <span class="built_in">int</span>(splited[<span class="number">1</span>])</span><br><span class="line">        clock[sender]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> sender==<span class="built_in">id</span>:</span><br><span class="line">            msg_clock_list.append(clock.copy())</span><br><span class="line">    <span class="keyword">return</span> msg_clock_list</span><br><span class="line"></span><br><span class="line"><span class="comment"># get vector clock associated with each message broadcasted by id from sequence</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getVectorClockOfCreator</span>(<span class="params">sequence, <span class="built_in">id</span>, proc_num</span>):</span></span><br><span class="line">    clock = []</span><br><span class="line">    msg_clock_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(proc_num+<span class="number">1</span>):</span><br><span class="line">        clock.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> msg <span class="keyword">in</span> sequence:</span><br><span class="line">        splited = msg.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        sender = <span class="built_in">int</span>(splited[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> splited[<span class="number">0</span>]==<span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            clock[sender]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg_clock_list.append(clock.copy())</span><br><span class="line">    <span class="keyword">return</span> msg_clock_list</span><br><span class="line">    </span><br><span class="line"><span class="comment"># check if dependency of id is satisfied in all other process</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkProcessId</span>(<span class="params"><span class="built_in">id</span>, dset</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;checking process&#x27;</span>, <span class="built_in">str</span>(<span class="built_in">id</span>), <span class="string">&#x27;,depend on&#x27;</span>, dset)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># sequence of currrent process</span></span><br><span class="line">    ref_sequence = getDependentListOfCreator(<span class="built_in">id</span>, dset)</span><br><span class="line">    ref_clock = getVectorClockOfCreator(ref_sequence, <span class="built_in">id</span>, proc_num)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>,<span class="string">&#x27;#clock:&#x27;</span>,<span class="built_in">len</span>(ref_clock))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(proc_num):</span><br><span class="line">        cur_id = i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> cur_id != <span class="built_in">id</span>:</span><br><span class="line">            <span class="comment"># sequence of other process</span></span><br><span class="line">            sequence = getDependentList(cur_id, dset)</span><br><span class="line">            <span class="comment"># get vector clock</span></span><br><span class="line">            clock = getVectorClock(sequence, <span class="built_in">id</span>, proc_num)</span><br><span class="line">            <span class="built_in">print</span>(cur_id,<span class="string">&#x27;#clock:&#x27;</span>,<span class="built_in">len</span>(clock))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># number should be less of equal</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(clock)&gt;<span class="built_in">len</span>(ref_clock):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Number exceeds!&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># output should be the same with ref_sequence</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(clock)):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(proc_num+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> ref_clock[i][j] &gt; clock[i][j]:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&#x27;Clock not match!&#x27;</span>)</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&#x27;ref_clock:&#x27;</span>,ref_clock[i])</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&#x27;clock    :&#x27;</span>,clock[i])</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># check output of all processes</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkProcess</span>(<span class="params">proc_num</span>):</span></span><br><span class="line">    depend = read_config()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;dependency:&#x27;</span>,depend,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(proc_num):</span><br><span class="line">        <span class="built_in">id</span> = i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> checkProcessId(<span class="built_in">id</span>, depend[<span class="built_in">id</span>])==<span class="literal">False</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;validate process&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>),<span class="string">&#x27;OK\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line"></span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--proc_num&quot;</span>,</span><br><span class="line">        required=<span class="literal">True</span>,</span><br><span class="line">        dest=<span class="string">&quot;proc_num&quot;</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;Total number of processes&quot;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    results = parser.parse_args()</span><br><span class="line">    </span><br><span class="line">    proc_num = <span class="built_in">int</span>(results.proc_num)</span><br><span class="line">    <span class="keyword">if</span> checkProcess(proc_num):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Validation OK&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Validation failed!&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="关于dependency"><a href="#关于dependency" class="headerlink" title="关于dependency"></a>关于dependency</h1><blockquote><p>We say that a process <code>x</code> is affected by a process <code>z</code> if all the messages which process <code>z</code> broadcasts and which process <code>x</code> delivers become dependencies for all future messages broadcast by process <code>x</code>.</p></blockquote><p>个人理解是，如果</p><ul><li>p1 b 1</li><li>p2 d 1 1</li><li>p1 d 2 1</li><li>p1 d 3 1</li><li>p1 b 2<br>此时p1的dependency是[1 1 1]，p2在d 1 2时需要有这些dependency<br>加入broadcast或deliver每条消息时对应的clock</li><li>p1 b 1 [0 0 0]</li><li>p2 d 1 1 [0 0 0]</li><li>p1 d 2 1</li><li>p1 d 3 1</li><li>p1 b 2 [1 1 1]</li><li>p2 d 3 1</li><li>p2 d 2 1</li><li>p2 d 1 2 [1 1 1]<br>统计时，对reference需要统计broadcast时的clock，而其它需统计deliver时的clock</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Update&quot;&gt;&lt;a href=&quot;#Update&quot; class=&quot;headerlink&quot; title=&quot;Update&quot;&gt;&lt;/a&gt;Update&lt;/h1&gt;&lt;p&gt;‼️ Dependency bug fixed. (10/12)&lt;/p&gt;
&lt;p&gt;‼️ 不测试FIFO&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="distributed_algorithm" scheme="https://coconutnutx.github.io/tags/distributed-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>CA project 思路笔记</title>
    <link href="https://coconutnutx.github.io/2021/11/28/ca-project/"/>
    <id>https://coconutnutx.github.io/2021/11/28/ca-project/</id>
    <published>2021-11-28T13:33:12.000Z</published>
    <updated>2021-11-28T13:33:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>看Project description里给的Dual-versioned transactional memory的一些记录</p><h1 id="关于access-set"><a href="#关于access-set" class="headerlink" title="关于access set"></a>关于access set</h1><h2 id="情况分析"><a href="#情况分析" class="headerlink" title="情况分析"></a>情况分析</h2><p>假设当前A是readable copy，B是writable copy，某一个位置可能出现的一些情况：</p><ol><li>小明读，成功，加入set<ol><li>张三读，成功，加入set<ol><li>小明写，发现张三也在set，失败 <font color="red">只要set里有别人，就不能写了</font></li></ol></li><li>张三写，发现小明已经在set，失败 <font color="red">只要set里有别人，就不能写了</font></li><li>小明写，set里只有自己，成功<ol><li>小明读，发现已经被写过了，自己在set里，成功，读B</li><li>张三读，发现已经被写过了，自己不在set里，失败</li></ol></li></ol></li></ol><h2 id="什么时候可以加入？"><a href="#什么时候可以加入？" class="headerlink" title="什么时候可以加入？"></a>什么时候可以加入？</h2><ol><li>读成功的时候<br> 什么时候可以读？<ol><li>没人写过，随便读，读A</li><li>自己写过，可以读，读B <font color="red">如果是别人写的，自己不可能在set里，不能读</font></li></ol></li><li>写成功的时候<br> 什么时候可以写？<ol><li>没人写过，且set里没别人 <font color="red">只可能有一个人是通过写加入set的</font></li><li>自己写过</li></ol></li></ol><p>从而保证：</p><ol><li>只可能有一个人写</li><li>写过的地方只有写的人能读</li><li>没写过的地方都可以读</li></ol><h2 id="set可以只记第一个"><a href="#set可以只记第一个" class="headerlink" title="set可以只记第一个"></a>set可以只记第一个</h2><p>set里可以只记录第一个加入set的人，因为：</p><ol><li>如果第一个加入set是通过写加入的<ol><li>后面可以通过set判断自己写过，可以继续读写</li><li>其他人发现写过，且不是自己写的，读写都不可以</li></ol></li><li>如果第一个加入set是通过读加入的，<ol><li>别人不能写，因为虽然没人写过，但set里已经有人了</li><li>别人可以读</li><li>自己可以写，自己写过之后，别人也不可以读了<br>这个第一个加入set的，可以视为所有者</li></ol></li></ol><p>🧐project description里面说不要implement an actual set，那么按这个逻辑，只存一个值应该就足够了</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>也就是说，一个位置是否可以读写有以下几种状态：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-11-28 PM2.36.51.jpg"                                     ></p><p>且1状态中，如果没有其他人读过，占有者可写。如果有人读过，则不可写了。</p><p>以上都是针对读写事务，只读事务可以直接读，不影响</p><p>更新<a href="https://coconutnutx.github.io/2021/12/16/ca-condition/">CA project 状态分析</a></p><h2 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h2><p>Q：可能有写成功的，但后续操作失败，如何处理？<br>A：这样的TX不会到commit()，而只有在commit()中可以更改valid copy，因此下一轮中有效的仍是旧的值</p><h1 id="关于batcher"><a href="#关于batcher" class="headerlink" title="关于batcher"></a>关于batcher</h1><p>什么时候调？</p><pre><code>1. 事务开始，调enter() -&gt; 即在tm_begin()中2. 最后一个操作结束时，调leave() -&gt; 即在tm_end()中</code></pre><h2 id="情况分析-1"><a href="#情况分析-1" class="headerlink" title="情况分析"></a>情况分析</h2><ol><li>初始时，remaining=0</li><li>第一个人enter()，remaining变成1</li><li>后面的人enter()，都被挂到blocked</li><li>第一个人leave()，remaining变成0</li><li>counter+1  <font color="red">相当于进入下一轮</font><ul><li>remaining重设为blocked的长度</li><li>叫醒所有blocked里的线程</li><li>清空blocked</li></ul></li><li>此时上一轮中被blocked的线程，在这一轮中一起开始工作。当有新线程调enter()，又会被挂到blocked里，等待下一轮</li></ol><h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>Q：为什么commit()中交换valid copy要推迟到两轮交替的间隙进行？<br>A：保证atomicity</p><p>Q：get_epoch()什么时候用到？是干什么用的？<br>A：优化的时候用</p><h1 id="关于tx-t"><a href="#关于tx-t" class="headerlink" title="关于tx_t"></a>关于tx_t</h1><p>一个事务需要记录的东西：</p><ul><li>boolean 是否成功 <font color="red">如果已经失败了，后面读写的时候可以直接返回</font></li><li>boolean 是否只读 <font color="red">读的时候可以直接读</font></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看Project description里给的Dual-versioned transactional memory的一些记录&lt;/p&gt;
&lt;h1 id=&quot;关于access-set&quot;&gt;&lt;a href=&quot;#关于access-set&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="concurrent_algorithm" scheme="https://coconutnutx.github.io/tags/concurrent-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>更改主题记录</title>
    <link href="https://coconutnutx.github.io/2021/11/16/theme/"/>
    <id>https://coconutnutx.github.io/2021/11/16/theme/</id>
    <published>2021-11-16T11:01:22.000Z</published>
    <updated>2021-11-16T11:01:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直用的<a class="link"   href="https://github.com/Shen-Yu/hexo-theme-ayer" >Ayer<i class="fas fa-external-link-alt"></i></a>主题，突然发现搜索不能用，debug了一早上解决不了，决定干脆换个主题</p><p>尝试过三个主题后<br><a class="link"   href="https://github.com/lh1me/hexo-theme-aomori" >Aomori<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/SukkaW/hexo-theme-suka" >suka<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/XPoet/hexo-theme-keep" >keep<i class="fas fa-external-link-alt"></i></a></p><p>决定用keep<br>太优雅了，搜索也没有bug，妙</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前一直用的&lt;a class=&quot;link&quot;   href=&quot;https://github.com/Shen-Yu/hexo-theme-ayer&quot; &gt;Ayer&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;主题，突然发现搜索不能用，d
      
    
    </summary>
    
    
      <category term="Memo" scheme="https://coconutnutx.github.io/categories/Memo/"/>
    
    
      <category term="tool" scheme="https://coconutnutx.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>sync example note2：memory order</title>
    <link href="https://coconutnutx.github.io/2021/11/13/concurrent2/"/>
    <id>https://coconutnutx.github.io/2021/11/13/concurrent2/</id>
    <published>2021-11-13T09:26:37.000Z</published>
    <updated>2021-11-13T09:26:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>Producer consumer example</p><p>There might be conflict on buffer[], but consumed_until and produced_until prevent that (if used correctly).</p><p>So, only need to make sure consumed_until and produced_until accessed correctly under concurrency.</p><h1 id="Using-locks"><a href="#Using-locks" class="headerlink" title="Using locks"></a>Using locks</h1><p>In each round of produce()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  lock_acquire(&amp;lock);</span><br><span class="line">  <span class="keyword">if</span> (consumed_until + BUFFER_SIZE &gt; r) <span class="keyword">break</span>;</span><br><span class="line">  lock_release(&amp;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">produced[r] = ...</span><br><span class="line">buffer[r % BUFFER_SIZE] = produced[r];</span><br><span class="line">produced_until++;</span><br><span class="line">lock_release(&amp;lock);</span><br></pre></td></tr></table></figure><p>Two locks:</p><ol><li>check if can produce: conflict on consumed_until</li><li>conflict on produced_until</li></ol><p>In each round of consume()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  lock_acquire(&amp;lock);</span><br><span class="line">  <span class="keyword">if</span> (produced_until &gt; r) <span class="keyword">break</span>;</span><br><span class="line">  lock_release(&amp;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumed[r] = buffer[r % BUFFER_SIZE];</span><br><span class="line">consumed_until++;</span><br><span class="line">lock_release(&amp;lock);</span><br></pre></td></tr></table></figure><p>Two locks:</p><ol><li>check if can consume: conflict on produced_until</li><li>conflict on consumed_until</li></ol><h1 id="Using-atomic-vairables"><a href="#Using-atomic-vairables" class="headerlink" title="Using atomic vairables"></a>Using atomic vairables</h1><p>In produce, two locks can be modified:</p><ol><li><p>check if can produce: conflict on consumed_until</p><p>no ordering constraints -&gt; memory_order_relaxed</p></li><li><p>conflict on produced_until</p><p>store produced_until should happen after all operations -&gt; load-store + store-store = release</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// The memory order can be relaxed as we don&#x27;t read anything &quot;produced&quot; by the consumer.</span></span><br><span class="line">  <span class="keyword">int</span> local_cu = atomic_load_explicit(&amp;consumed_until, memory_order_relaxed);</span><br><span class="line">  <span class="keyword">if</span> (local_cu + BUFFER_SIZE &gt; r) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">produced[r] = ...</span><br><span class="line">buffer[r % BUFFER_SIZE] = produced[r];</span><br><span class="line"><span class="comment">// We want to increment &quot;produced_until&quot; after the buffer has been written.</span></span><br><span class="line"><span class="comment">// By using memory_order_release, we prevent the STOREs on buffer from being</span></span><br><span class="line"><span class="comment">// reordered after the atomic operation.</span></span><br><span class="line">atomic_fetch_add_explicit(&amp;produced_until, <span class="number">1</span>, memory_order_release);</span><br></pre></td></tr></table></figure><p>In consume, two locks can be modified:</p><ol><li><p>check if can consume: conflict on produced_until</p><p>load produced_until should happen before all operations -&gt; load-load + load-store = acquire</p></li><li><p>conflict on consumed_until</p><p>store consumed_until should happen after all operations -&gt; load-store + store-store = release</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// We don&#x27;t want to access the buffer before checking the atomic variable.</span></span><br><span class="line">  <span class="comment">// The memory_order_acquire prevents this reordering.</span></span><br><span class="line">  <span class="keyword">int</span> local_pu = atomic_load_explicit(&amp;produced_until, memory_order_acquire);</span><br><span class="line">  <span class="keyword">if</span> (local_pu &gt; r) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumed[r] = buffer[r % BUFFER_SIZE];</span><br><span class="line">atomic_fetch_add_explicit(&amp;consumed_until, <span class="number">1</span>, memory_order_release);</span><br></pre></td></tr></table></figure><h1 id="Memory-barriers"><a href="#Memory-barriers" class="headerlink" title="Memory barriers"></a>Memory barriers</h1><blockquote><p><a class="link"   href="https://en.cppreference.com/w/cpp/atomic/memory_order" >std::memory_order<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://www.modernescpp.com/index.php/fences-as-memory-barriers" >Fences are Memory Barriers<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://www.youtube.com/watch?v=qlkMbxUbKfw&ab_channel=CodeBlacksmith" >Memory Barriers - Learn Modern C++<i class="fas fa-external-link-alt"></i></a></p></blockquote><ul><li><p>memory_order_relaxed: no ordering constraints</p></li><li><p>memory_order_consume</p></li><li><p>memory_order_acquire: load-load + load-store</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-11-13 AM10.59.57.jpg"                                     ></li><li><p>memory_order_release: load-store + store-store</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-11-13 AM11.00.42.jpg"                                     ></li><li><p>memory_order_acq_rel</p></li><li><p>memory_order_seq_cst</p></li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-11-13 AM10.55.43.jpg"                                     ><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-11-13 AM10.57.03.jpg"                                     >]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Producer consumer example&lt;/p&gt;
&lt;p&gt;There might be conflict on buffer[], but consumed_until and produced_until prevent that (if used correct
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="concurrent_algorithm" scheme="https://coconutnutx.github.io/tags/concurrent-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>sync example note1</title>
    <link href="https://coconutnutx.github.io/2021/11/13/concurrent/"/>
    <id>https://coconutnutx.github.io/2021/11/13/concurrent/</id>
    <published>2021-11-13T08:53:44.000Z</published>
    <updated>2021-11-13T08:53:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>Cync example for C concurrent programing</p><h1 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RUNS (4096 * 256)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREADS 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">count</span><span class="params">(<span class="keyword">void</span>* null)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;New thread created\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// declare an array of 4 threads</span></span><br><span class="line">  <span class="keyword">pthread_t</span> handlers[THREADS];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">intptr_t</span> i = <span class="number">0</span>; i &lt; THREADS; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> res = pthread_create(&amp;handlers[i], <span class="literal">NULL</span>, count, <span class="literal">NULL</span>);</span><br><span class="line">    assert(!res);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> res = pthread_join(handlers[i], <span class="literal">NULL</span>);</span><br><span class="line">    assert(!res);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (counter != RUNS * THREADS) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Didn&#x27;t count so well. :/, found %d\n&quot;</span>, counter);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Counted up to %d.\n&quot;</span>, counter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;lock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">count</span><span class="params">(<span class="keyword">void</span>* null)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; RUNS; r++) &#123;</span><br><span class="line">    lock_acquire(&amp;lock);</span><br><span class="line">    counter++;</span><br><span class="line">    lock_release(&amp;lock);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Better version: use lock_wait(&amp;lock) and lock_wake_up(&amp;lock) to prevent bucy wait, but rely on a notification.</p><h1 id="Atomic-variable"><a href="#Atomic-variable" class="headerlink" title="Atomic  variable"></a>Atomic  variable</h1><p>Atomic variables (~atomic registers) do not enforce atomic operation blocks.</p><p>Need to use atomic operation.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">atomic_int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">count</span><span class="params">(<span class="keyword">void</span>* null)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; RUNS; r++) &#123;</span><br><span class="line">    atomic_fetch_add(&amp;counter, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Another example</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> expected = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (atomic_compare_exchange_strong(&amp;leader[r], &amp;expected, tid)) &#123;</span><br><span class="line">atomic_fetch_add(&amp;nb_leaders[r], <span class="number">1</span>); <span class="comment">// used to check correctness</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h1><p>当有include .h时，报错</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang: error: linker command failed with <span class="built_in">exit</span> code <span class="number">1</span></span><br></pre></td></tr></table></figure><p>可以在Terminal</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc election2.c lock.c -o ekection2.o</span><br><span class="line">./election2.o</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Cync example for C concurrent programing&lt;/p&gt;
&lt;h1 id=&quot;Threads&quot;&gt;&lt;a href=&quot;#Threads&quot; class=&quot;headerlink&quot; title=&quot;Threads&quot;&gt;&lt;/a&gt;Threads&lt;/h1&gt;&lt;figu
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="concurrent_algorithm" scheme="https://coconutnutx.github.io/tags/concurrent-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Summary on basic register reductions</title>
    <link href="https://coconutnutx.github.io/2021/10/31/register/"/>
    <id>https://coconutnutx.github.io/2021/10/31/register/</id>
    <published>2021-10-31T17:01:49.000Z</published>
    <updated>2021-10-31T17:01:49.000Z</updated>
    
    <content type="html"><![CDATA[<img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-10-31 PM5.58.54.jpg"                                     >]]></content>
    
    <summary type="html">
    
      
      
        &lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/2021/screencaptur
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="distributed_algorithm" scheme="https://coconutnutx.github.io/tags/distributed-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>CountSketch Matrix</title>
    <link href="https://coconutnutx.github.io/2021/10/27/countsketch/"/>
    <id>https://coconutnutx.github.io/2021/10/27/countsketch/</id>
    <published>2021-10-27T20:58:59.000Z</published>
    <updated>2021-10-27T20:58:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>Drew a simple example to help understanding what I learned in class.</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/2021-10-27-225725.png"                                     ><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/2021-10-27-225726.png"                                     >]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Drew a simple example to help understanding what I learned in class.&lt;/p&gt;
&lt;img  
                     lazyload
                     src=&quot;/
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="sublinear_algorithm" scheme="https://coconutnutx.github.io/tags/sublinear-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>DA project0 test record</title>
    <link href="https://coconutnutx.github.io/2021/10/19/DA-project-test/"/>
    <id>https://coconutnutx.github.io/2021/10/19/DA-project-test/</id>
    <published>2021-10-19T16:28:01.000Z</published>
    <updated>2021-10-19T16:28:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>Project0要求实现Perfect Link，给了测试用的tc.py用来修改网络情况，stress.py模拟发消息。（Distributed Algorithms 2021-2022 Project Validation.pdf）</p><p>想测一下试试。</p><p>注：以下几个测试都没有改tc.py的参数，即↓</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-10-19 PM6.43.30.jpg"                                     ><h1 id="Round-1"><a href="#Round-1" class="headerlink" title="Round 1"></a>Round 1</h1><p>参数如图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">testConfig = &#123;</span><br><span class="line">        <span class="string">&#x27;concurrency&#x27;</span> : <span class="number">8</span>, <span class="comment"># How many threads are interferring with the running processes</span></span><br><span class="line">        <span class="string">&#x27;attempts&#x27;</span> : <span class="number">8</span>, <span class="comment"># How many interferring attempts each threads does</span></span><br><span class="line">        <span class="string">&#x27;attemptsDistribution&#x27;</span> : &#123; <span class="comment"># Probability with which an interferring thread will</span></span><br><span class="line">            <span class="string">&#x27;STOP&#x27;</span>: <span class="number">0.48</span>,          <span class="comment"># select an interferring action (make sure they add up to 1)</span></span><br><span class="line">            <span class="string">&#x27;CONT&#x27;</span>: <span class="number">0.48</span>,</span><br><span class="line">            <span class="string">&#x27;TERM&#x27;</span>:<span class="number">0.04</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 stress.py -r ../template_java/run.sh -t perfect -l output -p <span class="number">10</span> -m <span class="number">10</span></span><br></pre></td></tr></table></figure><p>testConfig在stress.py最后，这里全是默认，10个process，每个发10条消息（config中只有一行 10 1）</p><p>理论上来说，应该是2-9号都要给1号发10条，总共90条</p><p>但是出来的数据不完全是90</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-10-19 PM6.46.31.jpg"                                     ><p>（这里统计输出写了个简单工具，见最后）</p><p>根据后面测试的结果推测，问题在testConfig这里。concurrency和attempts数值都是8，也就是有8个捣乱线程各干预8次。STOP和CONT只是暂停和继续，不会干扰最后的结果。但是这里还有0.04的概率会发TERM，直接把正在干活的process杀了。所以最后有的只发了79、80</p><h1 id="Round-2"><a href="#Round-2" class="headerlink" title="Round 2"></a>Round 2</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;concurrency&#x27;</span> : <span class="number">16</span></span><br><span class="line"><span class="string">&#x27;attempts&#x27;</span> : <span class="number">16</span></span><br><span class="line"><span class="string">&#x27;attemptsDistribution&#x27;</span> : </span><br><span class="line">            <span class="string">&#x27;STOP&#x27;</span>: <span class="number">0.48</span>,</span><br><span class="line">            <span class="string">&#x27;CONT&#x27;</span>: <span class="number">0.48</span>,</span><br><span class="line">            <span class="string">&#x27;TERM&#x27;</span>:<span class="number">0.04</span></span><br><span class="line"></span><br><span class="line">-p <span class="number">20</span> -m <span class="number">20</span></span><br></pre></td></tr></table></figure><p>试了几次这个参数，情况差不多。应该有19*20=380条，但是结果分别是：267、299、360、319</p><h1 id="突然"><a href="#突然" class="headerlink" title="突然"></a>突然</h1><p>经另一位当值的昆虫馆管理员提醒，测试进程数是有上限的</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-10-19 PM6.08.42.jpg"                                     ><p>对不起我的CPU🙇‍♂️</p><p>（但是这里到底是在说9 100是上限，还是举个例子说如果9 100，让跑25分钟？？？）</p><h1 id="Round-3"><a href="#Round-3" class="headerlink" title="Round 3"></a>Round 3</h1><p>于是就把p和m直接设成9和100</p><p>意识到TERM可能会对correctness有影响，这里把TERM也调成了0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;concurrency&#x27;</span> : <span class="number">8</span></span><br><span class="line"><span class="string">&#x27;attempts&#x27;</span> : <span class="number">8</span></span><br><span class="line"><span class="string">&#x27;attemptsDistribution&#x27;</span> : </span><br><span class="line">            <span class="string">&#x27;STOP&#x27;</span>: <span class="number">0.5</span>,</span><br><span class="line">            <span class="string">&#x27;CONT&#x27;</span>: <span class="number">0.5</span>,</span><br><span class="line">            <span class="string">&#x27;TERM&#x27;</span>:<span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">-p <span class="number">9</span> -m <span class="number">100</span></span><br></pre></td></tr></table></figure><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-10-19 PM7.06.12.jpg"                                     ><p>输出没毛病</p><h1 id="Round-4"><a href="#Round-4" class="headerlink" title="Round 4"></a>Round 4</h1><p>然后把TERM改回去</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;concurrency&#x27;</span> : <span class="number">8</span></span><br><span class="line"><span class="string">&#x27;attempts&#x27;</span> : <span class="number">8</span></span><br><span class="line"><span class="string">&#x27;attemptsDistribution&#x27;</span> : </span><br><span class="line">            <span class="string">&#x27;STOP&#x27;</span>: <span class="number">0.48</span>,</span><br><span class="line">            <span class="string">&#x27;CONT&#x27;</span>: <span class="number">0.48</span>,</span><br><span class="line">            <span class="string">&#x27;TERM&#x27;</span>:<span class="number">0.04</span></span><br><span class="line"></span><br><span class="line">-p <span class="number">9</span> -m <span class="number">100</span></span><br></pre></td></tr></table></figure><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-10-19 PM7.07.10.jpg"                                     ><p>左边是运行中部分输出</p><p>可以发现有的process被SIGTERM杀掉了，第一次SIGTERM多一些，最后收到的少一些。第二次最后才有一个SIGTERM，此时已经发完了</p><p>符合预期</p><h1 id="Tool"><a href="#Tool" class="headerlink" title="Tool"></a>Tool</h1><p>由于输出长得实在没眼看，不好debug，写了个工具统计一下</p><p>这两放一个目录下：</p><ul><li>count.py</li><li>output.txt</li></ul><p>output.txt是stress.py的输出（只是process 1的output，全是deliver没有broadcast的，长这样↓）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">d 2 81</span><br><span class="line">d 2 87</span><br><span class="line">d 2 85</span><br><span class="line">d 6 48</span><br><span class="line">d 6 58</span><br><span class="line">d 6 86</span><br><span class="line">d 6 90</span><br><span class="line">d 6 93</span><br><span class="line">d 6 95</span><br><span class="line">d 6 99</span><br><span class="line">d 6 94</span><br><span class="line">d 2 11</span><br><span class="line">d 2 61</span><br><span class="line">d 2 92</span><br><span class="line">d 2 2</span><br><span class="line">d 2 9</span><br><span class="line">d 6 54</span><br><span class="line">d 2 21</span><br><span class="line">d 2 14</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>count.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">data = f.readlines()</span><br><span class="line"></span><br><span class="line"><span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> data:</span><br><span class="line">splited = line.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">sender = <span class="built_in">int</span>(splited[<span class="number">1</span>])</span><br><span class="line">seq = <span class="built_in">int</span>(splited[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">dict</span>.setdefault(sender,[]).append(seq)</span><br><span class="line">count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nTotal number of senders: &quot;</span> , <span class="built_in">len</span>(<span class="built_in">dict</span>), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Total number of messages: &quot;</span>,  count, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Details (S: sender id; T: total message received, Q: seq)\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">keys = []</span><br><span class="line"><span class="keyword">for</span> sender <span class="keyword">in</span> <span class="built_in">dict</span>.keys():</span><br><span class="line">keys.append(<span class="built_in">int</span>(sender))</span><br><span class="line">keys.sort()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> sender <span class="keyword">in</span> keys:</span><br><span class="line"><span class="built_in">dict</span>[sender].sort()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;S:&quot;</span>, <span class="built_in">format</span>(sender,<span class="string">&quot;&lt;4&quot;</span>), <span class="string">&quot; T:&quot;</span>, <span class="built_in">format</span>(<span class="built_in">len</span>(<span class="built_in">dict</span>[sender]),<span class="string">&quot;&lt;5&quot;</span>), <span class="string">&quot; Q:&quot;</span>, <span class="built_in">dict</span>[sender])</span><br><span class="line"><span class="comment"># print(&quot;S:&quot;, format(sender,&quot;&lt;4&quot;), &quot; T:&quot;, format(len(dict[sender]),&quot;&lt;5&quot;))</span></span><br></pre></td></tr></table></figure><p>后面输出多了，可以把具体的SEQ删掉掉，前面少的时候可以看看有没有重复</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Project0要求实现Perfect Link，给了测试用的tc.py用来修改网络情况，stress.py模拟发消息。（Distributed Algorithms 2021-2022 Project Validation.pdf）&lt;/p&gt;
&lt;p&gt;想测一下试试。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Memo" scheme="https://coconutnutx.github.io/categories/Memo/"/>
    
    
      <category term="distributed_algorithm" scheme="https://coconutnutx.github.io/tags/distributed-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>记录anki卡片</title>
    <link href="https://coconutnutx.github.io/2021/04/21/anki/"/>
    <id>https://coconutnutx.github.io/2021/04/21/anki/</id>
    <published>2021-04-21T09:45:17.000Z</published>
    <updated>2021-04-21T09:45:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>打算用anki背法语单词，用Fast Word Query加发音</p><p>字段：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-04-21 AM11.48.55.jpg"                      width="400px"                ><p>卡片：</p><p>正面模板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;/br&gt;</span><br><span class="line">&lt;center&gt;</span><br><span class="line">&lt;div class=&quot;background&quot;&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;word&#125;&#125;&lt;/div&gt;&lt;/br&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/center&gt;</span><br></pre></td></tr></table></figure><p>背面模板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;center&gt;</span><br><span class="line">&lt;div class=&quot;background&quot;&gt;</span><br><span class="line">&#123;&#123;FrontSide&#125;&#125;</span><br><span class="line">&lt;hr id=answer&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;pronunciation&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;explanation&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;example&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/center&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;var initVoice = function () &#123;</span><br><span class="line">    var player = document.getElementById(&#x27;dictVoice&#x27;);</span><br><span class="line">    document.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">        var target = e.target;</span><br><span class="line">        if (target.hasAttribute(&#x27;role&#x27;) &amp;&amp; target.getAttribute(&#x27;role&#x27;).indexOf(&#x27;dict_audio_js&#x27;) &gt;= 0) &#123;</span><br><span class="line">            var url = target.getAttribute(&#x27;data-rel&#x27;);</span><br><span class="line">            player.setAttribute(&#x27;src&#x27;, url);</span><br><span class="line">            player.volume = 1;</span><br><span class="line">            player.play();</span><br><span class="line">            e.preventDefault();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, false);</span><br><span class="line">&#125;;</span><br><span class="line">initVoice();&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>Fast Word Query配置：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-04-21 AM11.47.38.jpg"                                     ><p>试了一下法语助手只能查到发音，没有解释，于是解释用了有道</p><p>此时效果：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-04-21 AM11.51.40.jpg"                                     ><p>翻面自动发音，例句的语音也可以点</p><p>但有个问题是，查到的例句是白色，背景也是白色</p><p>选中example框，在编辑html中找到了这几个div的class，卡片中改样式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.card &#123;</span><br><span class="line">font-family: arial;</span><br><span class="line">font-size: 20px;</span><br><span class="line">&#125;</span><br><span class="line">.background&#123;</span><br><span class="line">max-width: 800px;</span><br><span class="line">&#125;</span><br><span class="line">.mcols-layout&#123;</span><br><span class="line"> background-color:#333335</span><br><span class="line">&#125;</span><br><span class="line">.trans-container&#123;</span><br><span class="line">background-color: #333335;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搞定~</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-04-21 PM12.22.46.jpg"                                     ><hr><p>又加了个pre字段，可以放le la之类的，显示时在word之前 </p><p>查的时候忽略（在Fast Word Query中Ignore掉），仍只查word，避免查不到解释</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;打算用anki背法语单词，用Fast Word Query加发音&lt;/p&gt;
&lt;p&gt;字段：&lt;/p&gt;
&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
     
      
    
    </summary>
    
    
      <category term="Memo" scheme="https://coconutnutx.github.io/categories/Memo/"/>
    
    
      <category term="tool" scheme="https://coconutnutx.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>Unity Debug WebGL播放视频</title>
    <link href="https://coconutnutx.github.io/2021/04/02/unity-debug/"/>
    <id>https://coconutnutx.github.io/2021/04/02/unity-debug/</id>
    <published>2021-04-02T07:53:07.000Z</published>
    <updated>2021-04-02T07:53:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>Unity内运行时播放视频没问题，导出后用火狐打开就放不了，看控制台报错是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">已拦截跨源请求：同源策略禁止读取位于 file:///Users/.../unity/Backups/WebV0.3/sharedassets0.resource 的远程资源。（原因：CORS 请求不是 http）。</span><br></pre></td></tr></table></figure><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><ol><li><p>WebGL只能通过URL播放视频</p><blockquote><p><a class="link"   href="https://blog.csdn.net/wuyt2008/article/details/107592492?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161752087116780265448826%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161752087116780265448826&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~times_rank-10-107592492.first_rank_v2_pc_rank_v29&utm_term=unity+webgl+%E8%A7%86%E9%A2%91%E9%BB%91%E5%B1%8F" >Unity2019在WebGL下播放视频<i class="fas fa-external-link-alt"></i></a></p></blockquote></li><li><p>火狐浏览器设置允许跨域</p><p>security.fileuri.strict_origin_policy改false</p><blockquote><p><a class="link"   href="https://blog.csdn.net/qq_28867949/article/details/99890103?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&spm=1001.2101.3001.4242" >Firefox火狐浏览器访问本地文件-提示跨域问题<i class="fas fa-external-link-alt"></i></a></p></blockquote></li><li><p>火狐浏览器设置允许播放视频</p><blockquote><p><a class="link"   href="https://blog.csdn.net/qq_34243277/article/details/114398872?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&spm=1001.2101.3001.4242" >Unity2018发布webgl视频无法播放<i class="fas fa-external-link-alt"></i></a></p></blockquote></li></ol><h1 id="各种失败尝试记录"><a href="#各种失败尝试记录" class="headerlink" title="各种失败尝试记录"></a>各种失败尝试记录</h1><p>1.</p><blockquote><p><a class="link"   href="https://blog.kongregate.com/unity-html5-cors-and-you/" >https://blog.kongregate.com/unity-html5-cors-and-you/<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>写了问题原因，但是没看到针对Unity怎么解决</p><p>2.</p><blockquote><p><a class="link"   href="https://www.jianshu.com/p/78904381ba32" >https://www.jianshu.com/p/78904381ba32<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>说把privacy.file_unique_origin改成false，但是它已经是false了</p><p>3.</p><p>发现Unity中Video Player的视频源有视频剪辑和URL两种方式</p><p>之前用的是视频剪辑，直接把mp4文件拖进去</p><p>改用URL试试，从浏览中找到同一个文件，测试也可以播放。试了一个网络上的mp4的URL，测试也可以</p><p>那或许可以尝试把mp4上传，然后用URL访问</p><blockquote><p><a class="link"   href="https://blog.csdn.net/weixin_33912453/article/details/94087306?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.baidujs&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.baidujs" >https://blog.csdn.net/weixin_33912453/article/details/94087306?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.baidujs&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.baidujs<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>试试这个用爱奇艺开放平台的</p><p>发现注册应用必须有url</p><p>4.</p><p>再找一下有没有视频托管网站</p><p><a class="link"   href="https://www.zhihu.com/question/23036186/answer/1716470191" >https://www.zhihu.com/question/23036186/answer/1716470191<i class="fas fa-external-link-alt"></i></a></p><p>找了一个酷播云，视频要审核，等会再看（似乎不能直接拿到URL，可能要凉）</p><p><a class="link"   href="http://www.stonepoll.com/helpcenter/hc/kb/article/fcc34c50-301a-822a-df8c-e690f5af5bb5/" >http://www.stonepoll.com/helpcenter/hc/kb/article/fcc34c50-301a-822a-df8c-e690f5af5bb5/<i class="fas fa-external-link-alt"></i></a></p><p>腾讯云要买服务，算了先</p><p>又传了一个优酷的，等会看审核</p><p>得，拿不到mp4的URL</p><p>5.</p><p>还是从浏览器入手吧，试试允许跨域</p><p><a class="link"   href="https://blog.csdn.net/nju_zjy/article/details/108870385" >https://blog.csdn.net/nju_zjy/article/details/108870385<i class="fas fa-external-link-alt"></i></a></p><p>参考这个，装一个火狐插件</p><p>没用</p><p>多试了几个插件，都没用</p><p>6.</p><p>有找到一个调浏览器设置的</p><p><a class="link"   href="https://blog.csdn.net/qq_28867949/article/details/99890103?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&amp;spm=1001.2101.3001.4242" >https://blog.csdn.net/qq_28867949/article/details/99890103?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&amp;spm=1001.2101.3001.4242<i class="fas fa-external-link-alt"></i></a></p><p>把security.fileuri.strict_origin_policy改成false</p><p>【重启后不报错了！】</p><p>但是视频还是播放不了</p><p>7.</p><p><a class="link"   href="https://blog.csdn.net/qq_38229886/article/details/103139228?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-2&amp;spm=1001.2101.3001.4242" >https://blog.csdn.net/qq_38229886/article/details/103139228?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-2&amp;spm=1001.2101.3001.4242<i class="fas fa-external-link-alt"></i></a></p><p>WebGL不支持mp4？！…</p><p>转成ogv。没用</p><p>8.</p><p>找了一个在线的mp4地址，本地ok</p><p>导出WebGL运行，不报错，播放不了</p><p>9.</p><p><a class="link"   href="https://blog.csdn.net/weixin_43779625/article/details/103410836" >https://blog.csdn.net/weixin_43779625/article/details/103410836<i class="fas fa-external-link-alt"></i></a></p><p>改用Render Texture的方式（以前是材质覆盖）</p><p>不行（甚至本地都显示不了视频，只有声音）</p><p>10.</p><p><a class="link"   href="https://blog.csdn.net/JLX_Sir/article/details/82684491?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.baidujs&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.baidujs" >https://blog.csdn.net/JLX_Sir/article/details/82684491?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.baidujs&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.baidujs<i class="fas fa-external-link-alt"></i></a></p><p>说WebGL不支持高分辨率</p><p>试试在检查器里设置转码 1/4分辨率，比特率模式低，空间质量低</p><p>导出，不行</p><p>11.</p><p><a class="link"   href="https://blog.csdn.net/qq_34243277/article/details/114398872?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&amp;spm=1001.2101.3001.4242" >https://blog.csdn.net/qq_34243277/article/details/114398872?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&amp;spm=1001.2101.3001.4242<i class="fas fa-external-link-alt"></i></a></p><p>火狐还有阻止音视频的默认设置？？关掉</p><p>mp4和ogv都不行</p><p>12.</p><p><a class="link"   href="https://blog.csdn.net/s1314_JHC/article/details/80618252" >https://blog.csdn.net/s1314_JHC/article/details/80618252<i class="fas fa-external-link-alt"></i></a></p><p>还有说是WebGL不支持MovieTexture的，用插件</p><p>导出后是黑的，疯狂报错</p><p>13.</p><p><a class="link"   href="https://blog.csdn.net/wuyt2008/article/details/107592492?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161752087116780265448826%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=161752087116780265448826&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~times_rank-10-107592492.first_rank_v2_pc_rank_v29&amp;utm_term=unity+webgl+%E8%A7%86%E9%A2%91%E9%BB%91%E5%B1%8F" >https://blog.csdn.net/wuyt2008/article/details/107592492?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161752087116780265448826%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=161752087116780265448826&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~times_rank-10-107592492.first_rank_v2_pc_rank_v29&amp;utm_term=unity+webgl+%E8%A7%86%E9%A2%91%E9%BB%91%E5%B1%8F<i class="fas fa-external-link-alt"></i></a></p><p>这个说WebGL只能通过url播放</p><p>现在调过火狐的设置了，再试试url吧</p><p>!!!!!!!!!!!!成功了😭!!!!!!!!!!!!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Unity内运行时播放视频没问题，导出后用火狐打开就放不了，看控制台报错是&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/sp
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="unity" scheme="https://coconutnutx.github.io/tags/unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity Project 版本记录</title>
    <link href="https://coconutnutx.github.io/2021/03/21/unity-project-memo/"/>
    <id>https://coconutnutx.github.io/2021/03/21/unity-project-memo/</id>
    <published>2021-03-21T16:35:47.000Z</published>
    <updated>2021-03-21T16:35:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="02-16-V0-1"><a href="#02-16-V0-1" class="headerlink" title="02.16 V0.1"></a>02.16 V0.1</h1><h2 id="新增基础移动操作"><a href="#新增基础移动操作" class="headerlink" title="新增基础移动操作"></a>新增基础移动操作</h2><ul><li><p>点击寻路</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/Feb-16-2021 18-29-31.gif"                                     ></li><li><p>靠近显示介绍</p></li><li><p>鼠标滚动前后平移</p></li><li><p>键盘前后左右平移</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/Feb-16-2021 18-30-32.gif"                                     ></li><li><p>鼠标拖拽旋转视角</p></li></ul><h1 id="02-19-V0-1-1"><a href="#02-19-V0-1-1" class="headerlink" title="02.19 V0.1.1"></a>02.19 V0.1.1</h1><h2 id="新增介绍牌"><a href="#新增介绍牌" class="headerlink" title="新增介绍牌"></a>新增介绍牌</h2><ul><li><p>删除靠近显示介绍</p></li><li><p>介绍牌鼠标移入高亮</p></li><li><p>点击介绍牌寻路</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/Feb-19-2021 17-25-59.gif"                                     ><ul><li>寻路中任意操作打断</li><li>到达目的地后转向介绍牌</li></ul></li></ul><h2 id="新增导游栏"><a href="#新增导游栏" class="headerlink" title="新增导游栏"></a>新增导游栏</h2><ul><li><p>点击中间按钮寻路</p></li><li><p>点击左右按钮更新导游栏并寻路</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/Feb-19-2021 17-26-58.gif"                                     ><ul><li>最左/最右时按钮不可用</li></ul></li></ul><h2 id="新增菜单栏"><a href="#新增菜单栏" class="headerlink" title="新增菜单栏"></a>新增菜单栏</h2><ul><li>点击帮助按钮弹出介绍</li></ul><h1 id="03-09-V0-1-2"><a href="#03-09-V0-1-2" class="headerlink" title="03.09 V0.1.2"></a>03.09 V0.1.2</h1><h2 id="新增介绍"><a href="#新增介绍" class="headerlink" title="新增介绍"></a>新增介绍</h2><ul><li><p>点击导航栏中按钮，显示简介</p><ul><li>文字超出时显示滚动条</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/Mar-09-2021 17-34-17.gif"                                     ><ul><li>点击查看大图打开新页面</li></ul></li></ul><h1 id="03-11-V0-2"><a href="#03-11-V0-2" class="headerlink" title="03.11 V0.2"></a>03.11 V0.2</h1><h2 id="重建展厅"><a href="#重建展厅" class="headerlink" title="重建展厅"></a>重建展厅</h2><ul><li><p>初始放入隋到五代的8张画</p></li><li><p>调整介绍牌样式</p></li><li><p>加入天花板和灯</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/Mar-11-2021 16-54-44.gif"                                     ></li></ul><h1 id="03-16-V0-2-1"><a href="#03-16-V0-2-1" class="headerlink" title="03.16 V0.2.1"></a>03.16 V0.2.1</h1><h2 id="加入帮助按钮"><a href="#加入帮助按钮" class="headerlink" title="加入帮助按钮"></a>加入帮助按钮</h2><ul><li><p>点击显示操作说明</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/Mar-16-2021 11-50-45.gif"                                     ></li></ul><h2 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h2><ul><li>点击查看大图时，在新窗口打开页面</li><li>调整点击寻路粒子效果</li></ul><h1 id="03-20-V0-2-2"><a href="#03-20-V0-2-2" class="headerlink" title="03.20 V0.2.2"></a>03.20 V0.2.2</h1><h2 id="HallA搭建基本完成"><a href="#HallA搭建基本完成" class="headerlink" title="HallA搭建基本完成"></a>HallA搭建基本完成</h2><ul><li><p>共28张画作</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/Mar-21-2021 22-30-25.gif"                                     ></li><li><p>设置座椅、绿植、花瓶等</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/Mar-21-2021 22-32-51.gif"                                     ></li></ul><h1 id="03-25-V0-2-3"><a href="#03-25-V0-2-3" class="headerlink" title="03.25 V0.2.3"></a>03.25 V0.2.3</h1><ul><li><p>修改导航栏高亮效果</p></li><li><p>新增装饰效果</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/Mar-26-2021 10-03-52.gif"                                     ></li></ul><h2 id="新增音乐"><a href="#新增音乐" class="headerlink" title="新增音乐"></a>新增音乐</h2><ul><li>移动时添加脚步音效</li><li>千里江山图走廊中添加流水音效</li></ul><h1 id="03-31-V0-2-4"><a href="#03-31-V0-2-4" class="headerlink" title="03.31 V0.2.4"></a>03.31 V0.2.4</h1><p>修改UI</p><ul><li><p>修改导航栏图标为文字，避免左右箭头与移动方向不一致影响体验</p></li><li><p>新增上下左右移动按钮</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/Apr-02-2021 09-24-45.gif"                                     ></li><li><p>导航栏初始显示0展览介绍，此时只有下一幅按钮可点击</p></li></ul><p>修改展厅</p><ul><li>新增展览介绍，默认进入场景时面向展览介绍，点下一幅来到第一幅画作</li><li>调整朝代介绍位置，使导航到画作时能完整浏览</li><li>新增出口</li><li>新增方向指示牌，将部分地上的花瓶移动到指示牌平台上</li></ul><p>修改导航模块</p><ul><li>点击画作也可导航</li></ul><h1 id="04-02-V0-3"><a href="#04-02-V0-3" class="headerlink" title="04.02 V0.3"></a>04.02 V0.3</h1><p>新增影厅</p><ul><li><p>开始和暂停视频</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/Apr-02-2021 09-18-14.gif"                                     ></li></ul><p>导航栏新增展开按钮</p><ul><li>点击展开去影厅和回起点按钮</li><li>去影厅导航到影厅</li><li>会起点导航到展厅介绍</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;02-16-V0-1&quot;&gt;&lt;a href=&quot;#02-16-V0-1&quot; class=&quot;headerlink&quot; title=&quot;02.16 V0.1&quot;&gt;&lt;/a&gt;02.16 V0.1&lt;/h1&gt;&lt;h2 id=&quot;新增基础移动操作&quot;&gt;&lt;a href=&quot;#新增基础移动操作&quot; cla
      
    
    </summary>
    
    
      <category term="Memo" scheme="https://coconutnutx.github.io/categories/Memo/"/>
    
    
      <category term="unity" scheme="https://coconutnutx.github.io/tags/unity/"/>
    
  </entry>
  
</feed>
