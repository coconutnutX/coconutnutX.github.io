<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CoCoNutNut&#39;s NoteBook</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://coconutnutx.github.io/"/>
  <updated>2023-11-21T10:20:37.000Z</updated>
  <id>https://coconutnutx.github.io/</id>
  
  <author>
    <name>coconutnut</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Switch policy design</title>
    <link href="https://coconutnutx.github.io/2023/11/21/switch-policy/"/>
    <id>https://coconutnutx.github.io/2023/11/21/switch-policy/</id>
    <published>2023-11-21T10:20:37.000Z</published>
    <updated>2023-11-21T10:20:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>Current swilock components &amp; implementation status</p><ul><li><p>Lock &amp; Unlock APIs✅</p><ul><li>Switch between CAS, qspinlock, TCLock (queue-based)</li></ul></li><li><p>Helper thread✅</p><ul><li>Change lock type every 5s</li></ul></li><li><p>FFWD⭕️</p><ul><li>Server thread: iterate through CPU requests, switch stack and process requests</li><li>Client APIs: delegate() &amp; delegate_finish(), can replace lock() &amp; unlock()</li></ul></li><li><p>Throughput live demo✅</p></li></ul><h1 id="Switch-base-on-contention"><a href="#Switch-base-on-contention" class="headerlink" title="Switch base on contention"></a>Switch base on contention</h1><h2 id="Plan-A"><a href="#Plan-A" class="headerlink" title="Plan A"></a>Plan A</h2><p>Consider how many threads are using the lock.</p><ol><li>Add a global counter</li><li>When calling lock() &amp; unlock(), increase &amp; decrease counter</li><li>Helper thread checks the counter, switch lock base on its value, e.g.<ul><li>(0,1] CAS</li><li>[2,8] qspinlock</li><li>(8,+inf) TCLock</li></ul></li></ol><h2 id="Plan-B"><a href="#Plan-B" class="headerlink" title="Plan B"></a><del>Plan B</del></h2><p><del>Consider how long the threads have been waiting</del></p><ol><li><del>For each thread, calculate time between lock() &amp; unlock()</del></li><li><del>Helper thread maintains recent waiting times (e.g. 32 lateast values)</del></li><li><del>Helper thread switch base on average waiting time?</del></li></ol><p>Can also keep statistics of:</p><ol><li>waiting time</li><li>overall throughput</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Current swilock components &amp;amp; implementation status&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Lock &amp;amp; Unlock APIs✅&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Switch between CAS, qspinlock
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="lock" scheme="https://coconutnutx.github.io/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>Delegation design</title>
    <link href="https://coconutnutx.github.io/2023/11/06/delegate-design/"/>
    <id>https://coconutnutx.github.io/2023/11/06/delegate-design/</id>
    <published>2023-11-06T13:16:37.000Z</published>
    <updated>2023-11-06T13:16:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Per-CPU-structure"><a href="#Per-CPU-structure" class="headerlink" title="Per-CPU structure"></a>Per-CPU structure</h1><p>For storing request info:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shadow_stack</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qspinlock</span> *<span class="title">lock</span>;</span></span><br><span class="line">  <span class="meta"># indicate there is a request, write only by client</span></span><br><span class="line"><span class="meta"># server iterates the array, checks this value, and process request</span></span><br><span class="line"><span class="keyword">bool</span> active;</span><br><span class="line"><span class="keyword">bool</span> completed;</span><br><span class="line"><span class="keyword">int</span> cpu_id;</span><br><span class="line">  <span class="keyword">void</span> *ptr;</span><br><span class="line">  <span class="keyword">uint64_t</span> local_shadow_stack_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Each CPU will have a shadow stack</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_PER_CPU_SHARED_ALIGNED(struct shadow_stack, local_shadow_stack);</span><br></pre></td></tr></table></figure><p>And server thread will a shadow stack</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shadow_stack</span> *<span class="title">server_ptr</span>;</span></span><br></pre></td></tr></table></figure><p>Question: server thread and some other threads might be on the same CPU. Will this be problematic?</p><h1 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">swilock_delegate(lock);        <span class="meta"># reuse spin_lock()</span></span><br><span class="line">...</span><br><span class="line"># CS</span><br><span class="line">...</span><br><span class="line">swilock_delegate_finish();     <span class="meta"># reuse spin_unlock()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__swilock_delegate(struct qspinlock *lock)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shadow_stack</span> *<span class="title">ptr</span> =</span> this_cpu_ptr(&amp;local_shadow_stack);</span><br><span class="line">    ptr-&gt;lock = lock;</span><br><span class="line">    ptr-&gt;completed = <span class="literal">false</span>;</span><br><span class="line">    ptr-&gt;active = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for server to process request</span></span><br><span class="line">    <span class="keyword">while</span>(ptr-&gt;completed == <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swilock_delegate</span><span class="params">(struct qspinlock *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Main -&gt; ephemeral stack</span></span><br><span class="line">  ...</span><br><span class="line">    </span><br><span class="line">ret_val = __swilock_delegate(lock);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Ephemeral -&gt; main stack</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swilock_delegate_finish</span><span class="params">(struct qspinlock *lock)</span></span>&#123;</span><br><span class="line"><span class="comment">// Client -&gt; server thread</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Can reuse TCLock code [Marked yellow]</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2023/screencapture2023-11-06 PM2.17.25.jpg"                                     ><h1 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h1><p>Reuse parts marked green</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// Init shadow stack for each cpu</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Init shadow stack for server thread</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Start delegate server</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute_request</span><span class="params">(struct shadow_stack *ptr)</span></span>&#123;</span><br><span class="line"><span class="comment">// Get TAS lock</span></span><br><span class="line">swi_lock(lock, TAS);</span><br><span class="line"><span class="comment">// Server → client stack </span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// Client&#x27;s critical section execution finished </span></span><br><span class="line">  ptr-&gt;active = <span class="literal">false</span>;</span><br><span class="line">ptr-&gt;completed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Release TAS lock</span></span><br><span class="line">swi_unlock(lock, TAS)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swi_delegate_thread</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!kthread_should_stop())&#123;</span><br><span class="line"><span class="comment">// Ieterate through client reuqests</span></span><br><span class="line">for_each_possible_cpu (i) &#123;</span><br><span class="line"><span class="comment">// Check if has request</span></span><br><span class="line"><span class="keyword">if</span> requests[i].active&#123;</span><br><span class="line">execute_request(requests[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Per-CPU-structure&quot;&gt;&lt;a href=&quot;#Per-CPU-structure&quot; class=&quot;headerlink&quot; title=&quot;Per-CPU structure&quot;&gt;&lt;/a&gt;Per-CPU structure&lt;/h1&gt;&lt;p&gt;For storin
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="lock" scheme="https://coconutnutx.github.io/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>Switch lock design</title>
    <link href="https://coconutnutx.github.io/2023/10/10/switch-lock/"/>
    <id>https://coconutnutx.github.io/2023/10/10/switch-lock/</id>
    <published>2023-10-10T08:37:07.000Z</published>
    <updated>2023-10-10T08:37:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lock-structure"><a href="#Lock-structure" class="headerlink" title="Lock structure"></a>Lock structure</h1><p>CAS, qspinlock and kmob can share the same lock structure:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qspinlock</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="keyword">atomic_t</span> val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">u8locked;</span><br><span class="line">u8pending;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">u16locked_pending;</span><br><span class="line">u16tail;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Since pending &amp; locked requires only 1 bit, there’s space for more information (if needed).</p><p>The threads could be spinning/waiting at:</p><ol><li>CAS spins on the lock (32bits)</li><li>qspinlock:<ol><li>uncontended: lock (32bits)</li><li>pending: locked (8bits)</li><li>uncontended queue: locked_pending (16bits)</li><li>contended queue: node.locked (and later locked_pending)</li></ol></li><li>komb:<ol><li>fastpath: lock (32bits)</li><li>midpath: locked_pending (16bits)</li><li>node.wait (and later lock)</li></ol></li></ol><p>For the nodes spinning on the lock itself, no further notification needed.</p><p>For those waiting on their own node, will need to notify according to queue type.</p><h1 id="Node-structure"><a href="#Node-structure" class="headerlink" title="Node structure"></a>Node structure</h1><p>TODO: How to store node?</p><ol><li>Copy all fields inside a single sqnode structure. Drawback: Will need to modify all underlying lock &amp; unlock functions</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sqnode</span>&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">LockType</span> <span class="title">type</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sqnode</span> *<span class="title">next</span>;</span></span><br><span class="line">  u8 locked; # Originally, <span class="class"><span class="keyword">struct</span> <span class="title">mcs_spinlock</span> <span class="title">has</span> <span class="title">uintptr_t</span> <span class="title">locked</span>;</span></span><br><span class="line">  <span class="meta"># other fields for QSPINLOCK</span></span><br><span class="line">  <span class="meta"># other fields for KOMB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Put MCS node and KOMB node inside sqnode. Drawback: Additional handling of getting next node</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sqnode</span>&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">LockType</span> <span class="title">type</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sqnode</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mcs_spinlock</span> <span class="title">mcs_node</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">komb_node</span> <span class="title">komb_node</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Passing sqnode instead of mcs/komb nodes</p><p>Modify select_next_waiter(sqnode)</p><p>Plan 2 seems to be better?</p><h1 id="Lock-amp-Unlock"><a href="#Lock-amp-Unlock" class="headerlink" title="Lock &amp; Unlock"></a>Lock &amp; Unlock</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Indicate current lock type</span><br><span class="line"># Currently a helper thread is changing lock type every <span class="number">5</span>s</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">LockType</span> <span class="title">cur_lock_type</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">slock_lock</span><span class="params">(lock)</span>:</span></span><br><span class="line"><span class="function"># Fastpath: <span class="keyword">try</span> to acquire the lock</span></span><br><span class="line"><span class="function">val </span>= CAS(&amp;lock.val, <span class="number">0</span>, _Q_LOCKED_VAL);</span><br><span class="line"><span class="keyword">if</span> val == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">  </span><br><span class="line">  # Midpath: same <span class="keyword">for</span> qspinlock <span class="keyword">and</span> komb, <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span> -&gt; <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">  # Don<span class="number">&#x27;</span>t need node</span><br><span class="line">  ...</span><br><span class="line">   </span><br><span class="line">  # Slowpath: choose according to lock type</span><br><span class="line">  <span class="keyword">if</span> cur_lock_type==CAS:</span><br><span class="line">    # Spin</span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    # Get per-CPU sqnode</span><br><span class="line">    sqnode = cst.node </span><br><span class="line">    init_sqnode(sqnode, cur_lock_type)</span><br><span class="line">    # Jump to slowpath</span><br><span class="line">    <span class="keyword">if</span> cur_lock_type==QSPINLOCK:</span><br><span class="line">        # Copy original one <span class="keyword">and</span> modify lines involving nodes</span><br><span class="line">        queued_spin_lock_slowpath(sqnode);</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        komb_spin_lock_slowpath(sqnode);</span><br></pre></td></tr></table></figure><p>For KOMB phase 4:</p><p>Check if next node is KOMB and next.next is not none</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">line</span> 58 in Listing 1</span></span><br><span class="line"><span class="keyword">if</span> qnext.next==None <span class="keyword">or</span> qnext.type!=KOMB:</span><br><span class="line">notify_next_queue_head(qnext)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">line</span> 73 in Listing 1 </span></span><br><span class="line"><span class="keyword">if</span> sqnext is None <span class="keyword">or</span> sqnext.type!=KOMB <span class="keyword">or</span> sqnext.next is None <span class="keyword">or</span></span><br><span class="line">  counter &gt;= WAITERS_TO_COMBINE:</span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>For qspinlock, waiting on <em>Q</em>LOCKED_PENDING_MASK also implies waiting on <em>Q</em>LOCKED_COMBINER_VAL</p><h1 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h1><p>Switching from QSPINLOCK to KOMB</p><p>node A[SPIN] -&gt; node B[SPIN] -&gt; node C[KOMB] -&gt; node D[KOMB] -&gt; node E[KOMB]</p><ol><li><p>A holds the lock</p><ul><li>B spins locked_pending</li><li><del>C spins on node.locked</del> C spins on lock.glock since qprev is None</li><li>D spins on node.locked</li></ul></li><li><p>A unlock, set locked to 0</p></li><li><p>B gets the lock, (0,1,1)-&gt;(0,1,0)-&gt;(0,0,1)</p></li><li><p><del>B unlock, notify C by setting C.node.locked to 0</del> B unlock, sets val to (0,0,0)</p></li><li><p>C gets the lock, switched</p></li></ol><p>Switching from KOMB to QSPINLOCK</p><p>A[KOMB] -&gt; B[KOMB] -&gt; C[KOMB] -&gt; D[KOMB] -&gt; E[SPIN]</p><ol><li><p>A holds the lock, and doing combining</p><ol><li>execute B’s CS</li><li>execute C’s CS</li><li>notify D</li><li>execute A’s CS</li><li>unlock</li></ol></li><li><p>D spins on D.qsnode.locked</p><ol><li>D gets lock</li><li>notify E</li><li>unlock</li></ol></li><li><p>E spins on E.qsnode.locked</p><ol><li>E gets lock, switched</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Lock-structure&quot;&gt;&lt;a href=&quot;#Lock-structure&quot; class=&quot;headerlink&quot; title=&quot;Lock structure&quot;&gt;&lt;/a&gt;Lock structure&lt;/h1&gt;&lt;p&gt;CAS, qspinlock and kmo
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="lock" scheme="https://coconutnutx.github.io/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>Switch lock debug</title>
    <link href="https://coconutnutx.github.io/2023/10/02/lock-debug/"/>
    <id>https://coconutnutx.github.io/2023/10/02/lock-debug/</id>
    <published>2023-10-02T16:24:40.000Z</published>
    <updated>2023-10-02T16:24:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>I’m using 2 locks: TAS &amp; TCLock, I want to maintain a counter of how many times the locks are called, and switch lock when it hits some threshold.</p><p>Basic structure:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slock_struct</span> &#123;</span></span><br><span class="line"><span class="comment">// Lock implementations</span></span><br><span class="line">  <span class="keyword">atomic_t</span> tas;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">orig_qspinlock</span> <span class="title">komb</span>;</span></span><br><span class="line"><span class="comment">// Lock switching</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">LockType</span> <span class="title">type</span>;</span></span><br><span class="line"><span class="keyword">atomic_t</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="1st-try"><a href="#1st-try" class="headerlink" title="1st try"></a>1st try</h1><p>Initially I tried using a counter:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slock_lock</span><span class="params">(struct slock_struct *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = atomic_read(&amp;lock-&gt;count);</span><br><span class="line">      <span class="comment">// Stop when threshold reached (might be switching)</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt; SWITCH_THRESHOLD) &#123;</span><br><span class="line">            <span class="keyword">if</span> (atomic_cmpxchg_acquire(&amp;lock-&gt;count, count, count + <span class="number">1</span>) == count) &#123;</span><br><span class="line">                <span class="comment">// Underlaying lock</span></span><br><span class="line">                slock_lock_chosen(lock);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slock_unlock</span><span class="params">(struct slock_struct *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    slock_unlock_chosen(lock);</span><br><span class="line">    <span class="keyword">if</span>(atomic_read(&amp;lock-&gt;count) == SWITCH_THRESHOLD)&#123;</span><br><span class="line"><span class="comment">// Switch lock</span></span><br><span class="line"><span class="keyword">if</span>(lock-&gt;type == TAS)&#123;</span><br><span class="line">lock-&gt;type = KOMB;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">lock-&gt;type = TAS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> count = atomic_cmpxchg_release(&amp;lock-&gt;count, SWITCH_THRESHOLD, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (count != SWITCH_THRESHOLD)&#123;</span><br><span class="line">        print_debug(<span class="string">&quot;!!!!!!!!!!!!!RESET COUNT ERROR, current_count=%d&quot;</span>, count);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When running rcuhashtable test, I sometimes get error with current_count==1 (or 2, 8…)</p><p>and something like:</p><p> BUG: soft Lockup CPU#0 stuck for 26s</p><h1 id="Bug-example"><a href="#Bug-example" class="headerlink" title="Bug example"></a>Bug example</h1><p>The above code crashes in this example (say threshold is 100):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">T1                T2</span><br><span class="line">---               ---</span><br><span class="line">get count 99</span><br><span class="line">                  get count 100</span><br><span class="line">lock TAS</span><br><span class="line">CS</span><br><span class="line">unlock TAS</span><br><span class="line">lock TAS</span><br><span class="line">read count 100</span><br><span class="line">change lock</span><br><span class="line">reset count</span><br><span class="line">---</span><br><span class="line">unlock TCLock [BOOM!]</span><br></pre></td></tr></table></figure><h1 id="2nd-try"><a href="#2nd-try" class="headerlink" title="2nd try"></a>2nd try</h1><p>I changed to 2 counters, one for threads entering, one for leaving</p><p>Now it’s passing the test (for a few times, no bug yet)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slock_lock</span><span class="params">(struct slock_struct *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> count = atomic_read(&amp;lock-&gt;count_in);</span><br><span class="line">        <span class="keyword">if</span>(count &lt; SWITCH_THRESHOLD) &#123;</span><br><span class="line">            <span class="keyword">if</span>(atomic_cmpxchg_acquire(&amp;lock-&gt;count_in, count, count+<span class="number">1</span>) == count) &#123;</span><br><span class="line">                <span class="comment">// Underlaying lock</span></span><br><span class="line">                slock_lock_chosen(lock);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slock_unlock</span><span class="params">(struct slock_struct *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    slock_unlock_chosen(lock);</span><br><span class="line">    <span class="comment">// Try increase counter</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> count = atomic_read(&amp;lock-&gt;count_out);</span><br><span class="line">        <span class="keyword">if</span>(atomic_cmpxchg_acquire(&amp;lock-&gt;count_out, count, count+<span class="number">1</span>) == count)&#123;</span><br><span class="line">          <span class="comment">// Hit threshold</span></span><br><span class="line">            <span class="keyword">if</span>(count == SWITCH_THRESHOLD<span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="comment">// Switch lock</span></span><br><span class="line">                <span class="keyword">if</span>(lock-&gt;type == TAS)&#123;</span><br><span class="line">                    lock-&gt;type = KOMB;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    lock-&gt;type = TAS;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Reset count</span></span><br><span class="line">                <span class="keyword">int</span> count_out = atomic_cmpxchg_release(&amp;lock-&gt;count_out, SWITCH_THRESHOLD, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (count_out != SWITCH_THRESHOLD)&#123;</span><br><span class="line">                  print_debug(<span class="string">&quot;!!!!!!!!!!!!!RESET COUNT ERROR, count_in=%d&quot;</span>, count_out);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> count_in = atomic_cmpxchg_release(&amp;lock-&gt;count_in, SWITCH_THRESHOLD, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (count_in != SWITCH_THRESHOLD)&#123;</span><br><span class="line">                  print_debug(<span class="string">&quot;!!!!!!!!!!!!!RESET COUNT ERROR, count_in=%d&quot;</span>, count_in);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;I’m using 2 locks: TAS &amp;amp; TCLock, I want to maintain a counter of how many times the locks are called, and switch lock when it hits so
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="lock" scheme="https://coconutnutx.github.io/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>TCLocks Note</title>
    <link href="https://coconutnutx.github.io/2023/09/14/tclocks-note/"/>
    <id>https://coconutnutx.github.io/2023/09/14/tclocks-note/</id>
    <published>2023-09-14T10:09:23.000Z</published>
    <updated>2023-09-14T10:09:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><a class="link"   href="https://rs3lab.github.io/assets/papers/2023/gupta:tclocks.pdf" >paper<i class="fas fa-external-link-alt"></i></a> <a class="link"   href="https://github.com/rs3lab/TCLocks" >repo<i class="fas fa-external-link-alt"></i></a></p><h1 id="Repo-structure"><a href="#Repo-structure" class="headerlink" title="Repo structure"></a>Repo structure</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── scripts                           </span><br><span class="line">│   ├── run-*-benchmark.sh         // run benchmarks(host)</span><br><span class="line">│   └── run-vm.sh                  // run VM(host)</span><br><span class="line">└── src</span><br><span class="line">    ├── defaults.sh                // configure VM cores</span><br><span class="line">    ├── benchmarks</span><br><span class="line">    ├── kernel</span><br><span class="line">    │   ├── linux-5.14.16</span><br><span class="line">    │   └── rcuht</span><br><span class="line">    │       ├── rcuht.c            // lock interface</span><br><span class="line">    │       ├── run-rcuht-*.sh     // run rcuhashbash test(guest, called by benchmarks)</span><br><span class="line">    │       ├── include</span><br><span class="line">    │       │   ├── lib</span><br><span class="line">    │       │   ├── mutex</span><br><span class="line">    │       │   ├── rwlock</span><br><span class="line">    │       │   ├── rwsem</span><br><span class="line">    │       │   └── spinlock</span><br><span class="line">    │       ├── lib</span><br><span class="line">    │       ├── locks              // lock implementation</span><br><span class="line">    │       └── script</span><br><span class="line">    └── userspace</span><br></pre></td></tr></table></figure><h1 id="TCLock-implementation"><a href="#TCLock-implementation" class="headerlink" title="TCLock implementation"></a>TCLock implementation</h1><p>Listing 1 in paper</p><p>code: komb.h, komb.c</p><h2 id="spin-lock"><a href="#spin-lock" class="headerlink" title="spin_lock"></a>spin_lock</h2><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2023/screencapture2023-09-14 PM12.20.06.jpg"                      width=500                ><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">komb_spin_lock(struct qspinlock *lock)</span><br><span class="line">&#123;</span><br><span class="line">u32 val, cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">komb_node</span> *<span class="title">curr_node</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Try to acquire TAS lock</span></span><br><span class="line">val = atomic_cmpxchg_acquire(&amp;lock-&gt;val, <span class="number">0</span>, _Q_LOCKED_VAL);</span><br><span class="line">  <span class="comment">//                                    expected value: 0, new value: _Q_LOCKED_VAL</span></span><br><span class="line">  <span class="comment">// if &amp;lock-&gt;val is 0: &amp;lock-&gt;val = 0, val = 0</span></span><br><span class="line">  <span class="comment">// if &amp;lock-&gt;val is not 0:             val = &amp;lock-&gt;val</span></span><br><span class="line"><span class="keyword">if</span> (val == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// Got the lock, return directly, then execute critical setion</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  curr_node = this_cpu_ptr(&amp;komb_nodes[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// Begin slow path function</span></span><br><span class="line">  komb_spin_lock_slowpath(lock); <span class="comment">// Switch stack in this function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch-stack"><a href="#switch-stack" class="headerlink" title="switch_stack"></a>switch_stack</h2><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2023/screencapture2023-09-14 PM2.32.19.jpg"                      width=500                ><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">komb_spin_lock_slowpath(struct qspinlock *lock)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> ret_val;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 26 switch_to_ephemeral_stack(cst.node) # Main → ephemeral stack</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Inline assembly</span></span><br><span class="line">  <span class="comment">// push register values to stack</span></span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;pushq %%rbp\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="string">&quot;pushq %%rbx\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="string">&quot;pushq %%r12\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="string">&quot;pushq %%r13\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="string">&quot;pushq %%r14\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="string">&quot;pushq %%r15\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">     :</span></span></span><br><span class="line"><span class="params"><span class="function">     :</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="comment">// indicate this inline assembly may affect memory</span></span></span></span><br><span class="line"><span class="params"><span class="function">     : <span class="string">&quot;memory&quot;</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="comment">// call function get_komb_node</span></span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="comment">// %P0 is a placeholder for the first input operation</span></span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="comment">// will be replaced by the address of funtion get_komb_node</span></span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="string">&quot;callq %P0\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="comment">// move the value of stack pointer &#x27;rsp&#x27; to &#x27;%c1(%%rax)&#x27;</span></span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="string">&quot;movq %%rsp, %c1(%%rax)\n&quot;</span> </span></span></span><br><span class="line"><span class="params"><span class="function">     :</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="comment">// indicate the value of input parameter %P0, %c1</span></span></span></span><br><span class="line"><span class="params"><span class="function">     : <span class="string">&quot;i&quot;</span>(get_komb_node), <span class="string">&quot;i&quot;</span>(offsetof(struct komb_node, rsp))</span></span></span><br><span class="line"><span class="params"><span class="function">     : <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="comment">// call function get_shadow_stack_ptr</span></span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="string">&quot;callq %P0\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="comment">// use the value in &#x27;rax&#x27; as address, get a value, and save to &#x27;rsp&#x27;</span></span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="string">&quot;movq (%%rax), %%rsp\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">     :</span></span></span><br><span class="line"><span class="params"><span class="function">     : <span class="string">&quot;i&quot;</span>(get_shadow_stack_ptr)</span></span></span><br><span class="line"><span class="params"><span class="function">     : <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 27 lock_slowpath(lock, cst)</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  ret_val = __komb_spin_lock_slowpath(lock);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 28 switch_from_ephemeral_stack(cst.node) # Ephemeral → main stack</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  <span class="keyword">if</span> (ret_val) &#123;  <span class="comment">// <span class="doctag">TODO:</span> what is ret_val?</span></span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;callq %P0\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="string">&quot;movq (%%rax), %%rsp\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="string">&quot;popq %%r15\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="string">&quot;popq %%r14\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="string">&quot;popq %%r13\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="string">&quot;popq %%r12\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="string">&quot;popq %%rbx\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="string">&quot;popq %%rbp\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="string">&quot;retq\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">     :</span></span></span><br><span class="line"><span class="params"><span class="function">     : <span class="string">&quot;i&quot;</span>(get_shadow_stack_ptr)</span></span></span><br><span class="line"><span class="params"><span class="function">     : <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">asm</span> <span class="keyword">volatile</span>(<span class="string">&quot;callq %P0\n&quot;</span></span><br><span class="line">     <span class="string">&quot;movq %%rsp, (%%rax)\n&quot;</span></span><br><span class="line">     :</span><br><span class="line">     : <span class="string">&quot;i&quot;</span>(get_shadow_stack_ptr)</span><br><span class="line">     : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;callq %P0\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="string">&quot;movq %c1(%%rax), %%rsp\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">     :</span></span></span><br><span class="line"><span class="params"><span class="function">     : <span class="string">&quot;i&quot;</span>(get_komb_node),</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="string">&quot;i&quot;</span>(offsetof(struct komb_node, rsp))</span></span></span><br><span class="line"><span class="params"><span class="function">     : <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;popq %%r15\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="string">&quot;popq %%r14\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="string">&quot;popq %%r13\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="string">&quot;popq %%r12\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="string">&quot;popq %%rbx\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="string">&quot;popq %%rbp\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="string">&quot;retq\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">     :</span></span></span><br><span class="line"><span class="params"><span class="function">     :</span></span></span><br><span class="line"><span class="params"><span class="function">     : <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lock-slowpath"><a href="#lock-slowpath" class="headerlink" title="lock_slowpath"></a>lock_slowpath</h2><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2023/screencapture2023-09-14 PM3.03.57.jpg"                      width=500                ><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">__komb_spin_lock_slowpath(struct qspinlock *lock)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">komb_node</span> *<span class="title">curr_node</span>;</span></span><br><span class="line"><span class="keyword">int</span> tail, idx;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get qnode</span></span><br><span class="line">curr_node = this_cpu_ptr(&amp;komb_nodes[<span class="number">0</span>]);</span><br><span class="line">idx = curr_node-&gt;count++;</span><br><span class="line">tail = encode_tail(smp_processor_id(), idx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize waiter&#x27;s qnode</span></span><br><span class="line">curr_node-&gt;locked = <span class="literal">true</span>;</span><br><span class="line">curr_node-&gt;completed = <span class="literal">false</span>;</span><br><span class="line">curr_node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">curr_node-&gt;tail = tail;</span><br><span class="line">curr_node-&gt;socket_id = numa_node_id();</span><br><span class="line">curr_node-&gt;cpuid = smp_processor_id();</span><br><span class="line">curr_node-&gt;irqs_disabled = <span class="literal">false</span>;</span><br><span class="line">curr_node-&gt;lock = lock;</span><br><span class="line">curr_node-&gt;task_struct_ptr = current;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> __komb_spin_lock_longjmp(lock, tail, curr_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase 1"></a>Phase 1</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2023/screencapture2023-09-14 PM3.04.48.jpg"                      width=500                ><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">__komb_spin_lock_longjmp(struct qspinlock *lock, <span class="keyword">int</span> tail,</span><br><span class="line"> <span class="keyword">register</span> struct komb_node *curr_node)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">komb_node</span> *<span class="title">prev_node</span> =</span> <span class="literal">NULL</span>, *next_node = <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qspinlock</span> *<span class="title">parent_lock</span>;</span></span><br><span class="line"><span class="keyword">int</span> old_tail, val, j;</span><br><span class="line">  <span class="keyword">uint32_t</span> prev_cs_cpu;</span><br><span class="line"><span class="keyword">bool</span> prev_locked_val;</span><br><span class="line"><span class="keyword">uint64_t</span> prev_rsp;</span><br><span class="line"><span class="keyword">uint64_t</span> prev_counter_val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">komb_node</span> *<span class="title">prev_next_node_ptr</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 36 qprev = SWAP(&amp;lock.tail, &amp;qnode) </span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  <span class="comment">// Add node to tail</span></span><br><span class="line">  old_tail = xchg_tail(lock, tail);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// If queue is not empty</span></span><br><span class="line"><span class="keyword">if</span> (old_tail &amp; _Q_TAIL_MASK) &#123;</span><br><span class="line">    <span class="comment">// Add qnode to tail</span></span><br><span class="line">prev_node = decode_tail(old_tail);</span><br><span class="line">prev_node-&gt;next = curr_node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 39 while qnode.wait is True:</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line"><span class="comment">// Wait on qnode.wait</span></span><br><span class="line">smp_cond_load_relaxed_sched(&amp;curr_node-&gt;locked, !(VAL));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shadow_stack</span> *<span class="title">ptr</span> =</span> this_cpu_ptr(&amp;local_shadow_stack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 41 if qnode.request == PRCSD :</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="comment">// Check if request has been processed (critical section executed by combiner)</span></span><br><span class="line"><span class="keyword">if</span> (curr_node-&gt;completed) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Phase 2</span></span><br><span class="line">  ...</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Phase 3</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase 2"></a>Phase 2</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2023/screencapture2023-09-14 PM3.05.06.jpg"                      width=500                ><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Now waiter is at the head of the queue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * we&#x27;re at the head of the waitqueue, wait for the owner &amp; pending to</span></span><br><span class="line"><span class="comment"> * go away.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * *,x,y -&gt; *,0,0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * this wait loop must use a load-acquire such that we match the</span></span><br><span class="line"><span class="comment"> * store-release that clears the locked bit and create lock</span></span><br><span class="line"><span class="comment"> * sequentiality; this is because the set_locked() function below</span></span><br><span class="line"><span class="comment"> * does not imply a full barrier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// Want to read &amp;lock-&gt;val</span></span><br><span class="line"><span class="comment">// !(VAL &amp; _Q_LOCKED_PENDING_MASK) is a condition</span></span><br><span class="line"><span class="comment">// when condition is true, read the value and save it to val</span></span><br><span class="line">val = atomic_cond_read_acquire(&amp;lock-&gt;val,</span><br><span class="line">             !(VAL &amp; _Q_LOCKED_PENDING_MASK));</span><br></pre></td></tr></table></figure><p>TODO: load acquire?</p><h3 id="Phase-3"><a href="#Phase-3" class="headerlink" title="Phase 3"></a>Phase 3</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2023/screencapture2023-09-14 PM3.05.24.jpg"                      width=500                ><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * claim the lock:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * n,0,0 -&gt; 0,0,1 : lock, uncontended</span></span><br><span class="line"><span class="comment"> * *,*,0 -&gt; *,*,1 : lock, contended</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the queue head is the only one in the queue (lock value == tail)</span></span><br><span class="line"><span class="comment"> * and nobody is pending, clear the tail code and grab the lock.</span></span><br><span class="line"><span class="comment"> * Otherwise, we only need to grab the lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 52 if CAS(&amp;lock.tail, qnode, None) == qnode:</span></span><br><span class="line"><span class="comment">* 53 return # If only one in the queue, return</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">if</span> (((val &amp; _Q_TAIL_MASK) == tail) &amp;&amp;</span><br><span class="line">    atomic_try_cmpxchg_relaxed(&amp;lock-&gt;val, &amp;val, _Q_LOCKED_VAL))</span><br><span class="line">  <span class="keyword">goto</span> release; <span class="comment">/* No contention */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Either somebody is queued behind us or _Q_PENDING_VAL is set */</span></span><br><span class="line"><span class="comment">// Declare combining phase (line 63 in pesudocode)</span></span><br><span class="line">check_and_set_combiner(lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * contended path; wait for next if not observed yet, release.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 54 qnext = qnode.next</span></span><br><span class="line"><span class="comment">* 55 while qnext is None:</span></span><br><span class="line"><span class="comment">* 56   qnext = qnode.next</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="comment">// Wait until qnext is get</span></span><br><span class="line">smp_cond_load_relaxed_sched(&amp;curr_node-&gt;next, (VAL));</span><br><span class="line">next_node = curr_node-&gt;next;</span><br><span class="line"></span><br><span class="line">run_combiner(lock, next_node);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">run_combiner(struct qspinlock *lock, struct komb_node *curr_node)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">komb_node</span> *<span class="title">next_node</span> =</span> curr_node-&gt;next;</span><br><span class="line"><span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 58 if qnext.next == None:</span></span><br><span class="line"><span class="comment">* 59 notify_next_queue_head(qnext) # next waiter is combiner</span></span><br><span class="line"><span class="comment">* 60 return</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  <span class="comment">// &lt;2 nodes in the queue, return</span></span><br><span class="line"><span class="keyword">if</span> (next_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">set_locked(lock);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Make this node spin on the locked variable and then it will </span></span><br><span class="line"><span class="comment"> * become the combiner.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">curr_node-&gt;locked = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Phase 4</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Phase-4"><a href="#Phase-4" class="headerlink" title="Phase 4"></a>Phase 4</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2023/screencapture2023-09-14 PM3.48.12.jpg"                      width=500                ><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shadow_stack</span> *<span class="title">ptr</span> =</span> this_cpu_ptr(&amp;local_shadow_stack);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare combining phase already done in Phase 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 65 while True: # Combiner loop</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">while</span> (curr_node) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">  next_node = get_next_node(curr_node);</span><br><span class="line">  execute_cs(lock, curr_node);</span><br><span class="line">  clear_locked_set_completed(curr_node);</span><br><span class="line">  <span class="keyword">if</span> (next_node == <span class="literal">NULL</span> || next_node-&gt;next == <span class="literal">NULL</span> ||</span><br><span class="line">      counter &gt;= komb_batch_size)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  curr_node = next_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Combining phase over, set lock, run its own critical section</span></span><br><span class="line">set_locked(lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Make this node spin on the locked variable and then it will become </span></span><br><span class="line"><span class="comment"> * the combiner.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">next_node-&gt;locked = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h2 id="spin-unlock"><a href="#spin-unlock" class="headerlink" title="spin_unlock"></a>spin_unlock</h2><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2023/screencapture2023-09-14 PM3.51.31.jpg"                      width=500                ><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">komb_spin_unlock(struct qspinlock *lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Not in combining phase, unlock and return</span></span><br><span class="line"><span class="keyword">if</span> (lock-&gt;locked == _Q_LOCKED_VAL ||</span><br><span class="line">    lock-&gt;locked == _Q_LOCKED_IRQ_VAL) &#123;</span><br><span class="line">lock-&gt;locked = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">shadow_stack</span> *<span class="title">ptr</span> =</span> this_cpu_ptr(&amp;local_shadow_stack);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">komb_node</span> *<span class="title">curr_node</span> =</span> per_cpu_ptr(&amp;komb_nodes[<span class="number">0</span>], from_cpuid);</span><br><span class="line">incoming_rsp_ptr = &amp;(ptr-&gt;local_shadow_stack_ptr);</span><br><span class="line">outgoing_rsp_ptr = &amp;(curr_node-&gt;rsp);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Jumo back to combiner</span></span><br><span class="line">komb_context_switch(incoming_rsp_ptr, outgoing_rsp_ptr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Global-lock"><a href="#Global-lock" class="headerlink" title="Global lock"></a>Global lock</h1><h2 id="Lock-struct"><a href="#Lock-struct" class="headerlink" title="Lock struct"></a>Lock struct</h2><p>Top level lock, MCS queue</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">orig_qspinlock</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">      <span class="keyword">atomic_t</span> val;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        u8 locked;</span><br><span class="line">        u8 pending;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        u16 locked_pending;</span><br><span class="line">        u16 tail;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Acquire"><a href="#Acquire" class="headerlink" title="Acquire"></a>Acquire</h2><h3 id="In-spin-lock"><a href="#In-spin-lock" class="headerlink" title="In spin_lock()"></a>In spin_lock()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val = atomic_cmpxchg_acquire(&amp;lock-&gt;val, <span class="number">0</span>, _Q_LOCKED_VAL);</span><br><span class="line"><span class="keyword">if</span> (val == <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>Fastpath: is val == 0 , get the lock</p><h3 id="In-phase-2"><a href="#In-phase-2" class="headerlink" title="In phase 2"></a>In phase 2</h3><p>Now current node is notified by the previous node</p><p>Its CS is not executed</p><p>Wants to aquire global lock</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * we&#x27;re at the head of the waitqueue, wait for the owner &amp; pending to</span></span><br><span class="line"><span class="comment"> * go away.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * *,x,y -&gt; *,0,0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * this wait loop must use a load-acquire such that we match the</span></span><br><span class="line"><span class="comment"> * store-release that clears the locked bit and create lock</span></span><br><span class="line"><span class="comment"> * sequentiality; this is because the set_locked() function below</span></span><br><span class="line"><span class="comment"> * does not imply a full barrier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">val = atomic_cond_read_acquire(&amp;lock-&gt;val, !(VAL &amp; _Q_LOCKED_PENDING_MASK));</span><br></pre></td></tr></table></figure><p>Since</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomic_cond_read_acquire(v, c) smp_cond_load_acquire(&amp;(v)-&gt;counter, (c))</span></span><br></pre></td></tr></table></figure><p>This actucally calls smp_cond_load_acquire()</p><p>-&gt; refer to: <a class="link"   href="https://www.kernel.org/doc/html/latest/core-api/wrappers/memory-barriers.html" >https://www.kernel.org/doc/html/latest/core-api/wrappers/memory-barriers.html<i class="fas fa-external-link-alt"></i></a></p><p>When lock is not pending, read lock value, add ACQUIRE barrier?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * set_locked - Set the lock bit and own the lock</span></span><br><span class="line"><span class="comment"> * @lock: Pointer to queued spinlock structure</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * *,*,0 -&gt; *,0,1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> <span class="title">set_locked</span><span class="params">(struct qspinlock *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WRITE_ONCE(lock-&gt;locked, _Q_LOCKED_VAL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>…reading <a class="link"   href="https://deepdives.medium.com/kernel-locking-deep-dive-into-spinlocks-part-1-bcdc46ee8df6" >https://deepdives.medium.com/kernel-locking-deep-dive-into-spinlocks-part-1-bcdc46ee8df6<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a class=&quot;link&quot;   href=&quot;https://rs3lab.github.io/assets/papers/2023/gupta:tclocks.pdf&quot; &gt;paper&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="lock" scheme="https://coconutnutx.github.io/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP复习</title>
    <link href="https://coconutnutx.github.io/2023/01/08/tcpip/"/>
    <id>https://coconutnutx.github.io/2023/01/08/tcpip/</id>
    <published>2023-01-08T15:57:24.000Z</published>
    <updated>2023-01-08T15:57:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>每一年前3题套路基本是一样的，重点：</p><ol><li>IP地址&amp;路由（问请求的souce/dest、配置network box为NAT/proxy/VLAN switch后的变化）</li><li>BGP（E-BGP和I-BGP，OSPF）</li><li>拥塞控制3种分配流量的方法</li></ol><p>第四题每年有些变化，大部分有IPv6-IPv4 interworking、IP multicast相关内容</p><h1 id="五层体系结构"><a href="#五层体系结构" class="headerlink" title="五层体系结构"></a>五层体系结构</h1><ul><li>application：HTTP、DNS</li><li>transport：TCP、IP</li><li>network：IP</li><li>link<ul><li>MAC：ARP</li></ul></li><li>physical</li></ul><h1 id="缩写和概念"><a href="#缩写和概念" class="headerlink" title="缩写和概念"></a>缩写和概念</h1><ul><li>DNS<ul><li>A/AAAA record：前者用于将域名映射到IPv4地址，后者IPv6<ul><li>如果有一个网站不知道用v4还是v6，可以用DNS，根据收到的record类型分辨</li></ul></li></ul></li><li>TCP<ul><li>MSS：Maximum Segment Size，指每个数据报所能携带的最大数据量</li><li>ECN：Explicit Congestion Notification，在数据包中添加特殊的标记，表示数据包可能会在传输过程中丢失，源端收到后，降低发送速率，从而减轻网络拥塞</li></ul></li><li>IP<ul><li>address prefix delegation through DHCPv6：在 IPv6 网络中，地址分配由 DHCPv6 服务器完成。当一个客户端连接到网络时，它会发送一个 Solicit 消息给 DHCPv6 服务器，请求获取一个地址前缀。如果 DHCPv6 服务器认为该请求是合法的，它会向该客户端发送一个 Advertise 消息，提供一个地址前缀。客户端收到的地址前缀可以用于分配其他地址。</li></ul></li><li>ARP：根据IP地址查询MAC地址<ul><li>Proxy ARP：主机A和B位于不同局域网（通常需要通过路由进行通信），可以用Proxy ARP设置路由器作为代理，接收ARP请求并返回虚拟的MAC地址</li></ul></li><li>路由<ul><li>IGP：Interior Gateway Protocol，AS内使用<ul><li>RIP：Routing Information Protocol，基于距离向量</li><li>OSPF：用Dijkstra计算最短路径</li></ul></li><li>EGP：Exterior Gateway Protocol，AS间使用<ul><li>BGP：Border Gateway Protocol</li></ul></li><li>距离向量路由算法<ul><li>route poisoning：当一个路由器发现某条路径不可用时，向相邻路由器发送带有较大距离的路由信息，表示该路径不可用</li></ul></li></ul></li><li>Stub network：指一种特殊类型的路由器，它只有一条出边（或者说只连向一个直接的邻居）。在这样的网络中，所有的数据包都会通过默认网关转发，而不是进行多跳转发</li></ul><h1 id="套路"><a href="#套路" class="headerlink" title="套路"></a>套路</h1><h2 id="第一题：IP、路由"><a href="#第一题：IP、路由" class="headerlink" title="第一题：IP、路由"></a>第一题：IP、路由</h2><h3 id="subnet-mask"><a href="#subnet-mask" class="headerlink" title="subnet mask"></a>subnet mask</h3><ul><li><p>不能太长：保证同一LAN内前缀相同</p></li><li><p>不能太短：避免不同LAN内前缀相同</p><ul><li>不同LAN前缀相同的问题：The hosts will think that other hosts are on the same LAN, and will try using ARP to get their MAC addresses. To solve this, one solution is to use proxy ARP in all routers X1, X2, X3, X4 .</li></ul></li><li><p>不同LAN中，长度可以不同</p></li></ul><h3 id="ping-request-ARP"><a href="#ping-request-ARP" class="headerlink" title="ping request/ARP"></a>ping request/ARP</h3><ul><li><p>ping的过程</p><ol><li><p>查询本地路由表，看ping的是内网还是外网地址</p></li><li><p>如果是内网地址</p><ol><li><p>查询ARP缓存，如果有，直接返回ICMP reply</p></li><li><p>如果缓存没有，用ARP协议在LAN内广播，要求拥有指定IP地址的主机回复自己的MAC地址</p><ul><li><p>ARP的可见范围是LAN内</p></li><li><p>如果收到，加入ARP缓存，返回ICMP reply</p></li></ul></li></ol></li><li><p>如果是外网地址</p><ol><li><p>ARP请求的IP目的地址是路由器的IP地址</p></li><li><p>路由器转发请求到外网</p><ul><li>路由器可能再次用ARP协议，查找目标主机的MAC地址</li></ul></li></ol></li></ol></li><li><p>注意network boxs的配置，是bridge还是router</p><ul><li>只有过router才减少TTL/HC，bridge不减（易错：host和router相连的一段没注意，直接填了64）</li><li>如果是bridge<ul><li>注意内网有没有环，如果有，要先用spanning tree algorithm，禁用部分链接</li><li>内网可以经过多个bridge，直接发给目标MAC地址（易错：把bridge看成router，填了bridge的MAC）</li></ul></li></ul></li></ul><h3 id="request经过NAT-proxy-VLAN-switch的变化"><a href="#request经过NAT-proxy-VLAN-switch的变化" class="headerlink" title="request经过NAT/proxy/VLAN switch的变化"></a>request经过NAT/proxy/VLAN switch的变化</h3><ul><li><p>NAT：建立{内网IP和端口，外网IP和端口}的对应</p><ul><li>内网向外发请求时，正常用自己的地址，像没有NAT一样</li><li>外网向内发请求时，用NAT翻译后的地址，像内网的主机不存在一样<ul><li>外网的C想ping内网的A，直接ping翻译后的地址即可</li></ul></li><li>TCP，丢包，source负责重发，NAT不负责</li></ul></li><li><p>application layer gateway, acting as web proxy</p><ul><li>host向server发请求时，发给proxy，像server不存在一样</li><li>server像host发请求时，发给proxy，像host不存在一样</li><li>proxy转发host的请求时，不同的host用不同的端口</li></ul></li><li><p>VLAN switch：将原本相连的网络分成不同的VLAN，通信必须经过路由器</p><ul><li>如果2个VLAN链接到同一个路由，可以：configure the Y1 interface of the router with two different IP addresses, each belonging to a different VLAN</li></ul></li><li><p>题目中有ping request和HTTP两种，地址变化都一样</p><ul><li>HTTP的protocol是TCP</li><li>HTTP over QUIC则protocol是UDP</li></ul></li></ul><p>🌰 A/B都用端口4567通过HTTP从服务器S下载文件，经过X</p><ol><li><p>当X是NAT</p><ul><li><p>A/B到X段观察（内网）</p><ul><li><p>A/B发送的包（仿佛没有X，直接发给S一样）</p><table><thead><tr><th>IP source</th><th>IP dest</th><th>protocol</th><th>source port</th><th>dest port</th></tr></thead><tbody><tr><td>A/B</td><td>S</td><td>TCP</td><td>4567</td><td>80</td></tr></tbody></table></li><li><p>S发送的包（仿佛没有经过X，直接发给A/B一样）</p><table><thead><tr><th>IP source</th><th>IP dest</th><th>protocol</th><th>source port</th><th>dest port</th></tr></thead><tbody><tr><td>S</td><td>A/B</td><td>TCP</td><td>80</td><td>4567</td></tr></tbody></table></li><li><p>X到S段观察（外网，NAT转换后）</p><ul><li><p>A/B发送的包</p><table><thead><tr><th>IP source</th><th>IP dest</th><th>protocol</th><th>source port</th><th>dest port</th></tr></thead><tbody><tr><td>X</td><td>S</td><td>TCP</td><td>23456/23457</td><td>80</td></tr></tbody></table></li><li><p>S发送的包（先发给X，用X的IP，和不同的端口号）</p><table><thead><tr><th>IP source</th><th>IP dest</th><th>protocol</th><th>source port</th><th>dest port</th></tr></thead><tbody><tr><td>S</td><td>X</td><td>TCP</td><td>80</td><td>23456/23457</td></tr></tbody></table></li></ul></li></ul></li></ul></li></ol><p>​    实际上就是在NAT处做了一个地址映射，将A,4567换成X,23456，将B:4567换成X,23457</p><p>​    从A/B的视角，没有X，以为是直接和S通信</p><p>​    从S的视角，没有A/B</p><ol start="2"><li><p>当X是application layer gateway, acting as web proxy</p><ul><li><p>A/B到X段观察</p><ul><li><p>A/B发送的包</p><table><thead><tr><th>IP source</th><th>IP dest</th><th>protocol</th><th>source port</th><th>dest port</th></tr></thead><tbody><tr><td>A/B</td><td>X的内网IP</td><td>TCP</td><td>4678</td><td>8080</td></tr></tbody></table></li></ul></li><li><p>X到S段观察</p><ul><li><p>A/B发送的包</p><table><thead><tr><th>IP source</th><th>IP dest</th><th>protocol</th><th>source port</th><th>dest port</th></tr></thead><tbody><tr><td>X的外网IP</td><td>S</td><td>TCP</td><td>8923/8924</td><td>80</td></tr></tbody></table></li></ul></li></ul></li></ol><p>​    从A/B的视角，没有S（以为X就是S）</p><p>​    X收到A/B的请求后，从不同端口转发给S</p><p>​    从S的视角，没有A/B</p><h3 id="路由表配置"><a href="#路由表配置" class="headerlink" title="路由表配置"></a>路由表配置</h3><p>路由器的routing table需要的几列：</p><table><thead><tr><th>Destination Network</th><th>Interface</th><th>Gateway</th></tr></thead><tbody><tr><td>10.1/16</td><td>Xw VLAN A</td><td>onlink</td></tr><tr><td>10.2/16</td><td>Xw VLAN B</td><td>onlink</td></tr><tr><td>9/8</td><td>Xe</td><td>onlink</td></tr></tbody></table><ul><li><p>Interface是该路由器的网络接口</p><ul><li>通常以eth0、eth1、eth2等命名，表示网卡的编号</li></ul></li><li><p>如果需要其它路由器转发，gateway填其它路由器的IP</p></li></ul><h2 id="第二题：BGP-OSPF"><a href="#第二题：BGP-OSPF" class="headerlink" title="第二题：BGP/OSPF"></a>第二题：BGP/OSPF</h2><p>注意：BGP next hop是AS外部的地址，不一定直接连接，而OSPF next hop是相邻的地址</p><p>注意：题目给定的OSPF cost是一个常数，还是cost to BGP next hop加一个常数</p><h3 id="Adj-RIB-in-out"><a href="#Adj-RIB-in-out" class="headerlink" title="Adj-RIB-in/out"></a>Adj-RIB-in/out</h3><p>当运行BGP的路由器收到更新时，会更新这两个表</p><p>Adj-RIB-in的列：</p><table><thead><tr><th></th><th>Destination network</th><th>AS path</th><th>Next hop</th><th></th></tr></thead><tbody><tr><td>from C1</td><td>66.66/16</td><td>C E F</td><td>30.20.0.3</td><td>best</td></tr><tr><td>from C1</td><td>66.66.0/17</td><td>C E F</td><td>30.20.0.3</td><td>best</td></tr></tbody></table><p>Adj-RIB-out包含best的几行</p><p>*如果上面的路由B1转发给另一个路由B2，next hop不变，仍是AS外的地址</p><p>*out只转发通过E-BGP得到的路径（不转发I-GBP得到的）</p><h3 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h3><p>BGP如何选择最优路线的Decision process，几项常用的（详见Exam booklet）：</p><ol><li>Shortest AS-PATH</li><li>E-BGP&gt;I-BGP</li><li>Shortest path to NEXT-HOP, according to IGP</li><li>Lowest BGP identifier</li></ol><p>Q：假设一个AS中只有部分路由器运行BGP，它们不re-distribute BGP into the interior routing protocol，如何让其他路由器也能知道外部的路径？</p><p>A：方法一：By configuring default gateway on all other routers. Drawback: Can not cope with link-failures. 方法二：By running BGP on all routers. Drawback: Expensive</p><h3 id="Distance-vector-routing"><a href="#Distance-vector-routing" class="headerlink" title="Distance vector routing"></a>Distance vector routing</h3><p>🌰 关于更新</p><p>假设有连接A-B-net1-C-net2，原本cost都是1</p><p>原本A的路由表中有：</p><table><thead><tr><th>Destination network</th><th>Next hop</th><th>Distance</th></tr></thead><tbody><tr><td>net1</td><td>IP of B</td><td>2</td></tr><tr><td>net2</td><td>IP of B</td><td>3</td></tr></tbody></table><p>此时B告诉A：B到直接相连的net1的cost变成了6，A的路由表变成：</p><table><thead><tr><th>Destination network</th><th>Next hop</th><th>Distance</th></tr></thead><tbody><tr><td>net1</td><td>IP of B</td><td>7</td></tr><tr><td>net2</td><td>IP of B</td><td>3</td></tr></tbody></table><p>由于routing protocol还没有converge，其它暂时不变</p><h3 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h3><p>在某一节点，对某一目的地，BGP会根据Decision process选出最优路径，但OSPF可能会算出多条equal-cost的路径</p><p>如果有大量packet发到该目的地，一般选择每条路径的可能性相同</p><p>Q：当有多条equal-cost最短路径时，会有什么负面影响？</p><p>A：所有用Dijkstra算法计算出的最短路径都会出现在路由表中。The router then does per-flow load balancing to ensure that packets of the same flow (e.g. same TCP connection) are sent to the same next hop. This is done to improve TCP performance by avoiding reordering of packets at the destination. It is typically achieved using hash functions on flow identifiers (source and destination IP’s and port numbers).</p><p>🌰 关于获得路径的过程</p><p>假设有3个area：</p><ul><li>Area 1：A，B1</li><li>Area 2：B1，B2</li><li>Area 3：B2，C</li></ul><p>C如何获得到A的路径？</p><p>过程：</p><ol><li>B1在area 1内用Dijkstra计算到A的最短路径，然后inject the route into area 2</li><li>B2在area 2内用Dijkstra计算到A的最短路径，然后inject the route into area 3</li><li>C在area 3内用Dijkstra计算到A的最短路径</li></ol><h2 id="第三题：拥塞控制"><a href="#第三题：拥塞控制" class="headerlink" title="第三题：拥塞控制"></a>第三题：拥塞控制</h2><h3 id="max-min-fairness"><a href="#max-min-fairness" class="headerlink" title="max-min fairness"></a>max-min fairness</h3><p>计算方法：water-filling</p><ol><li>mark all sources as non frozen</li><li>Do<ul><li>increase the rate of all non frozen sources to the largest possible common value</li><li>mark sources that use a saturated link as frozen</li></ul></li><li>Until all sources are frozen</li></ol><h3 id="propotional-fairness"><a href="#propotional-fairness" class="headerlink" title="propotional fairness"></a>propotional fairness</h3><p>计算方法<br>$$<br>J(x) = \sum_i{ logx_i }<br>$$</p><p>判断分配是否propotional fair：如果改变分配，变化率符合↓，则符合propotional fairness<br>$$<br>\sum_i\frac{\Delta x_i}{x_i}\le0<br>$$</p><h3 id="TCP-with-ECN"><a href="#TCP-with-ECN" class="headerlink" title="TCP with ECN"></a>TCP with ECN</h3><p>rate和RTT成反比</p><p>TCP Cubic：less sensitive to RTT than Reno</p><h3 id="TCP-Loss-Throughput-Formula"><a href="#TCP-Loss-Throughput-Formula" class="headerlink" title="TCP Loss - Throughput Formula"></a>TCP Loss - Throughput Formula</h3><p>$$<br>𝜃 = \frac{MSS*1.22}{RTT\sqrt{q}}<br>$$</p><p>其中𝜃是throughput，a fraction <em>q</em> of packets is lost，MSS和RTT题目会给</p><p>一般是前一问已经算出𝜃，问q</p><p>注意单位，s和bit，1 MB=10^6 bit</p><h2 id="第四题：IPv4和IPv6"><a href="#第四题：IPv4和IPv6" class="headerlink" title="第四题：IPv4和IPv6"></a>第四题：IPv4和IPv6</h2><h3 id="6to4"><a href="#6to4" class="headerlink" title="6to4"></a>6to4</h3><p>IPv6保留地址块<code>2002::/16</code></p><p>IPv4保留地址块<code>192.88.99/24</code>（6to4 relay routers）</p><p>🌰 <code>3.3.3.3</code>-&gt;<code>2002:0303:0303::</code>，default gateway <code>192.88.99.1</code>-&gt;<code>2002:c058:6301::</code></p><h3 id="NAT64"><a href="#NAT64" class="headerlink" title="NAT64"></a>NAT64</h3><p>收到IPv6包后，转发给只支持IPv4的主机，步骤：</p><ol><li>检查NAT64转换表，看是否已经为该IPv6地址分配了IPv4地址</li><li>如果没有，分配地址，将该地址添加到表中，并使用该地址转发IPv4包给目标主机</li></ol><p>*不能用NAT64设备自己的IPv4地址</p><h3 id="IP-multicast"><a href="#IP-multicast" class="headerlink" title="IP multicast"></a>IP multicast</h3><p>当receiver想加入一个multicast  group，它需要发送MLD(Multicast Listener Discovery)消息。其它receiver和server不需要任何操作。</p><p>（还看到一种答案是start a program that listens to the multicast group）</p><p>multicast MAC 地址：</p><ul><li>IPv4：01-00-5e-XX-XX-XX（后23bit）</li><li>IPv6：33-33-XX-XX-XX-XX（后32bit）<ul><li>🌰 <code>ff35::6:7</code> -&gt; <code>33-33-00-06-00-07</code></li></ul></li></ul><h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><p>IPv4：主机/路由器都可以对数据报进行分片</p><p>IPv6：只有主机可以对数据报进行分片</p><p>但是，路由器不会重新组装数据报。这意味着，如果数据报在网络中被分片，则接收方必须自己重新组装数据报。</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>一些错题的知识点</p><p><strong>Protocol type</strong></p><p>in IP header: TCP/UDP</p><p>in Ethernet header: IPv4/IPv6/ARP</p><p><strong>6to4</strong></p><p>A的IPv4地址：3.3.3.3，则：</p><p>A的6to4 IPv6地址：<code>2002:0303:0303:abcd:EUI_A</code></p><p>A的6to4 default gateway’s IPv6地址：2002:c058:6301::（IPv4默认网关192.88.99/24）</p><p><strong>BGP</strong></p><p>R1-B1-B4 R1-B2-B3都跑BGP</p><p>R1 peers with all BGP routers inside AS B</p><p>B4、B3的路线直接I-BGP发给R1，而不是通过B1、B2（不转发I-BGP学到的路径），所以在R1的表里，路径是来自BGP peer B4、B3的</p><p><strong>ARP</strong></p><p>The first ARP packet is broadcast and is sent to all bridges along the tree（MAC dest <code>ff-ff-ff-ff-ff-ff</code>）</p><p>The ARP reply is unicast from dest to source</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;每一年前3题套路基本是一样的，重点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IP地址&amp;amp;路由（问请求的souce/dest、配置network box为NAT/proxy/VLAN switch后的变化）&lt;/li&gt;
&lt;li&gt;BGP（E-BGP和I-BGP，OSPF）&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
  </entry>
  
  <entry>
    <title>Obsidian使用感受2</title>
    <link href="https://coconutnutx.github.io/2022/07/30/obsedian/"/>
    <id>https://coconutnutx.github.io/2022/07/30/obsedian/</id>
    <published>2022-07-30T12:11:51.000Z</published>
    <updated>2022-07-30T12:11:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>半年前的Obsidian<a href="https://coconutnutx.github.io/2022/01/12/note/">使用感受</a></p><p>今天的Obsidian：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/Obsedian202207.jpg"                                     ><p>开始尝试更多使用方法，各种tag、各种布局，文件夹组织方式也换了好几次，现在各种各样的笔记和想法都可以在其中找到容身之地，搜索和筛选功能也很好用。太爱了❤</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;半年前的Obsidian&lt;a href=&quot;https://coconutnutx.github.io/2022/01/12/note/&quot;&gt;使用感受&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天的Obsidian：&lt;/p&gt;
&lt;img  
                     lazyloa
      
    
    </summary>
    
    
      <category term="Memo" scheme="https://coconutnutx.github.io/categories/Memo/"/>
    
    
      <category term="tool" scheme="https://coconutnutx.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>记录vue项目deploy到github page</title>
    <link href="https://coconutnutx.github.io/2022/05/03/vue-deploy/"/>
    <id>https://coconutnutx.github.io/2022/05/03/vue-deploy/</id>
    <published>2022-05-03T18:59:17.000Z</published>
    <updated>2022-05-03T18:59:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下Data Visualization课程project 初版skeleton部署过程</p><h1 id="创建vue工程"><a href="#创建vue工程" class="headerlink" title="创建vue工程"></a>创建vue工程</h1><p>参考<a class="link"   href="https://www.panziye.com/java/web/974.html" >Vue系列入门教程（6）——vue-cli脚手架<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vue create dataviz</span><br><span class="line">cd dataviz</span><br><span class="line">npm install</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure><p>遇到的坑：因为要插图片，打算用plotly生成的html，在vue3中遇到一些奇奇怪怪的问题，最后还是用vue2</p><h1 id="发布vue到github-page"><a href="#发布vue到github-page" class="headerlink" title="发布vue到github page"></a>发布vue到github page</h1><p>参考<a class="link"   href="https://learnvue.co/2020/09/how-to-deploy-your-vue-app-to-github-pages/#how-does-github-pages-work" >How To Deploy Your Vue App to Github Pages<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin ...</span><br><span class="line"></span><br><span class="line">npm run build</span><br><span class="line">git checkout -b gh-pages</span><br><span class="line">git add -f dist</span><br><span class="line">git commit -m &#x27;first commit&#x27;</span><br><span class="line">git subtree push --prefix dist origin gh-pages</span><br></pre></td></tr></table></figure><p>遇到的坑：</p><ol><li><p>一开始用vue run build产生dist文件，index.html本地打开会有跨域bug。但是发布之后就可以了</p></li><li><p>路径问题众说纷纭，最后成功的是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publicPath: process.env.NODE_ENV === &quot;production&quot; ? &quot;/datavis-project-2022-nomorebugs/&quot; : &quot;/&quot;,</span><br></pre></td></tr></table></figure></li></ol><h1 id="Bug-github-page上plotly生成的html不显示"><a href="#Bug-github-page上plotly生成的html不显示" class="headerlink" title="Bug: github page上plotly生成的html不显示"></a>Bug: github page上plotly生成的html不显示</h1><p>原本的资源放在/public/static/world.html</p><p>引用时</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;/static/world.html&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;auto&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100%; height: 500px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>本地跑没问题，但是放到github page上之后404了</p><p>尝试改成</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;static/world.html&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;auto&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100%; height: 500px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 本地可以跑</p><p>发布，搞定！✌️</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录一下Data Visualization课程project 初版skeleton部署过程&lt;/p&gt;
&lt;h1 id=&quot;创建vue工程&quot;&gt;&lt;a href=&quot;#创建vue工程&quot; class=&quot;headerlink&quot; title=&quot;创建vue工程&quot;&gt;&lt;/a&gt;创建vue工程&lt;/h1
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="vue" scheme="https://coconutnutx.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Unity一些杂七杂八的笔记</title>
    <link href="https://coconutnutx.github.io/2022/05/01/unity-note/"/>
    <id>https://coconutnutx.github.io/2022/05/01/unity-note/</id>
    <published>2022-05-01T20:59:08.000Z</published>
    <updated>2022-05-01T20:59:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单Player移动"><a href="#简单Player移动" class="headerlink" title="简单Player移动"></a>简单Player移动</h1><ol><li><p>主摄像头放到Player下</p></li><li><p>加script</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class PlayerController : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    CharacterController controller;</span><br><span class="line">    public float speed = 5;</span><br><span class="line"></span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        controller = GetComponent&lt;CharacterController&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        // movement</span><br><span class="line">        float x = Input.GetAxis(&quot;Horizontal&quot;);</span><br><span class="line">        float z = Input.GetAxis(&quot;Vertical&quot;);</span><br><span class="line"></span><br><span class="line">        Vector3 move = transform.right * x + transform.forward * z;</span><br><span class="line">        controller.Move(move * speed * Time.deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="NPC漫游"><a href="#NPC漫游" class="headerlink" title="NPC漫游"></a>NPC漫游</h1><ol><li><p>导入城市资源</p></li><li><p>给所有物体加Mesh Collider（否则后面检测人行道时<br>Physics.Raycast无法检测）</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/screencapture2022-05-01 PM10.57.41.jpg"                                     ></li><li><p>给人行道设置layer为sidewalk，导航-&gt;对象-&gt;Navigation Static</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/screencapture2022-05-01 PM10.58.15.jpg"                                     ></li><li><p>给桌椅、房子等设置Navigation Static，Not Walkable</p></li><li><p>放一个胶囊当NPC，加组件Nav Mesh Agent</p></li><li><p>加script（ref：<a class="link"   href="https://www.youtube.com/watch?v=UjkSFoLxesw&ab_channel=Dave%2FGameDevelopment" >FULL 3D ENEMY AI in 6 MINUTES! || Unity Tutorial<i class="fas fa-external-link-alt"></i></a>）</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.AI;</span><br><span class="line"></span><br><span class="line">public class CitizenController : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public NavMeshAgent agent;</span><br><span class="line"></span><br><span class="line">    public LayerMask groudMask;</span><br><span class="line"></span><br><span class="line">    // patroling</span><br><span class="line">    Vector3 walkPoint;</span><br><span class="line">    bool walkPointSet;</span><br><span class="line">    public float walkPointRange = 20;</span><br><span class="line"></span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        agent = GetComponent&lt;NavMeshAgent&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        Patroling();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void Patroling()</span><br><span class="line">    &#123;</span><br><span class="line">        if (!walkPointSet) SearchWalkPoint();</span><br><span class="line"></span><br><span class="line">        if (walkPointSet)</span><br><span class="line">            agent.SetDestination(walkPoint);</span><br><span class="line"></span><br><span class="line">        Vector3 distanceToWalkPoint = transform.position - walkPoint;</span><br><span class="line"></span><br><span class="line">        // walkpoint reached</span><br><span class="line">        if (distanceToWalkPoint.magnitude &lt; 1f)</span><br><span class="line">            walkPointSet = false;</span><br><span class="line">      </span><br><span class="line">      // not moving</span><br><span class="line">        if(agent.speed &lt; 1f)</span><br><span class="line">            walkPointSet = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void SearchWalkPoint()</span><br><span class="line">    &#123;</span><br><span class="line">        // calculate random point in range</span><br><span class="line">        float randomZ = Random.Range(-walkPointRange, walkPointRange);</span><br><span class="line">        float randomX = Random.Range(-walkPointRange, walkPointRange);</span><br><span class="line"></span><br><span class="line">        walkPoint = new Vector3(transform.position.x + randomX, transform.position.y, transform.position.z + randomZ);</span><br><span class="line"></span><br><span class="line">        if (Physics.Raycast(walkPoint, -transform.up, 2f, groudMask))</span><br><span class="line">            walkPointSet = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>设置script引用</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/screencapture2022-05-01 PM11.10.42.jpg"                                     >]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简单Player移动&quot;&gt;&lt;a href=&quot;#简单Player移动&quot; class=&quot;headerlink&quot; title=&quot;简单Player移动&quot;&gt;&lt;/a&gt;简单Player移动&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;主摄像头放到Player下&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="unity" scheme="https://coconutnutx.github.io/tags/unity/"/>
    
  </entry>
  
  <entry>
    <title>处理time series笔记</title>
    <link href="https://coconutnutx.github.io/2022/03/11/time-series/"/>
    <id>https://coconutnutx.github.io/2022/03/11/time-series/</id>
    <published>2022-03-11T10:29:10.000Z</published>
    <updated>2022-03-11T10:29:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>Merge the <code>CO2_sensor_measurements.csv</code>, <code>temperature_humidity.csv</code>, and <code>sensors_metadata_updated.csv</code>, into a single dataframe.</p><ul><li>The merged dataframe contains:<ul><li>index: the time instance <code>timestamp</code> of the measurements</li><li>columns: the location of the site <code>LocationName</code>, the sensor ID <code>SensorUnit_ID</code>, the CO2 measurement <code>CO2</code>, the <code>temperature</code>, the <code>humidity</code>, the <code>zone</code>, the <code>altitude</code>, the longitude <code>lon</code> and the latitude <code>lat</code>.</li></ul></li></ul><table><thead><tr><th align="right">timestamp</th><th align="right">LocationName</th><th align="right">SensorUnit_ID</th><th align="right">CO2</th><th align="right">temperature</th><th align="right">humidity</th><th align="right">zone</th><th align="right">altitude</th><th align="right">lon</th><th align="right">lat</th></tr></thead><tbody><tr><td align="right">…</td><td align="right">…</td><td align="right">…</td><td align="right">…</td><td align="right">…</td><td align="right">…</td><td align="right">…</td><td align="right">…</td><td align="right">…</td><td align="right">…</td></tr></tbody></table><ul><li>For each measurement (CO2, humidity, temperature), <strong>take the average over an interval of 30 min</strong>.</li><li>If there are missing measurements, <strong>interpolate them linearly</strong> from measurements that are close by in time.</li></ul><h1 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DATA1 = <span class="string">&#x27;../data/carbosense-raw/CO2_sensor_measurements.csv&#x27;</span></span><br><span class="line">DATA2 = <span class="string">&#x27;../data/carbosense-raw/sensors_metadata_updated.csv&#x27;</span></span><br><span class="line">DATA3 = <span class="string">&#x27;../data/carbosense-raw/temperature_humidity.csv&#x27;</span></span><br><span class="line"></span><br><span class="line">df1 = pd.read_csv(DATA1, parse_dates=[<span class="number">0</span>], sep=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">df2 = pd.read_csv(DATA2)</span><br><span class="line">df3 = pd.read_csv(DATA3, parse_dates=[<span class="number">0</span>], sep=<span class="string">&#x27;\t&#x27;</span>)</span><br></pre></td></tr></table></figure><p>发现df1的timestamp是15分钟间隔，而df3是10分钟间隔，需要先各自取平均，再合并表格</p><h1 id="处理df1-resample-interpolate"><a href="#处理df1-resample-interpolate" class="headerlink" title="处理df1 (resample,interpolate)"></a>处理df1 (resample,interpolate)</h1><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/screencapture2022-03-11 AM11.42.29.jpg"                                     ><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每个传感器，每30min取均值</span></span><br><span class="line"><span class="comment"># 这里要先用groupby，再resample，否则会把所有传感器的数据合到一起</span></span><br><span class="line"><span class="comment"># 得到的结果中有多余的SensorUnit_ID列，好像也取了个均值，变成了float，这里直接drop了</span></span><br><span class="line">df1 = df1.groupby([<span class="string">&#x27;LocationName&#x27;</span>,<span class="string">&#x27;SensorUnit_ID&#x27;</span>]).resample(<span class="string">&#x27;30min&#x27;</span>, on=<span class="string">&#x27;timestamp&#x27;</span>).mean().drop(columns=[<span class="string">&#x27;SensorUnit_ID&#x27;</span>])</span><br><span class="line"><span class="comment"># 按30min为一个间隔重组后，出现一些nan，插值填上</span></span><br><span class="line">df1 = df1.interpolate(method=<span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line"><span class="comment"># 把multiindex拆开</span></span><br><span class="line">df1 = df1.reset_index()</span><br></pre></td></tr></table></figure><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/screencapture2022-03-11 PM5.09.56.jpg"                                     ><h1 id="处理df2"><a href="#处理df2" class="headerlink" title="处理df2"></a>处理df2</h1><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/screencapture2022-03-11 AM11.40.44.jpg"                                     ><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># drop掉不需要的列</span></span><br><span class="line">df2 = df2.drop(columns = [<span class="string">&#x27;Unnamed: 0&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>])</span><br><span class="line"><span class="comment"># 根据结果的需要重命名</span></span><br><span class="line">df2 = df2.rename(columns=&#123;<span class="string">&quot;LON&quot;</span>:<span class="string">&quot;lon&quot;</span>, <span class="string">&quot;LAT&quot;</span>:<span class="string">&quot;lat&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/screencapture2022-03-11 PM5.13.11.jpg"                                     ><h1 id="处理df3-melt-pivot-split-zip"><a href="#处理df3-melt-pivot-split-zip" class="headerlink" title="处理df3 (melt,pivot,split,zip)"></a>处理df3 (melt,pivot,split,zip)</h1><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/screencapture2022-03-11 AM11.41.10.jpg"                                     ><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据结果的需要重命名</span></span><br><span class="line">df3 = df3.rename(columns=&#123;<span class="string">&quot;Timestamp&quot;</span>:<span class="string">&quot;timestamp&quot;</span>&#125;)</span><br><span class="line"><span class="comment"># 同df1，按30min取均值，填补缺失数据，重设index</span></span><br><span class="line">df3 = df3.resample(<span class="string">&#x27;30min&#x27;</span>, on=<span class="string">&#x27;timestamp&#x27;</span>).mean()</span><br><span class="line">df3 = df3.interpolate(method=<span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">df3 = df3.reset_index()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时每一个timestamp的所有数据都还在一行中，要把它们拆开，扁宽的表变成细长的</span></span><br><span class="line">df3 = df3.melt(id_vars=[<span class="string">&#x27;timestamp&#x27;</span>])</span><br></pre></td></tr></table></figure><p><a class="link"   href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.melt.html#pandas.DataFrame.melt" >pandas.DataFrame.melt<i class="fas fa-external-link-alt"></i></a>后的结果：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/screencapture2022-03-11 PM5.22.12.jpg"                                     ><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此时sensor id和temperature/humidity作为值存在variable中</span></span><br><span class="line"><span class="comment"># 先把字符串拆开，然后分别存到两个新的列中，最后删除旧的variable列</span></span><br><span class="line">df3[<span class="string">&#x27;SensorUnit_ID&#x27;</span>], df3[<span class="string">&#x27;type&#x27;</span>] = <span class="built_in">zip</span>(*df3[<span class="string">&#x27;variable&#x27;</span>].<span class="built_in">str</span>.split(<span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">df3.drop(<span class="string">&#x27;variable&#x27;</span>, inplace=<span class="literal">True</span>, axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 将object类型的id转为int类型，方便后面merge</span></span><br><span class="line">df3[<span class="string">&#x27;SensorUnit_ID&#x27;</span>] = df3[<span class="string">&#x27;SensorUnit_ID&#x27;</span>].astype(<span class="built_in">str</span>).astype(<span class="built_in">int</span>)</span><br></pre></td></tr></table></figure><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/screencapture2022-03-11 PM5.27.35.jpg"                                     ><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此时temperature和humidity作为值存在type中，要分别变成列</span></span><br><span class="line"><span class="comment"># 用pivot函数，先把id和timestamp作为multiindex，type拆开</span></span><br><span class="line"><span class="comment"># Note：只用timestamp无法唯一标识，会报错Index contains duplicate entries, cannot reshape</span></span><br><span class="line">df3 = df3.pivot(index=[<span class="string">&#x27;SensorUnit_ID&#x27;</span>,<span class="string">&#x27;timestamp&#x27;</span>], columns=[<span class="string">&#x27;type&#x27;</span>], values=<span class="string">&#x27;value&#x27;</span>)</span><br></pre></td></tr></table></figure><p><a class="link"   href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.pivot.html" >pandas.DataFrame.pivot<i class="fas fa-external-link-alt"></i></a>后：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/screencapture2022-03-11 PM5.32.23.jpg"                                     ><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重设index，方便后面merge</span></span><br><span class="line">df3 = df3.reset_index()</span><br></pre></td></tr></table></figure><p>最终：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/screencapture2022-03-11 PM5.32.48.jpg"                                     ><h1 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据SensorUnit_ID和timestamp合并df1和df3</span></span><br><span class="line">df_merged = pd.merge(df1, df3, on=[<span class="string">&#x27;SensorUnit_ID&#x27;</span>,<span class="string">&#x27;timestamp&#x27;</span>], how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line"><span class="comment"># 再根据LocationName合并df2</span></span><br><span class="line">df_merged = pd.merge(df_merged, df2, on=[<span class="string">&#x27;LocationName&#x27;</span>], how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据要求将列重新排序</span></span><br><span class="line">df_merged = df_merged[[<span class="string">&#x27;timestamp&#x27;</span>,<span class="string">&#x27;LocationName&#x27;</span>,<span class="string">&#x27;SensorUnit_ID&#x27;</span>,<span class="string">&#x27;CO2&#x27;</span>,<span class="string">&#x27;temperature&#x27;</span>,<span class="string">&#x27;humidity&#x27;</span>,<span class="string">&#x27;zone&#x27;</span>,<span class="string">&#x27;altitude&#x27;</span>,<span class="string">&#x27;lon&#x27;</span>,<span class="string">&#x27;lat&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后排个序</span></span><br><span class="line">df_merged = df_merged.sort_values(by=[<span class="string">&#x27;SensorUnit_ID&#x27;</span>, <span class="string">&#x27;timestamp&#x27;</span>])</span><br><span class="line"><span class="comment"># 根据要求将timestamp设为index</span></span><br><span class="line">df_merged = df_merged.set_index(<span class="string">&#x27;timestamp&#x27;</span>)</span><br></pre></td></tr></table></figure><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/screencapture2022-03-11 PM5.47.00.jpg"                                     ><p>感觉有点奇怪，timestamp作index不也有duplicate吗？但是比较了前后的shape，是一样的。选了几个record也都没问题。🤔</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h1&gt;&lt;p&gt;Merge the &lt;code&gt;CO2_sensor_measurements.csv&lt;/code&gt;, &lt;code&gt;temperature_
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="data_science" scheme="https://coconutnutx.github.io/tags/data-science/"/>
    
  </entry>
  
  <entry>
    <title>Snapshot总结</title>
    <link href="https://coconutnutx.github.io/2022/01/14/snapshot/"/>
    <id>https://coconutnutx.github.io/2022/01/14/snapshot/</id>
    <published>2022-01-14T16:26:21.000Z</published>
    <updated>2022-01-14T16:26:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>重点：关于实现Wait-free Atomic Snapshot时，为什么要判断2次/n次更新</p><p>相关slides: The Power of Registers, Computing with anonymous processes</p><h1 id="实现Snapshot"><a href="#实现Snapshot" class="headerlink" title="实现Snapshot"></a>实现Snapshot</h1><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/screencapture2022-01-14 PM5.34.04.jpg"                                     ><p>当无同步更新时，scan返回的是当前所有寄存器中的值</p><p>当有同步更新时，返回的是last written value或concurrent update value</p><p>类似于regular</p><h1 id="实现Atomic"><a href="#实现Atomic" class="headerlink" title="实现Atomic"></a>实现Atomic</h1><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/screencapture2022-01-14 PM5.32.39.jpg"                                     ><p>思路：通过两个相同的collect，确保这两次操作期间没有更新，从而找到一个linearization point</p><p>注意：“相同的collect”不仅指值相同，还需要timestamp相同，否则反例见<a href="https://coconutnutx.github.io/2022/01/12/snapshot/">Snapshot的timestamp</a></p><h1 id="实现Wait-free"><a href="#实现Wait-free" class="headerlink" title="实现Wait-free"></a>实现Wait-free</h1><p>上面的算法不是wait-free，因为当有多个进程同步调用scan时，可能发生这样的情况：</p><ul><li>p1特别快，不停地更新</li><li>p2很慢，想要scan，但每次由于p1的更新，temp1总不等于temp2，无法返回</li></ul><p>解决思路通常是，让快的进程多做点事。这里如果让p1每次更新时，还要scan，那么p2即使自己无法完成scan，但可以直接抄p1 scan的结果，就有机会返回，从而达到整体的wait-free。具体算法如下：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/screencapture2022-01-14 PM5.43.28.jpg"                                     ><p>这里 if( t3=t2 ) 比较的是自己这次和上次的结果，如果一样，可以返回</p><p>而 if( t3[j,2] ≥ t1[j,2]+2 ) 比较的是其它进程，它这次的结果有没有比第一次新？如果是，则说明这两个时间点之间有过一次完整的scan，可以抄过来直接用</p><h2 id="为什么≥2（一个反例）"><a href="#为什么≥2（一个反例）" class="headerlink" title="为什么≥2（一个反例）"></a>为什么≥2（一个反例）</h2><p>如果将( t3[j,2] ≥ t1[j,2]+2 )变成( t3[j,2] ≥ t1[j,2]+1 )，无法保证一次完整的scan，可能发生这样的情况：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/IMG_FA11786ABCC8-1.jpeg"                                     ><p>即，虽然有一次更新，但这个更新可能开始于很久很久以前。如果是≥2，则可以避免。</p><h1 id="实现Anonymous"><a href="#实现Anonymous" class="headerlink" title="实现Anonymous"></a>实现Anonymous</h1><p>几个不同：</p><ul><li>上面是一个process对应一个Reg（如process1只会更新Reg1）；这里不必一一对应，从而保证anonymous</li><li>上面每个process有自己的local timestamp，每次加1；这里用一个共享的weak counter</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/screencapture2022-01-14 PM6.36.08.jpg"                                     ><p>（这里写的是n+1，后来TA说其实n就够了）</p><h2 id="为什么n（一个反例）"><a href="#为什么n（一个反例）" class="headerlink" title="为什么n（一个反例）"></a>为什么n（一个反例）</h2><p>（from last exercise session）</p><p>如果2个相同的collect就返回，假设：</p><ul><li><p>N个process同时开始，都拿到了相同的timestamp t1</p></li><li><p>process N想要scan</p></li><li><p>process 1 ~ N-1想要update（在write之前，都进行了scan，记为s1。s1=s0）</p></li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/IMG_B1316757EE80-1.jpeg"                                     ><ul><li>PN两次扫描得到了相同的[0,1]，会返回这个值</li><li>但是观察整个过程中X和Y位置的值，从来没有出现过[0,1]。这个scan无法linearize到一个时间点，违背Atomic</li><li>如果等N次相同的更新，可以避免该问题（因为其它N-1个process相同的timestamp已经用完了）</li></ul><h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><p><strong>非Anonymous情况：</strong></p><ol><li><p>process和Reg一一对应</p></li><li><p>非weak counter，每次操作都有唯一的timestamp</p></li><li><p>判断自己的collect是否可以返回 (连续2次collect相同)</p><ul><li><p>连续2次collect，所有值相同，所有timestamp相同</p></li><li><p>即可保证这两次collect之间有一次完整的scan</p></li></ul></li><li><p>判断能否抄别人的scan (某人的ts ≥ 自己开始时的ts+2)</p><ul><li>ts是每个process本地的，至少2才能保证没有“睡了很久刚醒”的情况</li></ul></li></ol><p><strong>Anonymous情况：</strong></p><ol><li><p>process和Reg并非一一对应，一个Reg可能同时被N个process更新</p></li><li><p>weak counter，N个process可能同时获得相同的timestamp</p></li><li><p>判断自己的collect是否可以返回 (连续n次collect相同)</p><ul><li><p>连续n次collect，所有值相同，所有timestamp相同</p></li><li><p>为什么是n？极限情况：</p><ul><li>所有N个process拿到了相同的timestamp，写相同值，写到同一个Reg中</li><li>除自己以外，最多可能有N-1个一模一样的更新</li><li>但如果读到了N个相同的结果，说明剩余N-1个process中，至少有一个更新了两次。这两次之间是一个完整的scan</li></ul></li><li><p>What If…?</p><ul><li>把Weak counter改成Strong counter，不会拿到相同的timestamp -&gt; 2次连续collect相同即可</li><li>仍是Weak counter，但最多10个process拿到相同的timestamp -&gt; 10次连续collect相同即可</li></ul></li></ul></li><li><p>判断能否抄别人的scan ( 某处的ts ≥ 自己开始时的ts+1 )</p><ol><li>细节：这里开始时的ts也是从Weak counter获得的，而不是collect()得到的（即，不是update()写入的）</li><li>Weak counter的性质保证，如果ts更大，该操作一定更晚发生，不会有“睡了很久刚醒”的情况<ul><li>甚至可以是 ( 某处的ts ≥ 自己开始时的ts )，只要不小于即可，Weak counter的性质可保证完整的scan（Exercise 8 Problem 2）</li></ul></li></ol></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>判断能否用自己collect的结果，需要比较两个collect是否相同（包括值和timestamp），当timestamp可能重复时，还需要排除重复情况。</p><p>判断能否抄别人的结果，需要确保产生这个结果的scan发生在自己开始之后，根据timestamp获取方式的不同（local和shared weak counter），比较时大多少也有所区别。</p><h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><p>TA的解释</p><p>关于Atomic，和实现linearizable的思路</p><blockquote><p>Weak counter facts (perspective of an individual process):</p><p>- After I get a value (return) from the weak counter by calling wInc(), at most N-1 other processes can <em>still</em> obtain a value less or equal to that.</p><p>This is true because at most N-1 other processes can be concurrently executing with me (there are at most N processes after all, me being one of them), and <em>specifically</em>, executing wInc() on that same counter (e.g. they could have been about to return from wInc()). A weak counter guarantees that if some process calls wInc after I return from wInc (Correctness) that process <em>will</em> get a higher timestamp so adding to the previous fact, at most N-1 processes might still get a lower or equal value to the one I have just obtained.</p><p>Now, the goal of the atomic snapshot (anonymous or not) is to return a read of the entire array that is linearizable. We break correctness if we somehow return an array that is <em>not</em> linearizable. For example, take the following history (sequence of states) for an array of size 2:</p><p>S1: [0, 0] -&gt; S2: [1, 0] -&gt; S3: [1, 1] -&gt; S4: [1, 0] -&gt; S5: [0, 0]</p><p>At no point in time did the array ever have the state [0, 1]. If we ever were to return that state in the scan() operation, it would break correctness. However, this could happen if we were doing a naive approach where we simply collected once (read e.g. left to right): We read the first register at S1, sleep during S2, read the second register at S3, and finally return [0, 1].</p><p>The key point is that this problem arises only if some other process writes while we are reading: if we could guarantee that, when we collect, no process wrote on any register of the array, we would be free to return the result of that collect.</p><p>The <strong>non-anonymous</strong> snapshot solves this problem in two manners:</p><p>- We add timestamps to each register</p><p>- We collect twice and only return the result if and only if the timestamps of all registers have not changed.</p><p>This implies that no register wrote on the array between the first and second collect (and that is the scan’s linearization point). Why? Because each process has its own register, therefore each register’s timestamp is <em>monotonically</em> increasing. If there is a write to the register, the timestamp necessarily increases (by one). By negation, if the timestamp did not increase, there was no write.</p><p>Can we make the same argument for the anonymous snapshot’s algorithm? The answer is no. The difficulty comes because the model is different: the anonymous snapshot allows any process to update any register. If we constrained or assigned processes to a few or their own register, we would break anonymity. The consequence is that, for each register, its timestamp is no longer monotonically increasing (because of counter is weak), so even if two reads return the same value for that register there might have been a write in between.</p><p>However, even if it is not <em>monotonically</em> increasing, it <strong>necessarily</strong> <strong>increases</strong> after every N writes (see Weak Counter facts at the beginning of this explanation). So by collecting N+1 times and getting the same timestamps on all registers, there must necessarily be a point between two of the N+1 collects in which no write to any register could have happened, and we can linearize our scan then.</p></blockquote><p>反例2</p><blockquote><p>Consider an anonymous snapshot object with M = 2, i.e. only 2 slots. Suppose process p is performing a scan operation. Suppose also that the scan operation consists of <strong>only</strong> 2 collects, as you mention, and not N as the original algorithm implies, and that process p obtains timestamp <strong>t</strong>. Suppose all other N-1 processes are performing update operations, have all obtained the same timestamp <strong>t’</strong> &lt; <strong>t</strong> and scan <strong>S</strong>, and are about to write to their corresponding register (paused just before writing).</p><p>Since N can be made arbitrarily large (and thus so can N-1), I can use any constant number of processes from this group in my counter example. More specifically, in these conditions I can choose to apply any number of writes of any value to any position of the snapshot at any point during process p’s scan, with the restriction that the timestamp value written is <strong>t’</strong> and the scan is <strong>S</strong>. Taking this into account, consider the following sequence of operations and state of the snapshot:</p><p>[empty, empty]     - initial value</p><p>[(0, t’, S), empty]   - process q1 writes (v = 0, i = 0)</p><p>[(0, t’, S), (0, t’, S)]  - process q2 writes (v = 0, i = 1)</p><p>[(0, t’, S), (0, t’, S)]  - process p reads the first register. first collect -&gt; (0, t’, S)</p><p>[(1, t’, S), (0, t’, S)]  - process q3 writes (v = 1, i = 0)</p><p>[(1, t’, S), (1, t’, S)]  - process q4 writes (v = 1, i = 1)</p><p>[(1, t’, S), (1, t’, S)]  - process p reads the second register. first collect -&gt; (1, t’, S)</p><p>[(1, t’, S), (0, t’, S)]  - process q5 writes (v = 0, i = 1)</p><p>[(0, t’, S), (0, t’, S)]  - process q6 writes (v = 0, i = 0)</p><p>[(0, t’, S), (0, t’, S)]  - process p reads the first register. second collect -&gt; (0, t’, S)</p><p>[(1, t’, S), (0, t’, S)]  - process q7 writes (v = 1, i = 0)</p><p>[(1, t’, S), (1, t’, S)]  - process q8 writes (v = 1, i = 1)</p><p>[(1, t’, S), (1, t’, S)]  - process p reads the second register. second collect -&gt; (1, t’, S)</p><p>In the previous execution, process p returns [0, 1] as the result of the scan operation (2 identical collects). However, at no point in time was the state of the snapshot ever [0, 1] indicating that the read of the snapshot is not linearizable.</p><p>Finally, note that the authors of the paper are not claiming a lower bound on the number of reads that have to be realized to have an atomic snapshot. They are claiming an upper bound (N collects -&gt; N x M reads). Maybe with some other algorithm, a strong counter or the like, you would be able to do it with less reads, but the present algorithm fails for just 2 collects as I’ve show above.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;重点：关于实现Wait-free Atomic Snapshot时，为什么要判断2次/n次更新&lt;/p&gt;
&lt;p&gt;相关slides: The Power of Registers, Computing with anonymous processes&lt;/p&gt;
&lt;h1 id=&quot;实
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="concurrent_algorithm" scheme="https://coconutnutx.github.io/tags/concurrent-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Snapshot的timestamp</title>
    <link href="https://coconutnutx.github.io/2022/01/12/snapshot/"/>
    <id>https://coconutnutx.github.io/2022/01/12/snapshot/</id>
    <published>2022-01-12T10:44:01.000Z</published>
    <updated>2022-01-12T10:44:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>CS-453 Concurrent algorithms，slide: The Power of Registers</p><p>Atomic Snapshot实现的基本思路：</p><ul><li>两次扫描，得到相同的结果</li><li>加timestamp避免ABA情况</li></ul><p>不加timestamp的反例（p19）</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/screencapture2022-01-12 PM12.20.20.jpg"                                     ><p>写了一下具体步骤：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/IMG_A6C8CC987C90-1.jpeg"                                     ><p>可以发现，两次collect得到的都是[0,0,2]，最后返回[0,0,2]<br>但是实际上，并没有一个时间点，寄存器中实际的值是[0,0,2]<br>也就是说，虽然collect了同样的值，但这个值从未存在过</p><p>所以不仅值要相同，还需要timestamp来保证没有发生过更新</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CS-453 Concurrent algorithms，slide: The Power of Registers&lt;/p&gt;
&lt;p&gt;Atomic Snapshot实现的基本思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两次扫描，得到相同的结果&lt;/li&gt;
&lt;li&gt;加timestamp避免
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="concurrent_algorithm" scheme="https://coconutnutx.github.io/tags/concurrent-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Obsidian使用感受</title>
    <link href="https://coconutnutx.github.io/2022/01/12/note/"/>
    <id>https://coconutnutx.github.io/2022/01/12/note/</id>
    <published>2022-01-12T08:56:00.000Z</published>
    <updated>2022-01-12T08:56:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>想要试试带关系图的双链笔记，10月开始尝试Obsidian，到现在差不多三个月，没想到已经这么多了。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/Obsedian2021.jpg"                                     ><p>一开始只是记了些课程笔记，蓝色是Machine Learning，粉色是Sublinear Algorithms，紫色和黄色是Distributed和Concurrent Algorithms。后来又把一些其它的、包括读书笔记都加了进来。看着整个图一点点长大、不同的部分开始有了联系，有种集卡游戏的满足感。</p><p>Obsidian+Github真是太棒了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想要试试带关系图的双链笔记，10月开始尝试Obsidian，到现在差不多三个月，没想到已经这么多了。&lt;/p&gt;
&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg
      
    
    </summary>
    
    
      <category term="Memo" scheme="https://coconutnutx.github.io/categories/Memo/"/>
    
    
      <category term="tool" scheme="https://coconutnutx.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>CA project 状态分析&amp;debug</title>
    <link href="https://coconutnutx.github.io/2021/12/16/ca-condition/"/>
    <id>https://coconutnutx.github.io/2021/12/16/ca-condition/</id>
    <published>2021-12-16T19:49:38.000Z</published>
    <updated>2021-12-16T19:49:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>上次<a href="https://coconutnutx.github.io/2021/11/28/ca-project/">CA project 思路笔记</a>分析一个位置是否可以读写的状态：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-16 PM8.49.01.jpg"                                     ><p>但是在project测试过程中发现有问题。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>按照<a class="link"   href="http://localhost:4000/2021/12/15/ca-control/" >Atomic control<i class="fas fa-external-link-alt"></i></a>的逻辑写了read_align()和write_align()。</p><p>read_align中判断Written==0时，如果没有owner、或者owner是自己，可以写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(owner==<span class="number">0</span> || owner==tr-&gt;id)&#123;</span><br><span class="line">  <span class="keyword">uint_least64_t</span> not_written = owner &lt;&lt; <span class="number">32</span> | epoch | valid;</span><br><span class="line">  <span class="keyword">if</span>(atomic_compare_exchange_strong(cur_control, &amp;not_written, written_and_is_owner))&#123;</span><br><span class="line">    <span class="comment">// write the content at source into the writable copy;</span></span><br><span class="line">    write_writable_copy(source, segment, index);</span><br><span class="line">    <span class="comment">// return the transaction can continue;</span></span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是测试时，transaction量一两千还能过，10000就过不了了。</p><p>反而↓这样可以过：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(atomic_compare_exchange_strong(cur_control, &amp;load_control, written_and_is_owner))&#123;</span><br><span class="line">  <span class="comment">// write the content at source into the writable copy;</span></span><br><span class="line">  write_writable_copy(source, segment, index);</span><br><span class="line">  <span class="comment">// return the transaction can continue;</span></span><br><span class="line">  flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是它并不符合原本的思路，因为可能会将第一个读成功的owner覆盖。就很奇怪。</p><h1 id="重读"><a href="#重读" class="headerlink" title="重读"></a>重读</h1><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-16 PM8.58.31.jpg"                      width=600                ><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-16 PM8.59.01.jpg"                      width=600                ><p>感觉会有问题的很可能是access set，上次分析只用记录第一个读或写成功的id，但是为什么实际中即使写覆盖了读也可以成功呢？</p><p>假设在某一个align，tr1、tr2读了旧值，此时如果tr3写了新值，tr1、tr2以及任何除tr3以外的transaction都不能再读。也就是说，写过的位置，只有写者可读。这其实是符合read_word()伪代码的。并且，如果tr1、tr2后面不再读这个值，可以提交并linearize到tr3开始之前；反之，如果它们后面还要读这个值，就会读失败，进而被abort。所以也是符合linearizable的。</p><p>难道access set只用记录第一个写成功的？上次跟TA确认了一下，access set只用记一个id，似乎确实没仔细问是第一个读成功、还是写成功。</p><p>那么按照新的逻辑分析，第一个读或写成功，还是都记入owner，只不过读成功的owner可以被覆盖。</p><p>可如果能够覆盖，read owner和other还有什么用呢？（其实现在这版代码里面也压根没用到other）如果直接把read_align中设置owner和other的代码注释掉，还能跑吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">⎪ #worker threads:     4</span><br><span class="line">⎪ #TX per worker:      10000</span><br><span class="line">⎪ #repetitions:        7</span><br><span class="line">⎪ Initial #accounts:   128</span><br><span class="line">⎪ Expected #accounts:  1024</span><br></pre></td></tr></table></figure><p>…用↑参数测了几次，多数能过，少数Violated isolation or atomicity。也就是说other还是有用的。</p><p>再看下project description中对access set的描述：</p><blockquote><p>The “access set” of read-write transaction(s) which have accessed the word in the current epoch. Do not implement an actual set in any (optimized) implementation: this set will only be used to tell whether a transaction can write to the word. Namely, if at least one other transaction has accessed (i.e. read or written) this word in the same epoch, the write cannot happen. Said differently, if two transactions are in the access set, it doesn’t matter which one they are.</p></blockquote><p>现在迷惑的点就是：</p><ol><li>如果有另一个transaction也访问过，还能不能写？</li><li>现在的代码里到底判断了other没？</li></ol><p>2应该是没有的，加个输出可以发现，即使有other还是有时写成功了。那为什么可以过呢？难道是意外？多测几次还真偶尔有Violated isolation or atomicity！</p><p>好吧，虽然project又变成了未完成状态，但至少没有逻辑错的代码能跑对、逻辑(以为)对的代码跑不通的尴尬情况了。</p><p>那么接下来的问题就是，为什么逻辑(以为)对的代码跑不通？更准确的是，为什么在transaction量较大时跑不通？</p><h1 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h1><h2 id="CAS-fail-when-equal"><a href="#CAS-fail-when-equal" class="headerlink" title="CAS fail when equal"></a>CAS fail when equal</h2><p>打印了一些tm_begin和tm_end的信息，发现当transaction进行了很多、id很大之后，只有tm_begin没有tm_end了，也就是说后面的都没有commit。并且都是一些read/write transaction，它们的write都没有成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[304850 write align] seg_id=8 index=1 flag=0</span><br><span class="line">[304851 tm_begin] is_ro=0</span><br><span class="line">[304821 write align] seg_id=8 index=1 flag=0</span><br><span class="line">[304852 tm_begin] is_ro=0</span><br><span class="line">[304833 write align] seg_id=8 index=1 flag=0</span><br><span class="line">[304853 tm_begin] is_ro=0</span><br><span class="line">[304836 write align] seg_id=8 index=1 flag=0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>发现有一个CAS中，明明expected值和control中的值是一样的，但是没有换成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atomic_compare_exchange_strong(cur_control, &amp;not_written, written_and_is_owner)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">not_written=5e0cb00000005 load_control=5e0cb00000005 cur_control=5e0cb00000005 equal=1</span><br></pre></td></tr></table></figure><p>这可就太离谱了！</p><blockquote><p><a class="link"   href="https://stackoverflow.com/questions/35534305/compare-exchange-strong-failing-despite-data-matching-expected-value" >compare_exchange_strong failing despite data matching expected value<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://stackoverflow.com/questions/66566810/why-does-compare-exchange-strong-fail-with-stdatomicdouble-stdatomicfloa" >Why does compare_exchange_strong fail with std::atomic, std::atomic in C++?<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>可能是由padding导致的。这就很尴尬了。</p><h3 id="尝试1"><a href="#尝试1" class="headerlink" title="尝试1"></a>尝试1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint_least64_t not_written = owner &lt;&lt; 32 | valid;</span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint_least64_t not_written = load_control &amp; 0xFFFFFFFFFFFFFFF9;</span><br></pre></td></tr></table></figure><p>不行</p><h3 id="尝试2"><a href="#尝试2" class="headerlink" title="尝试2"></a>尝试2</h3><p>这是真的很离谱啊！打印出来的判断就是相等啊！这换不了能怎么办啊？？？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;DEBUG4 not_written=%lx load_control=%lx cur_control=%lx equal=%d test=%d\n&quot;</span>, not_written, load_control, load, not_written==load, atomic_load(cur_control)==not_written);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DEBUG4 not_written=3e1a300000005 load_control=3e1a300000005 cur_control=3e1a300000005 equal=1 test=1</span><br><span class="line">[254371 write align] seg_id=8 index=1 flag=0 cond=4</span><br><span class="line">[254373 tm_begin] is_ro=0</span><br><span class="line">DEBUG4 not_written=3e1a400000005 load_control=3e1a400000005 cur_control=3e1a400000005 equal=1 test=1</span><br><span class="line">[254372 write align] seg_id=8 index=1 flag=0 cond=4</span><br><span class="line">[254374 tm_begin] is_ro=0</span><br><span class="line">DEBUG4 not_written=3e1a500000005 load_control=3e1a500000005 cur_control=3e1a500000005 equal=1 test=1</span><br></pre></td></tr></table></figure><p>难道是uint_least64_t的问题？它和memcpy的比较方法不一样？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_t a = (size_t)not_written;</span><br></pre></td></tr></table></figure><p>强制转成size_t然后比就好了？？？那之前担心位数不对，还特地搞个uint_least64_t，简直是离了个大谱。</p><h2 id="too-long"><a href="#too-long" class="headerlink" title="too long"></a>too long</h2><p>改好上面这个离谱的bug之后，当transaction太多还是会跑不完。打印输出看还是write_align不成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[370371 tm_begin] is_ro=0</span><br><span class="line">[370371 write align] seg_id=8 index=1 flag=0 cond=4 lc=5a6c300000005, cc=5a6c300000005</span><br><span class="line">[370372 tm_begin] is_ro=0</span><br><span class="line">[370372 write align] seg_id=8 index=1 flag=0 cond=4 lc=5a6c400000005, cc=5a6c400000005</span><br><span class="line">[370373 tm_begin] is_ro=0</span><br><span class="line">[370373 write align] seg_id=8 index=1 flag=0 cond=4 lc=5a6c500000005, cc=5a6c500000005</span><br><span class="line">[370374 tm_begin] is_ro=0</span><br><span class="line">[370374 write align] seg_id=8 index=1 flag=0 cond=4 lc=5a6c600000005, cc=5a6c600000005</span><br><span class="line">[370375 tm_begin] is_ro=0</span><br><span class="line">[370375 write align] seg_id=8 index=1 flag=0 cond=4 lc=5a6c700000005, cc=5a6c700000005</span><br></pre></td></tr></table></figure><p>全部都是有other read冲突</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[215647 read align] seg_id=7 index=0 lc=0 cc=34a5f00000000</span><br><span class="line">[215647 read align] seg_id=7 index=1 lc=1 cc=34a5f00000001</span><br><span class="line">[215647 read align] seg_id=8 index=0 lc=0 cc=34a5f00000000</span><br><span class="line">[215647 read align] seg_id=8 index=1 lc=1 cc=34a5f00000001</span><br><span class="line">[215647 read align] seg_id=9 index=0 lc=1 cc=34a5f00000001</span><br><span class="line">[215647 read align] seg_id=9 index=1 lc=0 cc=34a5f00000000</span><br><span class="line">[215647 read align] seg_id=9 index=2 lc=0 cc=34a5f00000000</span><br><span class="line">[215647 read align] seg_id=9 index=3 lc=1 cc=34a5f00000001</span><br><span class="line">[215647 read align] seg_id=8 index=1 lc=34a5f00000001 cc=34a5f00000005</span><br></pre></td></tr></table></figure><p>发现一个逻辑错误，owner是自己时仍设了other。</p><p>这下算是修了一个逻辑上的大bug，再上服务器测测。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-16 PM10.51.17.jpg"                      width=600                ><p>成功！虽然没有变快，但至少逻辑上合理了，不像之前那么虚了。</p><hr><p>所以之前那么大一个bug是怎么过的测试啊就离谱，今天真是满头问号。而且之前逻辑都没对就写优化，那可不是写了个寂寞。幸亏优化的思路现在是很清晰了，毕竟revert、重写都搞了好几遍了。虽然不知道这些优化到底能不能正向优化，但还是想试试，就是很好奇，而且毕竟都花了这么多时间了。</p><p>顺便把<a href="https://coconutnutx.github.io/2021/12/15/ca-control/">Atomic control</a>更新一下。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>reference的逻辑还是很正确的</li><li>bug确实是自己写的bug</li><li>除了c的atomic_compare_exchange_strong，值较大时，期望值和实际值一样但换不成功，是真的离谱</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上次&lt;a href=&quot;https://coconutnutx.github.io/2021/11/28/ca-project/&quot;&gt;CA project 思路笔记&lt;/a&gt;分析一个位置是否可以读写的状态：&lt;/p&gt;
&lt;img  
                     lazy
      
    
    </summary>
    
    
      <category term="Debug" scheme="https://coconutnutx.github.io/categories/Debug/"/>
    
    
      <category term="concurrent_algorithm" scheme="https://coconutnutx.github.io/tags/concurrent-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>CA project Atomic control</title>
    <link href="https://coconutnutx.github.io/2021/12/15/ca-control/"/>
    <id>https://coconutnutx.github.io/2021/12/15/ca-control/</id>
    <published>2021-12-15T16:37:29.000Z</published>
    <updated>2021-12-15T16:37:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>Project中为了标识transactional memory中每一个align的状态，需要一个control structure，这里用了一个64bit的atomic interger来存这些信息。</p><p>通过一次CAS完成对状态的判断和修改，避免加锁。</p><h1 id="Control设计"><a href="#Control设计" class="headerlink" title="Control设计"></a>Control设计</h1><table><thead><tr><th>占用bit</th><th>32</th><th>20</th><th>9</th><th>1</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>名称</td><td>Owner</td><td>Epoch</td><td>留空</td><td>Other</td><td>Written</td><td>Valid</td></tr><tr><td>描述</td><td>本轮第一个read或write成功的transaction的id</td><td>当前轮数</td><td></td><td>是否有其它transaction访问</td><td>是否被写</td><td>A或B哪个有效</td></tr></tbody></table><h1 id="Control-masks"><a href="#Control-masks" class="headerlink" title="Control masks"></a>Control masks</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> VALID_MASK = <span class="number">0x1</span>;         <span class="comment">// 0: A is valid    1: B is valid</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> WRITE_MASK = <span class="number">0x1</span> &lt;&lt; <span class="number">1</span>;    <span class="comment">// 0: not written   1: written</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> OTHER_MASK = <span class="number">0x1</span> &lt;&lt; <span class="number">2</span>;    <span class="comment">// 0: no other read 1: has other read</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> EPOCH_MASK = <span class="number">0xFFFFF000</span>;</span><br></pre></td></tr></table></figure><h1 id="Control-macros"><a href="#Control-macros" class="headerlink" title="Control macros"></a>Control macros</h1><p>有时需要直接读atomic interger。其他时候，先读一次，然后直接对读到的值进行操作，可以减少atomic_load()次数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_FLAG_SIGN(control, flag) ((atomic_load(control) &amp; flag) != 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_FLAG_SIGN_LOADED(load_control, flag) ((load_control &amp; flag) != 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_FLAG_LOADED(load_control, flag) (load_control &amp; flag)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_EPOCH_LOADED(load_control) (load_control &amp; EPOCH_FLAG)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_OWNER(control) ((atomic_load(control)) &gt;&gt; 32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_OWNER_LOADED(load_control) (load_control &gt;&gt; 32)</span></span><br></pre></td></tr></table></figure><h1 id="read-align逻辑"><a href="#read-align逻辑" class="headerlink" title="read_align逻辑"></a>read_align逻辑</h1><ol><li><p>If 已经被写过，只有owner可以读（且Other应该为空，因为Other和Written不肯能同时为1）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expected: Owner==id; Epoch==epoch; Other==0; Written==1; Valid==valid</span><br></pre></td></tr></table></figure></li><li><p>If 没有被写过</p><ol><li><p>If owner==0，尝试抢占（可能会出现竞争而失败）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expected: Owner==0;  Epoch==epoch; Other==0; Written==0; Valid==valid</span><br><span class="line">Desired:  Owner==id; Epoch==epoch; Other==0; Written==0; Valid==valid</span><br></pre></td></tr></table></figure></li><li><p>Else if owner==自己，直接读（owner不会被修改，也只有自己可能写）</p></li><li><p>Else if owner==别人</p><ol><li><p>If 尝试设Other</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expected: Owner==owner; Epoch==epoch; Other==0; Written==0; Valid==valid</span><br><span class="line">Desired:  Owner==owner; Epoch==epoch; Other==1; Written==0; Valid==valid</span><br></pre></td></tr></table></figure></li><li><p>Else if 读到已经被设了Other</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expected: Owner==owner; Epoch==epoch; Other==1; Written==0; Valid==valid</span><br></pre></td></tr></table></figure><p>如果读到Other为1，owner也不能再写这个align了，所以可以放心读。</p></li></ol></li></ol></li></ol><h1 id="write-align逻辑"><a href="#write-align逻辑" class="headerlink" title="write_align逻辑"></a>write_align逻辑</h1><ol><li><p>If 已经被写过，只有owner可以写，且不能有other</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expected: Owner==id; Epoch==epoch; Other==0; Written==1; Valid==valid</span><br></pre></td></tr></table></figure></li><li><p>If 没有被写过</p><ol><li><p>已经是owner可以写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expected: Owner==id; Epoch==epoch; Other==0; Written==0; Valid==valid</span><br><span class="line">Desired:  Owner==id; Epoch==epoch; Other==0; Written==1; Valid==valid</span><br></pre></td></tr></table></figure></li><li><p>抢到owner可以写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expected: Owner==0;  Epoch==epoch; Other==0; Written==0; Valid==valid</span><br><span class="line">Desired:  Owner==id; Epoch==epoch; Other==0; Written==1; Valid==valid</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>Note：如果写成功了，本轮中control的值将不会再发生改变</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Project中为了标识transactional memory中每一个align的状态，需要一个control structure，这里用了一个64bit的atomic interger来存这些信息。&lt;/p&gt;
&lt;p&gt;通过一次CAS完成对状态的判断和修改，避免加锁。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="concurrent_algorithm" scheme="https://coconutnutx.github.io/tags/concurrent-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>CA project 常用操作</title>
    <link href="https://coconutnutx.github.io/2021/12/12/ca-project/"/>
    <id>https://coconutnutx.github.io/2021/12/12/ca-project/</id>
    <published>2021-12-12T22:42:37.000Z</published>
    <updated>2021-12-12T22:42:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>很久没用C了，还有一些同步相关的操作，记录一下。</p><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>分配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">region</span>* <span class="title">region</span> =</span> (struct region*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct region));</span><br><span class="line"><span class="keyword">if</span> (unlikely(!region)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分配（且内存按align排列）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (posix_memalign(&amp;(region-&gt;start), align, size) != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">free</span>(region);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填零</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(region-&gt;start, <span class="number">0</span>, size);</span><br></pre></td></tr></table></figure><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>填值&amp;取值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define index</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> align;</span><br><span class="line">    <span class="keyword">uint8_t</span>* index;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// init index</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;cnt; i++)&#123;</span><br><span class="line">  <span class="keyword">size_t</span>* p = (<span class="keyword">size_t</span>*)(segment-&gt;index + i*align);</span><br><span class="line">  *p = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get index</span></span><br><span class="line"><span class="keyword">size_t</span> index = *(<span class="keyword">size_t</span>*)(address)</span><br></pre></td></tr></table></figure><p>🌰</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find segment and index</span></span><br><span class="line"><span class="keyword">size_t</span> index = *(<span class="keyword">size_t</span>*)(address);</span><br><span class="line"><span class="keyword">size_t</span> offset = index * region-&gt;align + <span class="keyword">sizeof</span>(struct segment);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment</span>* <span class="title">segment</span> =</span> (struct segment*)((<span class="keyword">uint8_t</span>*)address - offset);</span><br></pre></td></tr></table></figure><p>指针的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>** p_addr;</span><br><span class="line">    <span class="keyword">size_t</span>* p_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set</span></span><br><span class="line">*(s-&gt;p_addr + index) = address;    <span class="comment">// void* address</span></span><br><span class="line">*(s-&gt;p_num + index) = size;        <span class="comment">// size_t size</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get</span></span><br><span class="line"><span class="keyword">void</span>* addr = *(p_addr + i);</span><br><span class="line"><span class="keyword">size_t</span> size = *(p_num + i);</span><br></pre></td></tr></table></figure><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>设置mask</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> MASK = <span class="number">0x0001</span> &lt;&lt; <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>获取mask下的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_FLAG(control, mask) ((atomic_load(control) &amp; mask) != 0)</span></span><br></pre></td></tr></table></figure><p>设置高位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control |= id &lt;&lt; <span class="number">32</span>;</span><br></pre></td></tr></table></figure><p>获取高位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint_least64_t</span> id = control &gt;&gt; <span class="number">32</span>;</span><br></pre></td></tr></table></figure><h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h1><h2 id="锁和条件变量"><a href="#锁和条件变量" class="headerlink" title="锁和条件变量"></a>锁和条件变量</h2><blockquote><p>reference “lock.h” “lock.c”</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lock_init</span><span class="params">(struct <span class="keyword">lock_t</span>* lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pthread_mutex_init(&amp;(lock-&gt;mutex), <span class="literal">NULL</span>) == <span class="number">0</span></span><br><span class="line">        &amp;&amp; pthread_cond_init(&amp;(lock-&gt;cv), <span class="literal">NULL</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_cleanup</span><span class="params">(struct <span class="keyword">lock_t</span>* lock)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_destroy(&amp;(lock-&gt;mutex));</span><br><span class="line">    pthread_cond_destroy(&amp;(lock-&gt;cv));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lock_acquire</span><span class="params">(struct <span class="keyword">lock_t</span>* lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pthread_mutex_lock(&amp;(lock-&gt;mutex)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_release</span><span class="params">(struct <span class="keyword">lock_t</span>* lock)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_unlock(&amp;(lock-&gt;mutex));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_wait</span><span class="params">(struct <span class="keyword">lock_t</span>* lock)</span> </span>&#123;</span><br><span class="line">    pthread_cond_wait(&amp;(lock-&gt;cv), &amp;(lock-&gt;mutex));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_wake_up</span><span class="params">(struct <span class="keyword">lock_t</span>* lock)</span> </span>&#123;</span><br><span class="line">    pthread_cond_broadcast(&amp;(lock-&gt;cv));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h2><p><a class="link"   href="https://en.cppreference.com/w/c/atomic/atomic_load" >atomic_load<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://en.cppreference.com/w/cpp/atomic/atomic_store" >atomic_store<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://en.cppreference.com/w/c/atomic/atomic_fetch_add" >atomic_fetch_add<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://en.cppreference.com/w/c/atomic/atomic_compare_exchange" >atomic_compare_exchange<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很久没用C了，还有一些同步相关的操作，记录一下。&lt;/p&gt;
&lt;h1 id=&quot;内存&quot;&gt;&lt;a href=&quot;#内存&quot; class=&quot;headerlink&quot; title=&quot;内存&quot;&gt;&lt;/a&gt;内存&lt;/h1&gt;&lt;p&gt;分配&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;ta
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="concurrent_algorithm" scheme="https://coconutnutx.github.io/tags/concurrent-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>关于Localized Causal Broadcast</title>
    <link href="https://coconutnutx.github.io/2021/12/09/lcb/"/>
    <id>https://coconutnutx.github.io/2021/12/09/lcb/</id>
    <published>2021-12-09T12:33:01.000Z</published>
    <updated>2021-12-09T12:33:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>DA project submission #2 要求实现Localized Causal Broadcast，具体的定义在project repo的README中</p><blockquote><ul><li>You must implement this on top of uniform reliable broadcast (URB).</li><li>The <code>CONFIG</code> command-line argument for this algorithm consists of a file that contains an integer <code>m</code> in its first line. <code>m</code> defines how many messages each process should broadcast.</li><li>For a system of <code>n</code> processes, there are <code>n</code> more lines in the <code>CONFIG</code> file. Each line <code>i</code> corresponds to process <code>i</code>, and such a line indicates the identities of other processes which can affect process <code>i</code>. See the example below.<ul><li>The FIFO property still needs to be maintained by localized causal broadcast. That is, messages broadcast by the same process must not be delivered in a different order then they were broadcast.</li><li>The output format for localized causal broadcast remains the same as before.<br>Example of <code>CONFIG</code> file for a system of <code>5</code> processes, where each one broadcasts <code>m</code> messages:</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m</span><br><span class="line">1 4 5</span><br><span class="line">2 1</span><br><span class="line">3 1 2</span><br><span class="line">4</span><br><span class="line">5 3 4</span><br></pre></td></tr></table></figure><p><em>Note</em>: Lines should end in <code>\n</code>, and numbers are separated by white-space characters.</p><p>In this example we specify that process <code>1</code> is affected by messages broadcast by processes <code>4</code> and <code>5</code>. Similarly, we specify that process <code>2</code> is only affected by process <code>1</code>. Process <code>4</code> is not affected by any other processes. Process <code>5</code> is affected by processes <code>3</code> and <code>4</code>.</p><p>We say that a process <code>x</code> is affected by a process <code>z</code> if all the messages which process <code>z</code> broadcasts and which process <code>x</code> delivers become dependencies for all future messages broadcast by process <code>x</code>. We call these dependencies <em>localized</em>. If a process is not affected by any other process, messages it broadcasts only depend on its previously broadcast messages (due to the FIFO property).</p><p><em>Note</em>:  In the default causal broadcast (this algorithm will be discussed in one of the lectures) each process affects <code>all</code> processes. In this algorithm we can selectively define which process affects some other process.</p></blockquote><h1 id="关于dependency"><a href="#关于dependency" class="headerlink" title="关于dependency"></a>关于dependency</h1><p>process is affected by other processes，但消息的dependency是对每一条消息而言的。</p><p>（当用书上的vector clock方法实现时）也就是说，每一条LCB层消息在broadcast的时间点，需要拿到这个时间点、当前进程的vector clock，作为自己的dependency clock。可以作为消息内容传给其它process。</p><p>其它process收到消息，判断能否deliver，即判断自己的vector clock是否大于消息的dependency clock。</p><h1 id="关于FIFO"><a href="#关于FIFO" class="headerlink" title="关于FIFO"></a>关于FIFO</h1><p>根据sequence number可以保证FIFO。</p><p>基于vector clock也可以保证FIFO。</p><p>对于其它进程，都是在deliver消息时，增加该进程对应的vector clock值。</p><p>对于当前进程，可以做一些调整，在broadcast消息时就修改对应的vector clock值。</p><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># in process 1</span><br><span class="line">b 1 [0 . .]</span><br><span class="line">b 2 [1 . .]</span><br></pre></td></tr></table></figure><p>那么其它进程收到2时，必须先deliver 1。</p><p>可以保证当前进程广播的每一条消息，都有不同的vector clock（即使当前进程没有affected by任何进程），从而保证FIFO。</p><p>这样在deliver的时候，可以统一处理vector clock，而不用管sequence number。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;DA project submission #2 要求实现Localized Causal Broadcast，具体的定义在project repo的README中&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;You must implement this on t
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="distributed_algorithm" scheme="https://coconutnutx.github.io/tags/distributed-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>CA project debug记录</title>
    <link href="https://coconutnutx.github.io/2021/12/06/ca-debug/"/>
    <id>https://coconutnutx.github.io/2021/12/06/ca-debug/</id>
    <published>2021-12-06T10:09:23.000Z</published>
    <updated>2021-12-06T10:09:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="惨痛经验"><a href="#惨痛经验" class="headerlink" title="惨痛经验"></a>惨痛经验</h1><h2 id="Start-easy"><a href="#Start-easy" class="headerlink" title="Start easy"></a>Start easy</h2><p>第一步，加锁，把Transactional Memory的功能写对。</p><ul><li>测试报错Transactional library takes too long to process the transactions，是功能就不对，和线程数量、transaction数量、print没什么关系。</li><li>要把这个报错的阈值调大，修改grading里的slow_factor即可。刚开始可以直接改到1024。</li></ul><p>先不要写什么优化，把基础功能写对，否则debug直接de到吐血</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><ol><li>read_word()和write_write()虽然是照着project desciption写，但还是很容易出错，要很很很小心！</li><li>free的时机需要注意，有时候free后再读并不是一眼就能看出来，bug藏得比较隐蔽。</li></ol><h2 id="Debug-Segmentation-fault"><a href="#Debug-Segmentation-fault" class="headerlink" title="Debug Segmentation fault"></a>Debug Segmentation fault</h2><p>Segmentation fault常用debug操作：core dump（虚拟机环境不同，流程可能不一样，这里用了和DA project一样的ubuntu，最大的坑是找不到core）</p><ol><li><p>设置</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited</span><br><span class="line">ulimit -a</span><br></pre></td></tr></table></figure></li><li><p>run</p></li><li><p>找到core文件</p><blockquote><p><a class="link"   href="https://askubuntu.com/questions/966407/where-do-i-find-the-core-dump-in-ubuntu-16-04lts" >Where do I find the core dump in ubuntu 16.04LTS?<i class="fas fa-external-link-alt"></i></a></p></blockquote></li><li><p>设权限</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /var/lib/apport/</span><br><span class="line">sudo chmod 777 coredump/</span><br></pre></td></tr></table></figure></li><li><p>core移动到grading文件夹</p></li><li><p>debug</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb grading core</span><br></pre></td></tr></table></figure><p> gdb中常用</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where</span><br></pre></td></tr></table></figure></li></ol><hr><p>除了以上悲伤的故事，也有一些可喜可贺的习惯，给debug带了了巨大帮助，要继续保持：</p><ol><li>每一部分debug输出用参数控制，可以很方便的开关。</li><li>经常commit。避免debug变成写bug时，回退都无处可退。</li></ol><hr><p>备注：下文所有TM指的是Transactional Memory，不是口吐芬芳。</p><h1 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h1><p>写完read、write等基础操作，先加了个全局锁，放到虚拟机里测一下逻辑。</p><h2 id="atomic-load时segmentation-fault"><a href="#atomic-load时segmentation-fault" class="headerlink" title="atomic_load时segmentation fault"></a>atomic_load时segmentation fault</h2><p>本地跑没问题，但是虚拟机里make build-libs run就Segmentation fault。一番折腾后，定位到是atomic interger的问题。用atomic_store或者atomic_load的时候就会报错。</p><h3 id="尝试1"><a href="#尝试1" class="headerlink" title="尝试1"></a>尝试1</h3><p>在计算control structure的偏移量时，第一个segment没转(void*)，于是取地址出了问题，atomic_load时就崩了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">void</span>*)segment+segment-&gt;offset_control+CONTROL_SIZE*index</span><br></pre></td></tr></table></figure><p>改成这样本地跑又取不到了，就离谱</p><h3 id="尝试2（结构体指针）"><a href="#尝试2（结构体指针）" class="headerlink" title="尝试2（结构体指针）"></a>尝试2（结构体指针）</h3><p>怀疑是结构体指针的问题，打印了一下相关的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct segment* segment;</span><br><span class="line"></span><br><span class="line">DEBUG segment=0x7fb229405a30</span><br><span class="line">DEBUG (uint8_t*)segment=0x7fb229405a30</span><br><span class="line">DEBUG (void*)segment=0x7fb229405a30</span><br><span class="line">DEBUG &amp;segment=0x7ffedfedf530</span><br></pre></td></tr></table></figure><p>前三个是一样的，符合预期。那么计算偏移量的时候是否也一样？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DEBUG offset=208</span><br><span class="line"></span><br><span class="line">DEBUG segment+offset=0x7fb22940b530</span><br><span class="line">DEBUG (uint8_t*)segment+offset=0x7fb229405b00</span><br><span class="line">DEBUG (void*)segment+offset=0x7fb229405b00</span><br></pre></td></tr></table></figure><p>这里算出来就不一样了</p><p>b530-5a30 = 0x5b00 = 23296 = 208 * 112<br>而112正好是struct segment的大小，所以不转换直接加，单位是struct size</p><p>5b00-5a30 = 0xd0 = 208<br>这样就是对的，所以应该先转换指针类型</p><p>那么尝试1加了(void*)应该方向是对的</p><h2 id="control修改错误"><a href="#control修改错误" class="headerlink" title="control修改错误"></a>control修改错误</h2><p>接上一个bug，改完之后，发现set control owner出现问题，没有set成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[owner=0 v=0 w=0 s=0]</span><br></pre></td></tr></table></figure><p>写内存成功了，在函数内部打印control也是对的，但是结束之后整体print region时，control是空的</p><p>解决：<br>打印发现两次用control时地址不一样。是后面算control起始地址没有改过来，仍是直接算的，没有用定义的宏</p><p>改过来之后顺便检查了一遍，所有计算control地址的位置，都是用宏</p><h2 id="batch间reset-control后segmentation-fault"><a href="#batch间reset-control后segmentation-fault" class="headerlink" title="batch间reset control后segmentation fault"></a>batch间reset control后segmentation fault</h2><p>目前本地测试一轮中的transaction没什么问题，但是tm_end()、调用batcher_cleanup()之后，打印region出错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--------segment1--------</span><br><span class="line">[0] 00000000 | 11111111 [owner=0 v=1 w=0 s=0]</span><br><span class="line">[1] 00000000 | 11111111 [owner=0 v=1 w=0 s=0]</span><br><span class="line">[2] 00000000 | 22222222 [owner=0 v=1 w=0 s=0]</span><br><span class="line">[3] 00000000 | 22222222 [owner=0 v=1 w=0 s=0]</span><br><span class="line">--------segment0--------</span><br><span class="line">zsh: segmentation fault  ./tm.o</span><br></pre></td></tr></table></figure><p>应该是segment2，而不是0</p><h3 id="尝试1-1"><a href="#尝试1-1" class="headerlink" title="尝试1"></a>尝试1</h3><p>在batch_cleanup()中打印了一下segment id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(segment)&#123;</span><br><span class="line">        clean_up_segment(segment);</span><br><span class="line">        segment = segment-&gt;next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>发现第二次是0<br>可能是segment指针的问题<br>但是print_region()里面也有这个循环，没有问题，那边是这样写的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(segment != NULL)&#123;</span><br><span class="line">        print_segment(segment);</span><br><span class="line">        segment = segment-&gt;next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总不能是!=NULL的问题吧<br>试了一下，果然不是</p><h3 id="尝试2"><a href="#尝试2" class="headerlink" title="尝试2"></a>尝试2</h3><p>在batcher_cleanup()的循环里加了强制类型转换，好了一次，再测又不行了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">segment = (struct segment*)(segment-&gt;next);</span><br></pre></td></tr></table></figure><h3 id="尝试3（内存分配）"><a href="#尝试3（内存分配）" class="headerlink" title="尝试3（内存分配）"></a>尝试3（内存分配）</h3><p>打印region和segment的地址都是对的，但是为什么读出来东西就不对呢？</p><p>仔细看了下两块segment的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--------segment1-------- addr=0x7f9bc9c05a30</span><br><span class="line">[0] 00000000 | 11111111 [owner=1 v=0 w=1 s=1]</span><br><span class="line">[1] 00000000 | 11111111 [owner=1 v=0 w=1 s=1]</span><br><span class="line">[2] 00000000 | 22222222 [owner=1 v=0 w=1 s=1]</span><br><span class="line">[3] 00000000 | 22222222 [owner=1 v=0 w=1 s=1]</span><br><span class="line">--------segment2-------- addr=0x7f9bc9c05b30</span><br></pre></td></tr></table></figure><p>a30和b30这才隔了256，肯定会撞吧！难道是一开始分配就有问题？</p><p>初始化时的代码是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment</span>* <span class="title">segment</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> total_size = <span class="keyword">sizeof</span>(struct segment) + size*<span class="number">3</span> + size/align*<span class="keyword">sizeof</span>(<span class="keyword">atomic_uint_least64_t</span>);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(posix_memalign((<span class="keyword">void</span>**)&amp;segment, align, total_size) != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create_segment failed. cannot align memory.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看了下reference代码，先malloc的region，后面才posix_memalign的segment</p><p>改成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> total_size = <span class="keyword">sizeof</span>(struct segment) + size*<span class="number">3</span> + size/align*<span class="keyword">sizeof</span>(<span class="keyword">atomic_uint_least64_t</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">segment</span>* <span class="title">segment</span> =</span> (struct segment*) <span class="built_in">malloc</span>(total_size);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(posix_memalign((<span class="keyword">void</span>**)&amp;segment, align, total_size) != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create_segment failed. cannot align memory.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 成功！</p><p> 现在的地址是<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--------segment1-------- addr=0x7fde98405b20</span><br><span class="line">[0] 00000000 | 11111111 [owner=0 v=1 w=0 s=0]</span><br><span class="line">[1] 00000000 | 11111111 [owner=0 v=1 w=0 s=0]</span><br><span class="line">[2] 00000000 | 22222222 [owner=0 v=1 w=0 s=0]</span><br><span class="line">[3] 00000000 | 22222222 [owner=0 v=1 w=0 s=0]</span><br><span class="line">--------segment2-------- addr=0x7fde98405d10</span><br><span class="line">[0] 00000000 | 00000000 [owner=0 v=0 w=0 s=0]</span><br><span class="line">[1] 00000000 | 00000000 [owner=0 v=0 w=0 s=0]</span><br><span class="line">[2] 00000000 | 00000000 [owner=0 v=0 w=0 s=0]</span><br><span class="line">[3] 00000000 | 00000000 [owner=0 v=0 w=0 s=0]</span><br></pre></td></tr></table></figure><br>d10-b20 = 0x1f0 = 496</p><h2 id="阶段一测试"><a href="#阶段一测试" class="headerlink" title="阶段一测试"></a>阶段一测试</h2><p>丢进虚拟机跑grading<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-06 PM11.54.31.jpg"                      width=600                ><br>用时太久，正常。但是没有segmentation fault了，应该read write操作也没什么问题了，第一步完成！耶！</p><p>停掉了一些print，减少不必要的时间浪费，测TM相关函数</p><h2 id="malloc错误"><a href="#malloc错误" class="headerlink" title="malloc错误"></a>malloc错误</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[batcher_cleanup] region addr=0x7f1bc8000b20</span><br><span class="line">[batcher_cleanup] clean segment 1, addr=0x7f1bc8001530</span><br><span class="line">grading: malloc.c:2401: sysmalloc: Assertion `(old_top == initial_top (av) &amp;&amp; old_size == 0) || ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp; prev_inuse (old_top) &amp;&amp; ((unsigned long) old_end &amp; (pagesize - 1)) == 0)&#x27; failed.</span><br><span class="line">Makefile:40: recipe for target &#x27;run&#x27; failed</span><br></pre></td></tr></table></figure><p>像是个和内存分配有关的bug</p><blockquote><p>Why do I get a C malloc assertion failure?<br>检查clean_up_segment里的循环</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;segment-&gt;size; i++)</span><br></pre></td></tr></table></figure><p>终止条件写成了segment-&gt;size，应该是size/align<br>解决！</p><h2 id="时间太长"><a href="#时间太长" class="headerlink" title="时间太长"></a>时间太长</h2><p>现在grading输出是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[write]tx_id=1 seg_id=1 index=63 size=8</span><br><span class="line">[write]tx_id=1 seg_id=1 index=64 size=8</span><br><span class="line">[write]tx_id=1 seg_id=1 index=65 size=8</span><br><span class="line">[write]tx_id=1 seg_id=1 index=66 size=8</span><br><span class="line">[tm_end] id=1</span><br><span class="line"></span><br><span class="line">[batcher_cleanup]region addr=0x7f3a18000b20</span><br><span class="line">transaction created. id=2 addr=0x7f3a18001e30</span><br><span class="line">[read]tx_id=2 seg_id=1 index=3 size=8</span><br><span class="line">⎪ *** EXCEPTION ***</span><br><span class="line">⎩ Transactional library takes too long to process the transactions</span><br></pre></td></tr></table></figure><p>可能是用时太长，也可能是read有问题，先检查后者</p><p>单独打了一下read的输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[read align]tx_id=2 seg_id=1 index=64</span><br><span class="line">[read align]tx_id=2 seg_id=1 index=65</span><br><span class="line">[read align]tx_id=2 seg_id=1 index=66</span><br><span class="line">⎪ *** EXCEPTION ***</span><br><span class="line">⎩ Transactional library takes too long to process the transactions</span><br></pre></td></tr></table></figure><p>可以跑，那应该就是用时太长的问题，而不是逻辑问题<br>那么接下来就可以开始改并发相关的代码了</p><h1 id="虚假的阶段二"><a href="#虚假的阶段二" class="headerlink" title="虚假的阶段二"></a>虚假的阶段二</h1><p>前面基本测试了TM的read、write、alloc功能，现在把全局锁换成batcher</p><h2 id="时间太长-1"><a href="#时间太长-1" class="headerlink" title="时间太长"></a>时间太长</h2><p>现在的问题是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">⎪ *** EXCEPTION ***</span><br><span class="line">⎩ Transactional library takes too long to process the transactions</span><br><span class="line">Makefile:40: recipe for target &#x27;run&#x27; failed</span><br></pre></td></tr></table></figure><h3 id="尝试1-2"><a href="#尝试1-2" class="headerlink" title="尝试1"></a>尝试1</h3><p>把参数调小了还是很慢<br>看了下具体输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">transaction created. id=32 addr=0x7f35dc00d3d0 log_size=100</span><br><span class="line">[enter] current blocking length=1</span><br><span class="line">[read]tx_id=32 seg_id=1 index=3 size=8</span><br><span class="line">transaction created. id=33 addr=0x7f35dc00da40 log_size=100</span><br><span class="line">[enter] current blocking length=1</span><br></pre></td></tr></table></figure><p>似乎batcher的enter有问题，blocking length不对</p><p>…<br>一开始初始化把1写成0了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> const_zero = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> const_one = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="尝试2（逻辑错误）"><a href="#尝试2（逻辑错误）" class="headerlink" title="尝试2（逻辑错误）"></a>尝试2（逻辑错误）</h3><p>改batcher、换回锁，总是第一个transaction可以跑到batcher cleanup，第二批就不行，也许是中间清理有问题<br>但是本地测试并打印region，应该没问题</p><p>在虚拟机里加入了具体的R/W输出，发现第二轮的read卡住了<br>继续查发现read没问题，但是read之后write就写不进去了<br>发现是逻辑问题：写的时候，如果还没写过，会尝试gain_owner，但是如果自己已经读过了，需要判断owner是自己</p><p>但是虚拟机里跑还是不对，第一次read align返回了，但是没有后续了<br>发现是tm_read()最后应该return flag，写成了return false🤪</p><p>现在报错变成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">⎩ Violated isolation or atomicity</span><br></pre></td></tr></table></figure><p>终于可以进行下一步了</p><h1 id="阶段一’"><a href="#阶段一’" class="headerlink" title="阶段一’"></a>阶段一’</h1><h2 id="Violated-isolation-or-atomicity"><a href="#Violated-isolation-or-atomicity" class="headerlink" title="Violated isolation or atomicity"></a>Violated isolation or atomicity</h2><p>现在还是直接加锁，atomicity有问题只能是逻辑问题，一夜回到阶段一，又得开始找read、write、alloc的bug</p><p>多次测试，报错有2种，一个是violate atomicity，另一个是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[tm_begin 2]</span><br><span class="line">[tm_end 2]</span><br><span class="line">[tm_begin 3]</span><br><span class="line">[tm_end 3]</span><br><span class="line">[tm_begin 4]</span><br><span class="line">[tm_end 4]</span><br><span class="line">⎪ *** EXCEPTION ***</span><br><span class="line">⎩ Transactional library takes too long to process the transactions</span><br></pre></td></tr></table></figure><h3 id="尝试1-3"><a href="#尝试1-3" class="headerlink" title="尝试1"></a>尝试1</h3><p>怀疑是segment的问题，因为本地没怎么测alloc、free<br>但是加了输出，发现并没有调过这两个函数</p><h3 id="尝试2-1"><a href="#尝试2-1" class="headerlink" title="尝试2"></a>尝试2</h3><p>奇怪了，看输出没什么问题，到底是哪卡住了？<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-09 AM10.17.59.jpg"                      width=600                ><br>另一种情况是，可以继续跑，跑到最后violate atomicity</p><p>定位到一个bug！先read再write没有写write_flag！<br>但是对这里影响不大</p><h3 id="尝试3（逻辑错误）"><a href="#尝试3（逻辑错误）" class="headerlink" title="尝试3（逻辑错误）"></a>尝试3（逻辑错误）</h3><p>定位到yigebug！先write再read，读的是旧值！这个问题比较严重<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-09 AM10.48.06.jpg"                      width=600                ></p><p>现在的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read the writable copy into target</span></span><br><span class="line">read_readable_copy(target, segment, index);</span><br></pre></td></tr></table></figure><p> 这明显调的函数都和注释写的意思不一样啊🤪</p><h2 id="时间太长-2"><a href="#时间太长-2" class="headerlink" title="时间太长"></a>时间太长</h2><p> 现在的报错都是时间太长，会不会是其它线程被堵太久了？</p><p>把线程减到1个，大部分还是时间太长，有一个跑完了！感动！<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-09 AM11.03.47.jpg"                      width=600                ></p><p>把Slow trigger factor从8调到1024，都跑完了！感动！<br>也就是说，单线程的时候，read write没问题了！（测试里好像没有alloc free？）</p><p>改到2个线程，也可以跑！呜呜呜呜呜</p><p>一波未平一波又起，此时虚拟机出现了bug<br>罢了，做饭去</p><p>下午。<br>把grading的参数全部调回默认，除了slow_factor设成1024<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-09 PM2.43.00.jpg"                      width=600                ><br>对了对了！可以开始写batcher了！</p><h1 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h1><p>开始测batcher，这次要一步、一步、一步来</p><h2 id="Too-long"><a href="#Too-long" class="headerlink" title="Too long"></a>Too long</h2><p>开四个线程时，有时会卡住<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-10 PM4.45.21.jpg"                      width=600                ><br>感觉是某个transaction时间太长导致的</p><p>发现问题！如果有操作abort了，用户不会调tm_end</p><p>在read write失败时调leave()，解决</p><h2 id="没有core文件"><a href="#没有core文件" class="headerlink" title="没有core文件"></a>没有core文件</h2><p>想用coredump debug，运行显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make: *** [run] Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure><p>但是没有core文件</p><p>最后在↓的最后一个回答找到解决<br><a class="link"   href="https://askubuntu.com/questions/966407/where-do-i-find-the-core-dump-in-ubuntu-16-04lts" >Where do I find the core dump in ubuntu 16.04LTS?<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>found the core dunp in /var/lib/apport/coredump/</p></blockquote><p>core在不同文件夹，想移到同一个文件夹比较方便，拖的时候permission denied，先改了下权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 coredump/</span><br></pre></td></tr></table></figure><p>然后就可以debug了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb grading core</span><br></pre></td></tr></table></figure><p>发现是leave()的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#0  0x00007f13e809812c in leave ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br><span class="line">[Current thread is 1 (Thread 0x7f13e929c700 (LWP 1903))]</span><br></pre></td></tr></table></figure><p>但是没有显示行号，在编译时加-g（改Makefile）也不行</p><h2 id="Violated-isolation-or-atomicity-1"><a href="#Violated-isolation-or-atomicity-1" class="headerlink" title="Violated isolation or atomicity"></a>Violated isolation or atomicity</h2><p>添加了read log、write log、transaction log，加锁测试通过，改成batcher后报错</p><p>发现1或2个线程时，结果正确，4个线程会出错</p><p>发现竟然是因为开着DEBUG_READ和DEBUG_WRITE，可能是写debug output时同时访问，但是没有做同步控制，导致出错。关掉输出就好了</p><h2 id="Violated-consistency"><a href="#Violated-consistency" class="headerlink" title="Violated consistency"></a>Violated consistency</h2><p>现在大部分时间没问题，有时会出这个错</p><p>重新读了一下consistency的定义。难道是如果process读了一个值，后面这个值被改了，也得abort？但是如果被读过，这个值后面应该不能修改了。</p><h3 id="尝试1-4"><a href="#尝试1-4" class="headerlink" title="尝试1"></a>尝试1</h3><p>也许是因为read align和write align中，有时有多个判断，这些判断单独都是atomic的，但是合在一起就不是了。<br>改了一些逻辑，合并判断和交换，还是不对。</p><h3 id="尝试2-2"><a href="#尝试2-2" class="headerlink" title="尝试2"></a>尝试2</h3><p>在workload.hpp里加了一堆输出，打印具体是哪里出错，发现一个常见问题是check()中counter!=0<br>可是这个counter是什么鬼？</p><figure class="highlight hpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shared&lt;<span class="keyword">size_t</span>&gt; counter&#123;tx, tm.<span class="built_in">get_start</span>()&#125;;</span><br></pre></td></tr></table></figure><p> 找到定义<br> <figure class="highlight hpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">       Shared&lt;<span class="keyword">size_t</span>&gt;         count; <span class="comment">// Number of allocated accounts in this segment</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">/** Binding constructor.</span></span><br><span class="line"><span class="comment">        * @param tx      Associated pending transaction</span></span><br><span class="line"><span class="comment">        * @param address Block base address</span></span><br><span class="line"><span class="comment">       **/</span></span><br><span class="line">       <span class="built_in">AccountSegment</span>(Transaction&amp; tx, <span class="keyword">void</span>* address): count&#123;tx, address&#125;, next&#123;tx, count.<span class="built_in">after</span>()&#125;, parity&#123;tx, next.<span class="built_in">after</span>()&#125;, accounts&#123;tx, parity.<span class="built_in">after</span>()&#125; &#123;&#125;</span><br></pre></td></tr></table></figure><br>好像和transaction数量有关，会不会是最后没有free？<br>并不是。</p><p>1或2个线程的时候没事，3个以上出错，难道是OTHER的问题？<br>又检查了一遍逻辑感觉也没什么毛病</p><h3 id="尝试3"><a href="#尝试3" class="headerlink" title="尝试3"></a>尝试3</h3><p>现有的2个报错分别是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">------WL5------ counter=16</span><br><span class="line">[1011 leave]&#123;979&#125; committed=1 remain=0 blocked=0</span><br><span class="line">[1011 tm_end]</span><br><span class="line">⎩ Violated consistency</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">------WL1------ sum=61</span><br><span class="line">------WL1------ init_balance=10</span><br><span class="line">------WL1------ count=6</span><br><span class="line">Violated isolation or atomicity</span><br></pre></td></tr></table></figure><p>后者似乎导致了前者，需要先解决。<br>一个现象是，每次差的值都是1，而不会更大<br>加到8个线程会出现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">------WL1------ sum=637</span><br><span class="line">------WL1------ init_balance=10</span><br><span class="line">------WL1------ count=64</span><br></pre></td></tr></table></figure><p>总之基本偏差不大，像是哪里有个细节不对，但是到底在哪啊💥</p><p>但是counter最后的的偏差又很大…</p><p>把transaction数量减小之后，只发现Violated consistency，而没有Violated isolation or atomicity，不会是哪里溢出了吧？<br>就10和100的区别，也不至于啊。</p><h3 id="尝试4"><a href="#尝试4" class="headerlink" title="尝试4"></a>尝试4</h3><p>又开始读workload.hpp，这个count应该就是所有segment里面account值的和，加起来应该等于预期。那么这个值错了，其实还是read、write的问题。</p><p>给read、write加锁，还是同样的报错。那么难道是batcher的问题？</p><p>又多打了一点输出，上面Violated isolation or atomicity这个问题都是出现在 Long read-only transaction, summing the balance of each account中，其实也就是在检查实际进行操作的short transaction的结果是否正确。</p><p>再想想，参数小的时候，出错误一，参数大的时候，出一和二，那么还是应该一是更根本的。而一的关键在于counter，最后应该为0。那么这个counter到底是个什么啊？？？</p><h3 id="尝试5（CAS条件）"><a href="#尝试5（CAS条件）" class="headerlink" title="尝试5（CAS条件）"></a>尝试5（CAS条件）</h3><p>仔细读输出，找到了一个bug！！！一下午了，终于见到实际的bug在哪了！！！第一次见到bug这么激动。</p><p>有write之后，竟然又读成功，还改了owner，简直离谱。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-12 PM5.57.15.jpg"                      width=600                ></p><p>多加了一些输出，轻松复现这个bug。都是有2个transaction，A读写位置1、位置2，B在A之后读写位置3、位置2。正确情况应该是B读写位置2失败，但是现在 成功了。</p><p>问题在于read_align()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if the word has not been written in the current epoch then</span></span><br><span class="line"><span class="comment">// add the transaction into the “access set” (if not already in); </span></span><br><span class="line"><span class="comment">// try set owner</span></span><br><span class="line"><span class="keyword">uint_least64_t</span> read_and_set_owner = tr-&gt;id &lt;&lt; <span class="number">32</span> | valid;</span><br><span class="line"><span class="keyword">if</span>(atomic_compare_exchange_strong(cur_control, &amp;load_control, read_and_set_owner))</span><br></pre></td></tr></table></figure><p>比较的expected值不应该是load到的值！而是判断如果owner是自己，应该是的值。</p><h2 id="Reset错误"><a href="#Reset错误" class="headerlink" title="Reset错误"></a>Reset错误</h2><p>改完这个又发现一个bug<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-12 PM7.41.39.jpg"                      width=600                ><br>A写了位置9，之后B也想写位置9但没写成功，最后没有交换valid。<br>也就是说，B先退出，调用clean flag，此时由于B没有成功，直接将control清空了，9写的WRITE_FLAG也没有了。<br>加一个判断，只有自己是owner时才reset，应该可以解决问题。</p><p>现在没有Violated isolation or atomicity的问题了（或者没碰到）。<br>暂时测试可以正常跑完了。</p><h1 id="阶段三"><a href="#阶段三" class="headerlink" title="阶段三"></a>阶段三</h1><p>batcher的功能写对了（但愿），接下来尝试在服务器上跑通（20 threads和10000 transaction per worker）。</p><h2 id="Floating-point-exception"><a href="#Floating-point-exception" class="headerlink" title="Floating point exception"></a>Floating point exception</h2><p>为了避免每次clean segments遍历整个内存，将修改过的地方记了log，但是上服务器log会爆掉。<br>改成了overflow的时候realloc四倍空间</p><p>然后就出现了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make: *** [run] Floating point exception (core dumped)</span><br></pre></td></tr></table></figure><h3 id="尝试1-5"><a href="#尝试1-5" class="headerlink" title="尝试1"></a>尝试1</h3><p>gdb grading core一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[New LWP 2519]</span><br><span class="line">[New LWP 2518]</span><br><span class="line">[New LWP 2509]</span><br><span class="line">Core was generated by `./grading 453 ../reference.so ../338094.so&#x27;.</span><br><span class="line">Program terminated with signal SIGSEGV, Segmentation fault.</span><br><span class="line">#0  0x00007f34bc478f31 in ?? ()</span><br><span class="line">[Current thread is 1 (LWP 2517)]</span><br><span class="line">(gdb) where</span><br><span class="line">#0  0x00007f34bc478f31 in ?? ()</span><br><span class="line">#1  0x0000000000000387 in ?? ()</span><br><span class="line">#2  0x00007f34b8000b20 in ?? ()</span><br><span class="line">#3  0x0000000000000006 in ?? ()</span><br></pre></td></tr></table></figure><p>…说了个寂寞</p><h3 id="尝试2（free之后）"><a href="#尝试2（free之后）" class="headerlink" title="尝试2（free之后）"></a>尝试2（free之后）</h3><p>发现是上次设置的core dump参数在虚拟机重启后没有了，需要重新再来一遍。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited</span><br><span class="line">ulimit -a</span><br></pre></td></tr></table></figure><p>权限也要重设。<br>然后就可以看core dump文件了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Program terminated with signal SIGFPE, Arithmetic exception.</span><br><span class="line">#0  0x00007f8a4a5c30d8 in tm_read ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br><span class="line">[Current thread is 1 (Thread 0x7f8a4b7c6700 (LWP 2112))]</span><br><span class="line">(gdb) where</span><br><span class="line">#0  0x00007f8a4a5c30d8 in tm_read ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br><span class="line">#1  0x00005582a6470496 in TransactionalMemory::read (this=&lt;optimized out&gt;, </span><br><span class="line">    this=&lt;optimized out&gt;, target=0x7f8a4b7c47c0, size=8, </span><br><span class="line">    source=0x7f8a44008210, tx=&lt;optimized out&gt;) at transactional.hpp:231</span><br><span class="line">#2  Transaction::read (target=0x7f8a4b7c47c0, size=8, source=0x7f8a44008210, </span><br><span class="line">    this=0x7f8a4b7c47d0) at transactional.hpp:312</span><br><span class="line">#3  Shared&lt;unsigned long&gt;::read (this=&lt;synthetic pointer&gt;)</span><br><span class="line">    at transactional.hpp:394</span><br><span class="line">#4  Shared&lt;unsigned long&gt;::operator unsigned long (this=&lt;synthetic pointer&gt;)</span><br><span class="line">    at transactional.hpp:398</span><br></pre></td></tr></table></figure><p>竟然是read里面浮点异常？read里面浮点都没有啊哪来的异常？？？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Core was generated by `./grading 453 ../reference.so ../338094.so&#x27;.</span><br><span class="line">Program terminated with signal SIGFPE, Arithmetic exception.</span><br><span class="line">#0  0x00007f7533dfd9c8 in clean_log ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br><span class="line">[Current thread is 1 (Thread 0x7f754080d700 (LWP 3303))]</span><br><span class="line">(gdb) where</span><br><span class="line">#0  0x00007f7533dfd9c8 in clean_log ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br><span class="line">#1  0x00007f7533dfdaae in clean_transaction ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br><span class="line">#2  0x00007f7533dfdb23 in batcher_cleanup ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br><span class="line">#3  0x00007f7533dfdbf8 in leave ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br><span class="line">#4  0x00007f7533dfde2d in tm_end ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br></pre></td></tr></table></figure><p>这次在clean_log()里，还靠谱点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[clean_log] size=8</span><br><span class="line">[clean_log] align=0</span><br></pre></td></tr></table></figure><p>好家伙！真是除0啊！</p><p>打印发现segment id是0，明显是访问到了不该访问的segment，要么是起始地址算错了，要么是遍历错了。</p><p>会不会是clean了已经被free的segment啊？<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-12 PM9.55.00.jpg"                      width=600                ><br>果然！</p><p>所以是因为，read、write的时候写了log，一轮结束的时候根据log里的地址去重设control。但是可能其中有的segment已经被free掉了。</p><p>改成defer到tm_destroy再free segment，成功！<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-12 PM11.17.52.jpg"                                      ></p><h2 id="Segmentation-fault"><a href="#Segmentation-fault" class="headerlink" title="Segmentation fault"></a>Segmentation fault</h2><p>上服务器跑一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ERROR] write log overflow!⎪ *** EXCEPTION ***</span><br><span class="line">⎩ Transactional library takes too long to process the transactions</span><br></pre></td></tr></table></figure><p>log写死512不够。</p><p>试图在虚拟机里复现bug，参数调到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto const nbworkers = 4;</span><br><span class="line">auto const nbtxperwrk    = 160000ul / nbworkers;</span><br><span class="line">auto const nbaccounts    = 32 * nbworkers;</span><br><span class="line">auto const expnbaccounts = 256 * nbworkers;</span><br></pre></td></tr></table></figure><p>时，又出现了Segmentation fault，查看core</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Program terminated with signal SIGSEGV, Segmentation fault.</span><br><span class="line">#0  0x00007fe97e5faa00 in clean_log ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br><span class="line">[Current thread is 1 (Thread 0x7fe97ffff700 (LWP 1476))]</span><br></pre></td></tr></table></figure><p>是log的问题</p><p>奇怪的是，打开clean的debug输出后，报错变成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[batcher_cleanup] total=2</span><br><span class="line">[3 clean #write=1 #read=0]</span><br><span class="line">[2 clean #write=129 #read=0]</span><br><span class="line">[batcher_cleanup] total=1</span><br><span class="line">[5 clean #write=0 #read=2]</span><br><span class="line">[batcher_cleanup] total=1</span><br><span class="line">[6 clean #write=0 #read=2]</span><br><span class="line">⎪ *** EXCEPTION ***</span><br><span class="line">⎩ Transactional library takes too long to process the transactions</span><br></pre></td></tr></table></figure><p>先把slow factor调成1024</p><p>发现有时候read log满了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[78516 clean #write=0 #read=512]</span><br><span class="line">[batcher_cleanup] done.</span><br><span class="line">batch round -&gt; 32924</span><br><span class="line">[batcher_cleanup] total=1</span><br><span class="line">[78517 clean #write=0 #read=512]</span><br><span class="line">[batcher_cleanup] done.</span><br><span class="line">batch round -&gt; 32925</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">batch round -&gt; 56620</span><br><span class="line">[77895 tm_begin] is_ro=0</span><br><span class="line">[ERROR] read log overflow! tr_id=77894 is_ro=1</span><br><span class="line">[77896 tm_begin] is_ro=1</span><br><span class="line">[ERROR] read log overflow! tr_id=77893 is_ro=1</span><br><span class="line">[77897 tm_begin] is_ro=1</span><br></pre></td></tr></table></figure><p>不是设置过read only不写log吗？发现代码里没有，可能是前面哪次debug回退删掉了🤪</p><p>重新加入判断：is_ro时不写log、不清理，成功！</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-13 AM11.45.34.jpg"                      width=600                ><p>现在跑↑这个参数可以过了！可喜可贺！</p><h2 id="log-overflow"><a href="#log-overflow" class="headerlink" title="log overflow"></a>log overflow</h2><p>上服务器！</p><p>write log overflow😭</p><p>512，不够<br>1024，不够<br>2048，不够！</p><p>虚拟机调成相同的参数试试。至少有一个好消息，虚拟机的报错现在和服务器一样了！也就是说， 可以直接在虚拟机上测试一下log的大小。</p><p>可是虚拟机2048够了啊？见鬼。</p><p>等等…刚才上服务器改了参数忘记重新打包zip了…2048重新试一次</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-13 PM12.03.39.jpg"                      width=600                ><p>啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊！！！！！！！！！！！！！！！！</p><p>虚拟机1024也能过，要不上服务器再试一次。果不其然！过了！哈哈哈哈哈！</p><h1 id="Milestone"><a href="#Milestone" class="headerlink" title="Milestone"></a>Milestone</h1><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-13 PM12.16.39.jpg"                      width=600                ><p>太感动了！</p><p>第一次过，绿色，竟然有1.6！活过来了！</p><p>从11/28开始写这个版本，断断续续写到今天12/13，差不多两周，终于，及格了😭😭😭<br>（虽然中间还写了个DA project submission3，DA可真是太友善了，我爱Java）</p><h1 id="阶段四"><a href="#阶段四" class="headerlink" title="阶段四"></a>阶段四</h1><p>尝试改进，提高性能。</p><p>-&gt; <a href="https://coconutnutx.github.io/2021/12/16/ca-condition/">CA project 状态分析&amp;debug</a></p><h2 id="BoundedOverrun"><a href="#BoundedOverrun" class="headerlink" title="BoundedOverrun"></a>BoundedOverrun</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terminate called after throwing an instance of &#x27;Exception::BoundedOverrun&#x27;</span><br></pre></td></tr></table></figure><p>发现是优化逻辑后read_only transaction没有free</p><h1 id="Memcheck"><a href="#Memcheck" class="headerlink" title="Memcheck"></a>Memcheck</h1><p>下面主要是用Valgrind检查内存泄漏时的问题。</p><p>解决上面的问题后还有泄露：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">==2068== 32 bytes in 1 blocks are still reachable in loss record 1 of 2</span><br><span class="line">==2068==    at 0x4C33B25: calloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">==2068==    by 0x4E3F7F4: _dlerror_run (dlerror.c:140)</span><br><span class="line">==2068==    by 0x4E3F050: dlopen@@GLIBC_2.2.5 (dlopen.c:87)</span><br><span class="line">==2068==    by 0x10DEE7: TransactionalLibrary::TransactionalLibrary(char const*) (in /home/dcl/Desktop/CS453-2021-project-main/grading/grading)</span><br><span class="line">==2068==    by 0x10B25C: main (in /home/dcl/Desktop/CS453-2021-project-main/grading/grading)</span><br><span class="line">==2068== </span><br><span class="line">==2068== 2,448 bytes in 51 blocks are definitely lost in loss record 2 of 2</span><br><span class="line">==2068==    at 0x4C31B0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">==2068==    by 0x859A0D9: ???</span><br><span class="line">==2068==    by 0x10E12D: Transaction::Transaction(TransactionalMemory const&amp;, Transaction::Mode) (in /home/dcl/Desktop/CS453-2021-project-main/grading/grading)</span><br><span class="line">==2068==    by 0x10F425: auto transactional&lt;WorkloadBank::long_tx(unsigned long&amp;) const::&#123;lambda(Transaction&amp;)#1&#125;&gt;(TransactionalMemory const&amp;, Transaction::Mode, WorkloadBank::long_tx(unsigned long&amp;) const::&#123;lambda(Transaction&amp;)#1&#125;&amp;&amp;) [clone .constprop.125] (in /home/dcl/Desktop/CS453-2021-project-main/grading/grading)</span><br><span class="line">==2068==    by 0x110A7A: WorkloadBank::run(unsigned long, unsigned long) const (in /home/dcl/Desktop/CS453-2021-project-main/grading/grading)</span><br><span class="line">==2068==    by 0x10D376: measure(Workload&amp;, unsigned int, unsigned int, unsigned long, unsigned long, unsigned long, unsigned long)::&#123;lambda(unsigned int)#1&#125;::operator()(unsigned int) const (in /home/dcl/Desktop/CS453-2021-project-main/grading/grading)</span><br><span class="line">==2068==    by 0x531E6DE: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.25)</span><br><span class="line">==2068==    by 0x50496DA: start_thread (pthread_create.c:463)</span><br><span class="line">==2068==    by 0x5CC171E: clone (clone.S:95)</span><br></pre></td></tr></table></figure><p>应该是read only在read失败时，不会调用tm_end，所以应该就地free。</p><p>果然。迅速解决！耶！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;惨痛经验&quot;&gt;&lt;a href=&quot;#惨痛经验&quot; class=&quot;headerlink&quot; title=&quot;惨痛经验&quot;&gt;&lt;/a&gt;惨痛经验&lt;/h1&gt;&lt;h2 id=&quot;Start-easy&quot;&gt;&lt;a href=&quot;#Start-easy&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Debug" scheme="https://coconutnutx.github.io/categories/Debug/"/>
    
    
      <category term="concurrent_algorithm" scheme="https://coconutnutx.github.io/tags/concurrent-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>DA project 总结</title>
    <link href="https://coconutnutx.github.io/2021/12/01/project-review/"/>
    <id>https://coconutnutx.github.io/2021/12/01/project-review/</id>
    <published>2021-12-01T07:06:31.000Z</published>
    <updated>2021-12-01T07:06:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>基于UDP Socket，实现Perfect Links -&gt; Uniform Reliable Broadcast -&gt; FIFO Broadcast application和Localized Causal Broadcast</p><h1 id="Perfect-Links层"><a href="#Perfect-Links层" class="headerlink" title="Perfect Links层"></a>Perfect Links层</h1><p>点对点的通信，测试时跑n个process，给其中一个发m条消息。</p><p>需要满足的性质：</p><ul><li>Reliable delivery -&gt; 如果发送、接收方都正确，每一条发出的消息最终都会被接收方deliver</li><li>No duplication -&gt; 不重复deliver</li><li>No creation -&gt; 不凭空产生消息<h2 id="主要的几个类"><a href="#主要的几个类" class="headerlink" title="主要的几个类"></a>主要的几个类</h2></li></ul><ol><li>PerfectLinks<ul><li>调用SocketClient发消息</li><li>检查并deliver，向上(URB)indicate</li></ul></li><li>SocketClient<ul><li>创建并发送Socket（包括普通消息和ACK）</li></ul></li><li>SocketServer（单独的线程）<ul><li>监听Socket，收到消息时，交给SocketServerHandler处理</li></ul></li><li>SocketServerHandler（单独的线程）<ul><li>处理收到的消息，向上(PerfectLinks)indicate</li></ul></li><li>MessageResender（单独的线程）<ul><li>定时检查并重发消息<h2 id="保证Reliable-delivery"><a href="#保证Reliable-delivery" class="headerlink" title="保证Reliable delivery"></a>保证Reliable delivery</h2>通过ACK实现。PerfectLinks发送消息后，维持一个pending集合，用于存所有已经发送、但还没有收到ACK的消息，收到ACK后将消息移出。MessageResender定时检查这个集合，重发其中的所有消息。<h2 id="保证No-duplication"><a href="#保证No-duplication" class="headerlink" title="保证No duplication"></a>保证No duplication</h2>维持一个delivered集合即可。<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2>SocketServerHandler用到线程池，防止同时收到消息太多时炸掉。<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2>可能会出现冲突的是pending和delivered，用ConcurrentHashMap实现。<h2 id="SEQ细节"><a href="#SEQ细节" class="headerlink" title="SEQ细节"></a>SEQ细节</h2>上层的消息有一个SEQ，创建之后不会改变，且在后面的广播中，发送给每一个process的SEQ都是一样的。而PL层需要区分发给不同process的SEQ，于是加入了PSEQ。PerfectLinks有一个AtomicInteger，每次创建消息时getAndIncrement得到PSEQ。<h1 id="Uniform-Reliable-Broadcast层"><a href="#Uniform-Reliable-Broadcast层" class="headerlink" title="Uniform Reliable Broadcast层"></a>Uniform Reliable Broadcast层</h1>每个process对其他所有process广播m条消息，需满足的性质：</li></ul></li></ol><ul><li>Validity -&gt; 如果一个正确的process广播了一条消息，它最终会deliver这条消息</li><li>No duplication</li><li>No creation</li><li>Agreement -&gt; 如果某个正确的process deliver了一条消息，最终所有的process都会deliver这条消息<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2>UniformReliableBroadcast类调用PerfectLinks对每一个process发送消息。<h2 id="保证Agreement"><a href="#保证Agreement" class="headerlink" title="保证Agreement"></a>保证Agreement</h2>测试环境保证了至少一半的process是正确的，基于这个假设，只要确保大多数process收到消息即可。</li></ul><p>每次broadcast或收到一条新消息后，加入pending。收到新消息还需要转发，即再次广播这条消息，此时SEQ是不变的，消息中需要含有creator id和sender id。</p><p>对pending中的每一条消息，统计从哪些不同的sender处收到了这条消息（此处收到消息，类似PL层收到ACK），如果总数过半，即可deliver。</p><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>上述统计用到BitSet实现。对pending中的每条消息，用一个BitSet记录从哪些id收到了这条消息。</p><p>当总数过半，deliver之后，消息可以从pending中移出。转而加入delivered中，此时不需要保留之前的统计信息，记录一个SEQ就够了。</p><h1 id="FIFO-Broadcast-application层"><a href="#FIFO-Broadcast-application层" class="headerlink" title="FIFO Broadcast application层"></a>FIFO Broadcast application层</h1><p>性质：在URB的基础上，还需保证按序deliver</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>用一个AtomicInteger数组next，记录对于每一个process，当前以及deliver的消息的SEQ。一开始用了PriorityQueue，每次比较顶部和next。后面发现PriorityQueue并发得加锁，于是还是改成了用set记录收到的SEQ，可并发的set通过ConcurrentHashMap.newKeySet()得到。</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>用一个AtomicInteger统计当前process发出、但还没有deliver的消息数量。该数量超过阈值时，暂停发送新消息。</p><h2 id="检查deliver细节"><a href="#检查deliver细节" class="headerlink" title="检查deliver细节"></a>检查deliver细节</h2><p>每次收到消息后，检查pending中来自这条消息creator的，有没有符合要求可以deliver的消息。用到这样一句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(currentPending.remove(currentNext.get()))&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">currentNext.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>currentPending是一个ConcurrentSet，只有remove成功时才会返回true，可以避免并发访问时的冲突。</p><p>至此，从PerfectLinks到FIFO，都不用加synchronized。</p><h1 id="UML-activity-graph-1"><a href="#UML-activity-graph-1" class="headerlink" title="UML activity graph 1"></a>UML activity graph 1</h1><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/DA_fifo_v2.jpg"                                     ><h1 id="Localized-Causal-Broadcast层"><a href="#Localized-Causal-Broadcast层" class="headerlink" title="Localized Causal Broadcast层"></a>Localized Causal Broadcast层</h1><p>性质：在URB的基础上，还需保证causal order<br>例如，1依赖2、3，则当1deliver了2、3的消息m1、m2后，再broadcast新消息m3，那么其它所有process在deliver m3之前，都必须已经deliver了2、3的消息m1、m2。<br>无依赖的消息仍需保证FIFO。</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>用2个AtomicInteger数组，一个是vector clock，当deliver一条消息后，对应的位置+1；另一个是dependency clock，当deliver依赖的消息后，对应的位置+1。发送消息时，同时发送当前的dependency clock。收到消息时，需先解析出消息附带的clock，判断这条消息的所有依赖是否满足，是才可以deliver，否则加入pending。</p><h2 id="2个clock"><a href="#2个clock" class="headerlink" title="2个clock"></a>2个clock</h2><p>区分不同的vector clock和dependency clock，是考虑到以下情况：<br>对于某一个process i，可能broadcast了很多条消息，但都还没有deliver，那么此时vector clock还没有更新。但是对于其它接收消息的process，它们在deliver来自i的消息时，要保证顺序。通过dependency clock可以统一的处理顺序和依赖。<br>（实际上只用一个vector clock记录也行，但是打包和更新有点麻烦，于是干脆就分开了，也只占用process总数个AtomicInteger，可以接受）</p><h2 id="检查deliver"><a href="#检查deliver" class="headerlink" title="检查deliver"></a>检查deliver</h2><p>类似FIFO，仍然是在收到每条消息后，检查对应的creator，是否有来自改creator的消息可以deliver，不同的是需要比较dependency。<br>这里用深度优先遍历的方法，从左到右比较消息的clock和当前的vector clock，如果全部满足，deliver该消息并返回true。如果缺少依赖，先看能否解决依赖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkDeliver</span><span class="params">(<span class="keyword">int</span> createrId)</span></span>&#123;</span><br><span class="line">        ConcurrentHashMap&lt;Integer, URBMessage&gt; currentPending = pending.get(createrId);</span><br><span class="line">        <span class="keyword">boolean</span> hasDeilivered = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// traverse according to SEQ of this creator</span></span><br><span class="line">        <span class="keyword">while</span>(currentPending.containsKey(vectorClock[createrId-<span class="number">1</span>].get()+<span class="number">1</span>))&#123;</span><br><span class="line">            URBMessage urbMessage = currentPending.get(vectorClock[createrId-<span class="number">1</span>].get()+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// check dependency</span></span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=totalHost; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vectorClock[i-<span class="number">1</span>].get() &lt; urbMessage.vectorClock[i-<span class="number">1</span>])&#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="keyword">false</span>)&#123;</span><br><span class="line">                <span class="comment">// has dependency</span></span><br><span class="line">                System.out.println(<span class="string">&quot;depend on &quot;</span>+i);</span><br><span class="line">                <span class="comment">// check if dependency can be solved</span></span><br><span class="line">                <span class="keyword">if</span>(createrId==myId || checkDeliver(i)==<span class="keyword">false</span>)&#123;</span><br><span class="line">                    <span class="comment">// nothing delivered</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                deliver(urbMessage);</span><br><span class="line">                hasDeilivered = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hasDeilivered;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="UML-activity-graph-2"><a href="#UML-activity-graph-2" class="headerlink" title="UML activity graph 2"></a>UML activity graph 2</h1><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/DA_lcb.jpg"                                     >]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h1&gt;&lt;p&gt;基于UDP Socket，实现Perfect Links -&amp;gt; Uniform Reliable Broadcast -&amp;gt; FI
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="distributed_algorithm" scheme="https://coconutnutx.github.io/tags/distributed-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>DA project 2 validation tool</title>
    <link href="https://coconutnutx.github.io/2021/11/30/validate/"/>
    <id>https://coconutnutx.github.io/2021/11/30/validate/</id>
    <published>2021-11-30T08:40:52.000Z</published>
    <updated>2021-11-30T08:40:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h1><p>‼️ Dependency bug fixed. (10/12)</p><p>‼️ 不测试FIFO</p><p>‼️ 最多9个线程（若要测10+可修改拼接文件名代码）</p><hr><p>为了测试submission2(Localized Causal Broadcast)的输出写了个简陋工具，仅<strong>有限情况</strong>下<strong>测试</strong>用<br>仅！供！参！考！不！保！证！对！</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>如，process 1依赖2、3，和4、5没关系，先找出所有process输出中关于1、2、3的消息，然后统计1 broadcast每条消息时的vector clock，以及其它process deliver每条消息时的vector clock，后者的&gt;=前者。1的输出可以比其它多，此时多的不考虑，只比较前面的部分。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>基本和给的validate_fifo.py差不多<br>把代码、config、output放在同一个文件夹内（即stress.py的所有输出，有多余的没关系）<br>带参数–proc_num运行</p><h2 id="流程示例"><a href="#流程示例" class="headerlink" title="流程示例"></a>流程示例</h2><ol><li>cd到tools</li><li>把validate_lcausal.py放到tools中</li><li>run stress<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python stress.py -r ../template_java/run.sh -t lcausal -l output -p 4 -m 100</span><br><span class="line"></span><br><span class="line">// VM</span><br><span class="line">python3 stress.py -r ../template_java/run.sh -t lcausal -l output -p 4 -m 100</span><br></pre></td></tr></table></figure><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-11-30 AM9.51.22.jpg"                      width='400px'                ></li><li>run validate<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python validate_lcausal.py --proc_num 4</span><br><span class="line"></span><br><span class="line">// VM</span><br><span class="line">python3 validate_lcausal.py --proc_num 4</span><br></pre></td></tr></table></figure><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-01 PM3.03.46.jpg"                      width='600px'                ></li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">config_path = <span class="string">&#x27;./output/config&#x27;</span></span><br><span class="line">output_path = <span class="string">&#x27;./output/proc0&#x27;</span>   <span class="comment"># append id.output later, id&lt;=9</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_config</span>():</span></span><br><span class="line">    f = <span class="built_in">open</span>(config_path,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">    data = f.readlines()</span><br><span class="line">    m = <span class="number">0</span></span><br><span class="line">    <span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> data:</span><br><span class="line">        splited = line.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">            m = <span class="built_in">int</span>(splited[<span class="number">0</span>]) <span class="comment"># how many messages each process should broadcast</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        sender = <span class="built_in">int</span>(splited[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(splited)):</span><br><span class="line">            <span class="built_in">dict</span>.setdefault(sender,[]).append(<span class="built_in">int</span>(splited[i])) <span class="comment"># dependency (including sender itself)</span></span><br><span class="line">        count+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dict</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># find all &#x27;d sender seq&#x27; in output_id, where sender is in depent set</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDependentList</span>(<span class="params"><span class="built_in">id</span>, dset</span>):</span></span><br><span class="line">    cur_output_path = output_path+<span class="built_in">str</span>(<span class="built_in">id</span>)+<span class="string">&#x27;.output&#x27;</span></span><br><span class="line">    f = <span class="built_in">open</span>(cur_output_path,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">    data = f.readlines()</span><br><span class="line">    </span><br><span class="line">    sequence = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> data:</span><br><span class="line">        splited = line.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> splited[<span class="number">0</span>] == <span class="string">&quot;d&quot;</span>: <span class="comment"># only consider diliver</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(splited[<span class="number">1</span>]) <span class="keyword">in</span> dset: <span class="comment"># only consider sender in depent set</span></span><br><span class="line">                sequence.append(line)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(<span class="built_in">id</span>),<span class="string">&#x27;#msg:&#x27;</span>,<span class="built_in">len</span>(sequence))</span><br><span class="line">    <span class="keyword">return</span> sequence</span><br><span class="line"></span><br><span class="line"><span class="comment"># find all &#x27;b seq&#x27; and relevent delivered message in output_id, where sender is in depent set</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDependentListOfCreator</span>(<span class="params"><span class="built_in">id</span>, dset</span>):</span></span><br><span class="line">    cur_output_path = output_path+<span class="built_in">str</span>(<span class="built_in">id</span>)+<span class="string">&#x27;.output&#x27;</span></span><br><span class="line">    f = <span class="built_in">open</span>(cur_output_path,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">    data = f.readlines()</span><br><span class="line">    </span><br><span class="line">    sequence = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> data:</span><br><span class="line">        splited = line.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> splited[<span class="number">0</span>] == <span class="string">&quot;b&quot;</span>:</span><br><span class="line">            sequence.append(line)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(splited[<span class="number">1</span>]) <span class="keyword">in</span> dset:</span><br><span class="line">                sequence.append(line)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(<span class="built_in">id</span>),<span class="string">&#x27;#msg:&#x27;</span>,<span class="built_in">len</span>(sequence))</span><br><span class="line">    <span class="keyword">return</span> sequence</span><br><span class="line">    </span><br><span class="line"><span class="comment"># get vector clock associated with each message created by id from sequence</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getVectorClock</span>(<span class="params">sequence, <span class="built_in">id</span>, proc_num</span>):</span></span><br><span class="line">    clock = []</span><br><span class="line">    msg_clock_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(proc_num+<span class="number">1</span>):</span><br><span class="line">        clock.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> msg <span class="keyword">in</span> sequence:</span><br><span class="line">        splited = msg.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        sender = <span class="built_in">int</span>(splited[<span class="number">1</span>])</span><br><span class="line">        clock[sender]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> sender==<span class="built_in">id</span>:</span><br><span class="line">            msg_clock_list.append(clock.copy())</span><br><span class="line">    <span class="keyword">return</span> msg_clock_list</span><br><span class="line"></span><br><span class="line"><span class="comment"># get vector clock associated with each message broadcasted by id from sequence</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getVectorClockOfCreator</span>(<span class="params">sequence, <span class="built_in">id</span>, proc_num</span>):</span></span><br><span class="line">    clock = []</span><br><span class="line">    msg_clock_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(proc_num+<span class="number">1</span>):</span><br><span class="line">        clock.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> msg <span class="keyword">in</span> sequence:</span><br><span class="line">        splited = msg.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        sender = <span class="built_in">int</span>(splited[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> splited[<span class="number">0</span>]==<span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            clock[sender]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg_clock_list.append(clock.copy())</span><br><span class="line">    <span class="keyword">return</span> msg_clock_list</span><br><span class="line">    </span><br><span class="line"><span class="comment"># check if dependency of id is satisfied in all other process</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkProcessId</span>(<span class="params"><span class="built_in">id</span>, dset</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;checking process&#x27;</span>, <span class="built_in">str</span>(<span class="built_in">id</span>), <span class="string">&#x27;,depend on&#x27;</span>, dset)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># sequence of currrent process</span></span><br><span class="line">    ref_sequence = getDependentListOfCreator(<span class="built_in">id</span>, dset)</span><br><span class="line">    ref_clock = getVectorClockOfCreator(ref_sequence, <span class="built_in">id</span>, proc_num)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>,<span class="string">&#x27;#clock:&#x27;</span>,<span class="built_in">len</span>(ref_clock))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(proc_num):</span><br><span class="line">        cur_id = i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> cur_id != <span class="built_in">id</span>:</span><br><span class="line">            <span class="comment"># sequence of other process</span></span><br><span class="line">            sequence = getDependentList(cur_id, dset)</span><br><span class="line">            <span class="comment"># get vector clock</span></span><br><span class="line">            clock = getVectorClock(sequence, <span class="built_in">id</span>, proc_num)</span><br><span class="line">            <span class="built_in">print</span>(cur_id,<span class="string">&#x27;#clock:&#x27;</span>,<span class="built_in">len</span>(clock))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># number should be less of equal</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(clock)&gt;<span class="built_in">len</span>(ref_clock):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Number exceeds!&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># output should be the same with ref_sequence</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(clock)):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(proc_num+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> ref_clock[i][j] &gt; clock[i][j]:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&#x27;Clock not match!&#x27;</span>)</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&#x27;ref_clock:&#x27;</span>,ref_clock[i])</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&#x27;clock    :&#x27;</span>,clock[i])</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># check output of all processes</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkProcess</span>(<span class="params">proc_num</span>):</span></span><br><span class="line">    depend = read_config()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;dependency:&#x27;</span>,depend,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(proc_num):</span><br><span class="line">        <span class="built_in">id</span> = i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> checkProcessId(<span class="built_in">id</span>, depend[<span class="built_in">id</span>])==<span class="literal">False</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;validate process&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>),<span class="string">&#x27;OK\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line"></span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--proc_num&quot;</span>,</span><br><span class="line">        required=<span class="literal">True</span>,</span><br><span class="line">        dest=<span class="string">&quot;proc_num&quot;</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;Total number of processes&quot;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    results = parser.parse_args()</span><br><span class="line">    </span><br><span class="line">    proc_num = <span class="built_in">int</span>(results.proc_num)</span><br><span class="line">    <span class="keyword">if</span> checkProcess(proc_num):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Validation OK&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Validation failed!&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="关于dependency"><a href="#关于dependency" class="headerlink" title="关于dependency"></a>关于dependency</h1><blockquote><p>We say that a process <code>x</code> is affected by a process <code>z</code> if all the messages which process <code>z</code> broadcasts and which process <code>x</code> delivers become dependencies for all future messages broadcast by process <code>x</code>.</p></blockquote><p>个人理解是，如果</p><ul><li>p1 b 1</li><li>p2 d 1 1</li><li>p1 d 2 1</li><li>p1 d 3 1</li><li>p1 b 2<br>此时p1的dependency是[1 1 1]，p2在d 1 2时需要有这些dependency<br>加入broadcast或deliver每条消息时对应的clock</li><li>p1 b 1 [0 0 0]</li><li>p2 d 1 1 [0 0 0]</li><li>p1 d 2 1</li><li>p1 d 3 1</li><li>p1 b 2 [1 1 1]</li><li>p2 d 3 1</li><li>p2 d 2 1</li><li>p2 d 1 2 [1 1 1]<br>统计时，对reference需要统计broadcast时的clock，而其它需统计deliver时的clock</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Update&quot;&gt;&lt;a href=&quot;#Update&quot; class=&quot;headerlink&quot; title=&quot;Update&quot;&gt;&lt;/a&gt;Update&lt;/h1&gt;&lt;p&gt;‼️ Dependency bug fixed. (10/12)&lt;/p&gt;
&lt;p&gt;‼️ 不测试FIFO&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="distributed_algorithm" scheme="https://coconutnutx.github.io/tags/distributed-algorithm/"/>
    
  </entry>
  
</feed>
