<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CoCoNutNut&#39;s NoteBook</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://coconutnutx.github.io/"/>
  <updated>2022-01-12T08:56:00.000Z</updated>
  <id>https://coconutnutx.github.io/</id>
  
  <author>
    <name>coconutnut</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Obsidian使用感受</title>
    <link href="https://coconutnutx.github.io/2022/01/12/note/"/>
    <id>https://coconutnutx.github.io/2022/01/12/note/</id>
    <published>2022-01-12T08:56:00.000Z</published>
    <updated>2022-01-12T08:56:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>想要试试带关系图的双链笔记，10月开始尝试Obsidian，到现在差不多三个月，没想到已经这么多了。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2022/Obsedian2021.jpg"                                     ><p>一开始只是记了些课程笔记，蓝色是Machine Learning，粉色是Sublinear Algorithms，紫色和黄色是Distributed和Concurrent Algorithms。后来又把一些其它的、包括读书笔记都加了进来。看着整个图一点点长大、不同的部分开始有了联系，有种集卡游戏的满足感。</p><p>Obsidian+Github真是太棒了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想要试试带关系图的双链笔记，10月开始尝试Obsidian，到现在差不多三个月，没想到已经这么多了。&lt;/p&gt;
&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg
      
    
    </summary>
    
    
      <category term="Memo" scheme="https://coconutnutx.github.io/categories/Memo/"/>
    
    
      <category term="tool" scheme="https://coconutnutx.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>CA project 状态分析&amp;debug</title>
    <link href="https://coconutnutx.github.io/2021/12/16/ca-condition/"/>
    <id>https://coconutnutx.github.io/2021/12/16/ca-condition/</id>
    <published>2021-12-16T19:49:38.000Z</published>
    <updated>2021-12-16T19:49:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>上次<a href="https://coconutnutx.github.io/2021/11/28/ca-project/">CA project 思路笔记</a>分析一个位置是否可以读写的状态：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-16 PM8.49.01.jpg"                                     ><p>但是在project测试过程中发现有问题。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>按照<a class="link"   href="http://localhost:4000/2021/12/15/ca-control/" >Atomic control<i class="fas fa-external-link-alt"></i></a>的逻辑写了read_align()和write_align()。</p><p>read_align中判断Written==0时，如果没有owner、或者owner是自己，可以写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(owner==<span class="number">0</span> || owner==tr-&gt;id)&#123;</span><br><span class="line">  <span class="keyword">uint_least64_t</span> not_written = owner &lt;&lt; <span class="number">32</span> | epoch | valid;</span><br><span class="line">  <span class="keyword">if</span>(atomic_compare_exchange_strong(cur_control, &amp;not_written, written_and_is_owner))&#123;</span><br><span class="line">    <span class="comment">// write the content at source into the writable copy;</span></span><br><span class="line">    write_writable_copy(source, segment, index);</span><br><span class="line">    <span class="comment">// return the transaction can continue;</span></span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是测试时，transaction量一两千还能过，10000就过不了了。</p><p>反而↓这样可以过：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(atomic_compare_exchange_strong(cur_control, &amp;load_control, written_and_is_owner))&#123;</span><br><span class="line">  <span class="comment">// write the content at source into the writable copy;</span></span><br><span class="line">  write_writable_copy(source, segment, index);</span><br><span class="line">  <span class="comment">// return the transaction can continue;</span></span><br><span class="line">  flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是它并不符合原本的思路，因为可能会将第一个读成功的owner覆盖。就很奇怪。</p><h1 id="重读"><a href="#重读" class="headerlink" title="重读"></a>重读</h1><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-16 PM8.58.31.jpg"                      width=600                ><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-16 PM8.59.01.jpg"                      width=600                ><p>感觉会有问题的很可能是access set，上次分析只用记录第一个读或写成功的id，但是为什么实际中即使写覆盖了读也可以成功呢？</p><p>假设在某一个align，tr1、tr2读了旧值，此时如果tr3写了新值，tr1、tr2以及任何除tr3以外的transaction都不能再读。也就是说，写过的位置，只有写者可读。这其实是符合read_word()伪代码的。并且，如果tr1、tr2后面不再读这个值，可以提交并linearize到tr3开始之前；反之，如果它们后面还要读这个值，就会读失败，进而被abort。所以也是符合linearizable的。</p><p>难道access set只用记录第一个写成功的？上次跟TA确认了一下，access set只用记一个id，似乎确实没仔细问是第一个读成功、还是写成功。</p><p>那么按照新的逻辑分析，第一个读或写成功，还是都记入owner，只不过读成功的owner可以被覆盖。</p><p>可如果能够覆盖，read owner和other还有什么用呢？（其实现在这版代码里面也压根没用到other）如果直接把read_align中设置owner和other的代码注释掉，还能跑吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">⎪ #worker threads:     4</span><br><span class="line">⎪ #TX per worker:      10000</span><br><span class="line">⎪ #repetitions:        7</span><br><span class="line">⎪ Initial #accounts:   128</span><br><span class="line">⎪ Expected #accounts:  1024</span><br></pre></td></tr></table></figure><p>…用↑参数测了几次，多数能过，少数Violated isolation or atomicity。也就是说other还是有用的。</p><p>再看下project description中对access set的描述：</p><blockquote><p>The “access set” of read-write transaction(s) which have accessed the word in the current epoch. Do not implement an actual set in any (optimized) implementation: this set will only be used to tell whether a transaction can write to the word. Namely, if at least one other transaction has accessed (i.e. read or written) this word in the same epoch, the write cannot happen. Said differently, if two transactions are in the access set, it doesn’t matter which one they are.</p></blockquote><p>现在迷惑的点就是：</p><ol><li>如果有另一个transaction也访问过，还能不能写？</li><li>现在的代码里到底判断了other没？</li></ol><p>2应该是没有的，加个输出可以发现，即使有other还是有时写成功了。那为什么可以过呢？难道是意外？多测几次还真偶尔有Violated isolation or atomicity！</p><p>好吧，虽然project又变成了未完成状态，但至少没有逻辑错的代码能跑对、逻辑(以为)对的代码跑不通的尴尬情况了。</p><p>那么接下来的问题就是，为什么逻辑(以为)对的代码跑不通？更准确的是，为什么在transaction量较大时跑不通？</p><h1 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h1><h2 id="CAS-fail-when-equal"><a href="#CAS-fail-when-equal" class="headerlink" title="CAS fail when equal"></a>CAS fail when equal</h2><p>打印了一些tm_begin和tm_end的信息，发现当transaction进行了很多、id很大之后，只有tm_begin没有tm_end了，也就是说后面的都没有commit。并且都是一些read/write transaction，它们的write都没有成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[304850 write align] seg_id=8 index=1 flag=0</span><br><span class="line">[304851 tm_begin] is_ro=0</span><br><span class="line">[304821 write align] seg_id=8 index=1 flag=0</span><br><span class="line">[304852 tm_begin] is_ro=0</span><br><span class="line">[304833 write align] seg_id=8 index=1 flag=0</span><br><span class="line">[304853 tm_begin] is_ro=0</span><br><span class="line">[304836 write align] seg_id=8 index=1 flag=0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>发现有一个CAS中，明明expected值和control中的值是一样的，但是没有换成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atomic_compare_exchange_strong(cur_control, &amp;not_written, written_and_is_owner)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">not_written=5e0cb00000005 load_control=5e0cb00000005 cur_control=5e0cb00000005 equal=1</span><br></pre></td></tr></table></figure><p>这可就太离谱了！</p><blockquote><p><a class="link"   href="https://stackoverflow.com/questions/35534305/compare-exchange-strong-failing-despite-data-matching-expected-value" >compare_exchange_strong failing despite data matching expected value<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://stackoverflow.com/questions/66566810/why-does-compare-exchange-strong-fail-with-stdatomicdouble-stdatomicfloa" >Why does compare_exchange_strong fail with std::atomic, std::atomic in C++?<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>可能是由padding导致的。这就很尴尬了。</p><h3 id="尝试1"><a href="#尝试1" class="headerlink" title="尝试1"></a>尝试1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint_least64_t not_written = owner &lt;&lt; 32 | valid;</span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint_least64_t not_written = load_control &amp; 0xFFFFFFFFFFFFFFF9;</span><br></pre></td></tr></table></figure><p>不行</p><h3 id="尝试2"><a href="#尝试2" class="headerlink" title="尝试2"></a>尝试2</h3><p>这是真的很离谱啊！打印出来的判断就是相等啊！这换不了能怎么办啊？？？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;DEBUG4 not_written=%lx load_control=%lx cur_control=%lx equal=%d test=%d\n&quot;</span>, not_written, load_control, load, not_written==load, atomic_load(cur_control)==not_written);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DEBUG4 not_written=3e1a300000005 load_control=3e1a300000005 cur_control=3e1a300000005 equal=1 test=1</span><br><span class="line">[254371 write align] seg_id=8 index=1 flag=0 cond=4</span><br><span class="line">[254373 tm_begin] is_ro=0</span><br><span class="line">DEBUG4 not_written=3e1a400000005 load_control=3e1a400000005 cur_control=3e1a400000005 equal=1 test=1</span><br><span class="line">[254372 write align] seg_id=8 index=1 flag=0 cond=4</span><br><span class="line">[254374 tm_begin] is_ro=0</span><br><span class="line">DEBUG4 not_written=3e1a500000005 load_control=3e1a500000005 cur_control=3e1a500000005 equal=1 test=1</span><br></pre></td></tr></table></figure><p>难道是uint_least64_t的问题？它和memcpy的比较方法不一样？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_t a = (size_t)not_written;</span><br></pre></td></tr></table></figure><p>强制转成size_t然后比就好了？？？那之前担心位数不对，还特地搞个uint_least64_t，简直是离了个大谱。</p><h2 id="too-long"><a href="#too-long" class="headerlink" title="too long"></a>too long</h2><p>改好上面这个离谱的bug之后，当transaction太多还是会跑不完。打印输出看还是write_align不成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[370371 tm_begin] is_ro=0</span><br><span class="line">[370371 write align] seg_id=8 index=1 flag=0 cond=4 lc=5a6c300000005, cc=5a6c300000005</span><br><span class="line">[370372 tm_begin] is_ro=0</span><br><span class="line">[370372 write align] seg_id=8 index=1 flag=0 cond=4 lc=5a6c400000005, cc=5a6c400000005</span><br><span class="line">[370373 tm_begin] is_ro=0</span><br><span class="line">[370373 write align] seg_id=8 index=1 flag=0 cond=4 lc=5a6c500000005, cc=5a6c500000005</span><br><span class="line">[370374 tm_begin] is_ro=0</span><br><span class="line">[370374 write align] seg_id=8 index=1 flag=0 cond=4 lc=5a6c600000005, cc=5a6c600000005</span><br><span class="line">[370375 tm_begin] is_ro=0</span><br><span class="line">[370375 write align] seg_id=8 index=1 flag=0 cond=4 lc=5a6c700000005, cc=5a6c700000005</span><br></pre></td></tr></table></figure><p>全部都是有other read冲突</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[215647 read align] seg_id=7 index=0 lc=0 cc=34a5f00000000</span><br><span class="line">[215647 read align] seg_id=7 index=1 lc=1 cc=34a5f00000001</span><br><span class="line">[215647 read align] seg_id=8 index=0 lc=0 cc=34a5f00000000</span><br><span class="line">[215647 read align] seg_id=8 index=1 lc=1 cc=34a5f00000001</span><br><span class="line">[215647 read align] seg_id=9 index=0 lc=1 cc=34a5f00000001</span><br><span class="line">[215647 read align] seg_id=9 index=1 lc=0 cc=34a5f00000000</span><br><span class="line">[215647 read align] seg_id=9 index=2 lc=0 cc=34a5f00000000</span><br><span class="line">[215647 read align] seg_id=9 index=3 lc=1 cc=34a5f00000001</span><br><span class="line">[215647 read align] seg_id=8 index=1 lc=34a5f00000001 cc=34a5f00000005</span><br></pre></td></tr></table></figure><p>发现一个逻辑错误，owner是自己时仍设了other。</p><p>这下算是修了一个逻辑上的大bug，再上服务器测测。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-16 PM10.51.17.jpg"                      width=600                ><p>成功！虽然没有变快，但至少逻辑上合理了，不像之前那么虚了。</p><hr><p>所以之前那么大一个bug是怎么过的测试啊就离谱，今天真是满头问号。而且之前逻辑都没对就写优化，那可不是写了个寂寞。幸亏优化的思路现在是很清晰了，毕竟revert、重写都搞了好几遍了。虽然不知道这些优化到底能不能正向优化，但还是想试试，就是很好奇，而且毕竟都花了这么多时间了。</p><p>顺便把<a href="https://coconutnutx.github.io/2021/12/15/ca-control/">Atomic control</a>更新一下。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>reference的逻辑还是很正确的</li><li>bug确实是自己写的bug</li><li>除了c的atomic_compare_exchange_strong，值较大时，期望值和实际值一样但换不成功，是真的离谱</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上次&lt;a href=&quot;https://coconutnutx.github.io/2021/11/28/ca-project/&quot;&gt;CA project 思路笔记&lt;/a&gt;分析一个位置是否可以读写的状态：&lt;/p&gt;
&lt;img  
                     lazy
      
    
    </summary>
    
    
      <category term="Debug" scheme="https://coconutnutx.github.io/categories/Debug/"/>
    
    
      <category term="concurrent_algorithm" scheme="https://coconutnutx.github.io/tags/concurrent-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>CA project Atomic control</title>
    <link href="https://coconutnutx.github.io/2021/12/15/ca-control/"/>
    <id>https://coconutnutx.github.io/2021/12/15/ca-control/</id>
    <published>2021-12-15T16:37:29.000Z</published>
    <updated>2021-12-15T16:37:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>Project中为了标识transactional memory中每一个align的状态，需要一个control structure，这里用了一个64bit的atomic interger来存这些信息。</p><p>通过一次CAS完成对状态的判断和修改，避免加锁。</p><h1 id="Control设计"><a href="#Control设计" class="headerlink" title="Control设计"></a>Control设计</h1><table><thead><tr><th>占用bit</th><th>32</th><th>20</th><th>9</th><th>1</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>名称</td><td>Owner</td><td>Epoch</td><td>留空</td><td>Other</td><td>Written</td><td>Valid</td></tr><tr><td>描述</td><td>本轮第一个read或write成功的transaction的id</td><td>当前轮数</td><td></td><td>是否有其它transaction访问</td><td>是否被写</td><td>A或B哪个有效</td></tr></tbody></table><h1 id="Control-masks"><a href="#Control-masks" class="headerlink" title="Control masks"></a>Control masks</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> VALID_MASK = <span class="number">0x1</span>;         <span class="comment">// 0: A is valid    1: B is valid</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> WRITE_MASK = <span class="number">0x1</span> &lt;&lt; <span class="number">1</span>;    <span class="comment">// 0: not written   1: written</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> OTHER_MASK = <span class="number">0x1</span> &lt;&lt; <span class="number">2</span>;    <span class="comment">// 0: no other read 1: has other read</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> EPOCH_MASK = <span class="number">0xFFFFF000</span>;</span><br></pre></td></tr></table></figure><h1 id="Control-macros"><a href="#Control-macros" class="headerlink" title="Control macros"></a>Control macros</h1><p>有时需要直接读atomic interger。其他时候，先读一次，然后直接对读到的值进行操作，可以减少atomic_load()次数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_FLAG_SIGN(control, flag) ((atomic_load(control) &amp; flag) != 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_FLAG_SIGN_LOADED(load_control, flag) ((load_control &amp; flag) != 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_FLAG_LOADED(load_control, flag) (load_control &amp; flag)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_EPOCH_LOADED(load_control) (load_control &amp; EPOCH_FLAG)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_OWNER(control) ((atomic_load(control)) &gt;&gt; 32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_OWNER_LOADED(load_control) (load_control &gt;&gt; 32)</span></span><br></pre></td></tr></table></figure><h1 id="read-align逻辑"><a href="#read-align逻辑" class="headerlink" title="read_align逻辑"></a>read_align逻辑</h1><ol><li><p>If 已经被写过，只有owner可以读（且Other应该为空，因为Other和Written不肯能同时为1）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expected: Owner==id; Epoch==epoch; Other==0; Written==1; Valid==valid</span><br></pre></td></tr></table></figure></li><li><p>If 没有被写过</p><ol><li><p>If owner==0，尝试抢占（可能会出现竞争而失败）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expected: Owner==0;  Epoch==epoch; Other==0; Written==0; Valid==valid</span><br><span class="line">Desired:  Owner==id; Epoch==epoch; Other==0; Written==0; Valid==valid</span><br></pre></td></tr></table></figure></li><li><p>Else if owner==自己，直接读（owner不会被修改，也只有自己可能写）</p></li><li><p>Else if owner==别人</p><ol><li><p>If 尝试设Other</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expected: Owner==owner; Epoch==epoch; Other==0; Written==0; Valid==valid</span><br><span class="line">Desired:  Owner==owner; Epoch==epoch; Other==1; Written==0; Valid==valid</span><br></pre></td></tr></table></figure></li><li><p>Else if 读到已经被设了Other</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expected: Owner==owner; Epoch==epoch; Other==1; Written==0; Valid==valid</span><br></pre></td></tr></table></figure><p>如果读到Other为1，owner也不能再写这个align了，所以可以放心读。</p></li></ol></li></ol></li></ol><h1 id="write-align逻辑"><a href="#write-align逻辑" class="headerlink" title="write_align逻辑"></a>write_align逻辑</h1><ol><li><p>If 已经被写过，只有owner可以写，且不能有other</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expected: Owner==id; Epoch==epoch; Other==0; Written==1; Valid==valid</span><br></pre></td></tr></table></figure></li><li><p>If 没有被写过</p><ol><li><p>已经是owner可以写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expected: Owner==id; Epoch==epoch; Other==0; Written==0; Valid==valid</span><br><span class="line">Desired:  Owner==id; Epoch==epoch; Other==0; Written==1; Valid==valid</span><br></pre></td></tr></table></figure></li><li><p>抢到owner可以写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expected: Owner==0;  Epoch==epoch; Other==0; Written==0; Valid==valid</span><br><span class="line">Desired:  Owner==id; Epoch==epoch; Other==0; Written==1; Valid==valid</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>Note：如果写成功了，本轮中control的值将不会再发生改变</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Project中为了标识transactional memory中每一个align的状态，需要一个control structure，这里用了一个64bit的atomic interger来存这些信息。&lt;/p&gt;
&lt;p&gt;通过一次CAS完成对状态的判断和修改，避免加锁。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="concurrent_algorithm" scheme="https://coconutnutx.github.io/tags/concurrent-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>CA project 常用操作</title>
    <link href="https://coconutnutx.github.io/2021/12/12/ca-project/"/>
    <id>https://coconutnutx.github.io/2021/12/12/ca-project/</id>
    <published>2021-12-12T22:42:37.000Z</published>
    <updated>2021-12-12T22:42:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>很久没用C了，还有一些同步相关的操作，记录一下。</p><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>分配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">region</span>* <span class="title">region</span> =</span> (struct region*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct region));</span><br><span class="line"><span class="keyword">if</span> (unlikely(!region)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分配（且内存按align排列）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (posix_memalign(&amp;(region-&gt;start), align, size) != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">free</span>(region);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填零</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(region-&gt;start, <span class="number">0</span>, size);</span><br></pre></td></tr></table></figure><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>填值&amp;取值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define index</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> align;</span><br><span class="line">    <span class="keyword">uint8_t</span>* index;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// init index</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;cnt; i++)&#123;</span><br><span class="line">  <span class="keyword">size_t</span>* p = (<span class="keyword">size_t</span>*)(segment-&gt;index + i*align);</span><br><span class="line">  *p = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get index</span></span><br><span class="line"><span class="keyword">size_t</span> index = *(<span class="keyword">size_t</span>*)(address)</span><br></pre></td></tr></table></figure><p>🌰</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find segment and index</span></span><br><span class="line"><span class="keyword">size_t</span> index = *(<span class="keyword">size_t</span>*)(address);</span><br><span class="line"><span class="keyword">size_t</span> offset = index * region-&gt;align + <span class="keyword">sizeof</span>(struct segment);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment</span>* <span class="title">segment</span> =</span> (struct segment*)((<span class="keyword">uint8_t</span>*)address - offset);</span><br></pre></td></tr></table></figure><p>指针的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>** p_addr;</span><br><span class="line">    <span class="keyword">size_t</span>* p_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set</span></span><br><span class="line">*(s-&gt;p_addr + index) = address;    <span class="comment">// void* address</span></span><br><span class="line">*(s-&gt;p_num + index) = size;        <span class="comment">// size_t size</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get</span></span><br><span class="line"><span class="keyword">void</span>* addr = *(p_addr + i);</span><br><span class="line"><span class="keyword">size_t</span> size = *(p_num + i);</span><br></pre></td></tr></table></figure><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>设置mask</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> MASK = <span class="number">0x0001</span> &lt;&lt; <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>获取mask下的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_FLAG(control, mask) ((atomic_load(control) &amp; mask) != 0)</span></span><br></pre></td></tr></table></figure><p>设置高位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control |= id &lt;&lt; <span class="number">32</span>;</span><br></pre></td></tr></table></figure><p>获取高位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint_least64_t</span> id = control &gt;&gt; <span class="number">32</span>;</span><br></pre></td></tr></table></figure><h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h1><h2 id="锁和条件变量"><a href="#锁和条件变量" class="headerlink" title="锁和条件变量"></a>锁和条件变量</h2><blockquote><p>reference “lock.h” “lock.c”</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lock_init</span><span class="params">(struct <span class="keyword">lock_t</span>* lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pthread_mutex_init(&amp;(lock-&gt;mutex), <span class="literal">NULL</span>) == <span class="number">0</span></span><br><span class="line">        &amp;&amp; pthread_cond_init(&amp;(lock-&gt;cv), <span class="literal">NULL</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_cleanup</span><span class="params">(struct <span class="keyword">lock_t</span>* lock)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_destroy(&amp;(lock-&gt;mutex));</span><br><span class="line">    pthread_cond_destroy(&amp;(lock-&gt;cv));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lock_acquire</span><span class="params">(struct <span class="keyword">lock_t</span>* lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pthread_mutex_lock(&amp;(lock-&gt;mutex)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_release</span><span class="params">(struct <span class="keyword">lock_t</span>* lock)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_unlock(&amp;(lock-&gt;mutex));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_wait</span><span class="params">(struct <span class="keyword">lock_t</span>* lock)</span> </span>&#123;</span><br><span class="line">    pthread_cond_wait(&amp;(lock-&gt;cv), &amp;(lock-&gt;mutex));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_wake_up</span><span class="params">(struct <span class="keyword">lock_t</span>* lock)</span> </span>&#123;</span><br><span class="line">    pthread_cond_broadcast(&amp;(lock-&gt;cv));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h2><p><a class="link"   href="https://en.cppreference.com/w/c/atomic/atomic_load" >atomic_load<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://en.cppreference.com/w/cpp/atomic/atomic_store" >atomic_store<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://en.cppreference.com/w/c/atomic/atomic_fetch_add" >atomic_fetch_add<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://en.cppreference.com/w/c/atomic/atomic_compare_exchange" >atomic_compare_exchange<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很久没用C了，还有一些同步相关的操作，记录一下。&lt;/p&gt;
&lt;h1 id=&quot;内存&quot;&gt;&lt;a href=&quot;#内存&quot; class=&quot;headerlink&quot; title=&quot;内存&quot;&gt;&lt;/a&gt;内存&lt;/h1&gt;&lt;p&gt;分配&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;ta
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="concurrent_algorithm" scheme="https://coconutnutx.github.io/tags/concurrent-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>关于Localized Causal Broadcast</title>
    <link href="https://coconutnutx.github.io/2021/12/09/lcb/"/>
    <id>https://coconutnutx.github.io/2021/12/09/lcb/</id>
    <published>2021-12-09T12:33:01.000Z</published>
    <updated>2021-12-09T12:33:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>DA project submission #2 要求实现Localized Causal Broadcast，具体的定义在project repo的README中</p><blockquote><ul><li>You must implement this on top of uniform reliable broadcast (URB).</li><li>The <code>CONFIG</code> command-line argument for this algorithm consists of a file that contains an integer <code>m</code> in its first line. <code>m</code> defines how many messages each process should broadcast.</li><li>For a system of <code>n</code> processes, there are <code>n</code> more lines in the <code>CONFIG</code> file. Each line <code>i</code> corresponds to process <code>i</code>, and such a line indicates the identities of other processes which can affect process <code>i</code>. See the example below.<ul><li>The FIFO property still needs to be maintained by localized causal broadcast. That is, messages broadcast by the same process must not be delivered in a different order then they were broadcast.</li><li>The output format for localized causal broadcast remains the same as before.<br>Example of <code>CONFIG</code> file for a system of <code>5</code> processes, where each one broadcasts <code>m</code> messages:</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m</span><br><span class="line">1 4 5</span><br><span class="line">2 1</span><br><span class="line">3 1 2</span><br><span class="line">4</span><br><span class="line">5 3 4</span><br></pre></td></tr></table></figure><p><em>Note</em>: Lines should end in <code>\n</code>, and numbers are separated by white-space characters.</p><p>In this example we specify that process <code>1</code> is affected by messages broadcast by processes <code>4</code> and <code>5</code>. Similarly, we specify that process <code>2</code> is only affected by process <code>1</code>. Process <code>4</code> is not affected by any other processes. Process <code>5</code> is affected by processes <code>3</code> and <code>4</code>.</p><p>We say that a process <code>x</code> is affected by a process <code>z</code> if all the messages which process <code>z</code> broadcasts and which process <code>x</code> delivers become dependencies for all future messages broadcast by process <code>x</code>. We call these dependencies <em>localized</em>. If a process is not affected by any other process, messages it broadcasts only depend on its previously broadcast messages (due to the FIFO property).</p><p><em>Note</em>:  In the default causal broadcast (this algorithm will be discussed in one of the lectures) each process affects <code>all</code> processes. In this algorithm we can selectively define which process affects some other process.</p></blockquote><h1 id="关于dependency"><a href="#关于dependency" class="headerlink" title="关于dependency"></a>关于dependency</h1><p>process is affected by other processes，但消息的dependency是对每一条消息而言的。</p><p>（当用书上的vector clock方法实现时）也就是说，每一条LCB层消息在broadcast的时间点，需要拿到这个时间点、当前进程的vector clock，作为自己的dependency clock。可以作为消息内容传给其它process。</p><p>其它process收到消息，判断能否deliver，即判断自己的vector clock是否大于消息的dependency clock。</p><h1 id="关于FIFO"><a href="#关于FIFO" class="headerlink" title="关于FIFO"></a>关于FIFO</h1><p>根据sequence number可以保证FIFO。</p><p>基于vector clock也可以保证FIFO。</p><p>对于其它进程，都是在deliver消息时，增加该进程对应的vector clock值。</p><p>对于当前进程，可以做一些调整，在broadcast消息时就修改对应的vector clock值。</p><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># in process 1</span><br><span class="line">b 1 [0 . .]</span><br><span class="line">b 2 [1 . .]</span><br></pre></td></tr></table></figure><p>那么其它进程收到2时，必须先deliver 1。</p><p>可以保证当前进程广播的每一条消息，都有不同的vector clock（即使当前进程没有affected by任何进程），从而保证FIFO。</p><p>这样在deliver的时候，可以统一处理vector clock，而不用管sequence number。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;DA project submission #2 要求实现Localized Causal Broadcast，具体的定义在project repo的README中&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;You must implement this on t
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="distributed_algorithm" scheme="https://coconutnutx.github.io/tags/distributed-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>CA project debug记录</title>
    <link href="https://coconutnutx.github.io/2021/12/06/ca-debug/"/>
    <id>https://coconutnutx.github.io/2021/12/06/ca-debug/</id>
    <published>2021-12-06T10:09:23.000Z</published>
    <updated>2021-12-06T10:09:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="惨痛经验"><a href="#惨痛经验" class="headerlink" title="惨痛经验"></a>惨痛经验</h1><h2 id="Start-easy"><a href="#Start-easy" class="headerlink" title="Start easy"></a>Start easy</h2><p>第一步，加锁，把Transactional Memory的功能写对。</p><ul><li>测试报错Transactional library takes too long to process the transactions，是功能就不对，和线程数量、transaction数量、print没什么关系。</li><li>要把这个报错的阈值调大，修改grading里的slow_factor即可。刚开始可以直接改到1024。</li></ul><p>先不要写什么优化，把基础功能写对，否则debug直接de到吐血</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><ol><li>read_word()和write_write()虽然是照着project desciption写，但还是很容易出错，要很很很小心！</li><li>free的时机需要注意，有时候free后再读并不是一眼就能看出来，bug藏得比较隐蔽。</li></ol><h2 id="Debug-Segmentation-fault"><a href="#Debug-Segmentation-fault" class="headerlink" title="Debug Segmentation fault"></a>Debug Segmentation fault</h2><p>Segmentation fault常用debug操作：core dump（虚拟机环境不同，流程可能不一样，这里用了和DA project一样的ubuntu，最大的坑是找不到core）</p><ol><li><p>设置</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited</span><br><span class="line">ulimit -a</span><br></pre></td></tr></table></figure></li><li><p>run</p></li><li><p>找到core文件</p><blockquote><p><a class="link"   href="https://askubuntu.com/questions/966407/where-do-i-find-the-core-dump-in-ubuntu-16-04lts" >Where do I find the core dump in ubuntu 16.04LTS?<i class="fas fa-external-link-alt"></i></a></p></blockquote></li><li><p>设权限</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /var/lib/apport/</span><br><span class="line">sudo chmod 777 coredump/</span><br></pre></td></tr></table></figure></li><li><p>core移动到grading文件夹</p></li><li><p>debug</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb grading core</span><br></pre></td></tr></table></figure><p> gdb中常用</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where</span><br></pre></td></tr></table></figure></li></ol><hr><p>除了以上悲伤的故事，也有一些可喜可贺的习惯，给debug带了了巨大帮助，要继续保持：</p><ol><li>每一部分debug输出用参数控制，可以很方便的开关。</li><li>经常commit。避免debug变成写bug时，回退都无处可退。</li></ol><hr><p>备注：下文所有TM指的是Transactional Memory，不是口吐芬芳。</p><h1 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h1><p>写完read、write等基础操作，先加了个全局锁，放到虚拟机里测一下逻辑。</p><h2 id="atomic-load时segmentation-fault"><a href="#atomic-load时segmentation-fault" class="headerlink" title="atomic_load时segmentation fault"></a>atomic_load时segmentation fault</h2><p>本地跑没问题，但是虚拟机里make build-libs run就Segmentation fault。一番折腾后，定位到是atomic interger的问题。用atomic_store或者atomic_load的时候就会报错。</p><h3 id="尝试1"><a href="#尝试1" class="headerlink" title="尝试1"></a>尝试1</h3><p>在计算control structure的偏移量时，第一个segment没转(void*)，于是取地址出了问题，atomic_load时就崩了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">void</span>*)segment+segment-&gt;offset_control+CONTROL_SIZE*index</span><br></pre></td></tr></table></figure><p>改成这样本地跑又取不到了，就离谱</p><h3 id="尝试2（结构体指针）"><a href="#尝试2（结构体指针）" class="headerlink" title="尝试2（结构体指针）"></a>尝试2（结构体指针）</h3><p>怀疑是结构体指针的问题，打印了一下相关的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct segment* segment;</span><br><span class="line"></span><br><span class="line">DEBUG segment=0x7fb229405a30</span><br><span class="line">DEBUG (uint8_t*)segment=0x7fb229405a30</span><br><span class="line">DEBUG (void*)segment=0x7fb229405a30</span><br><span class="line">DEBUG &amp;segment=0x7ffedfedf530</span><br></pre></td></tr></table></figure><p>前三个是一样的，符合预期。那么计算偏移量的时候是否也一样？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DEBUG offset=208</span><br><span class="line"></span><br><span class="line">DEBUG segment+offset=0x7fb22940b530</span><br><span class="line">DEBUG (uint8_t*)segment+offset=0x7fb229405b00</span><br><span class="line">DEBUG (void*)segment+offset=0x7fb229405b00</span><br></pre></td></tr></table></figure><p>这里算出来就不一样了</p><p>b530-5a30 = 0x5b00 = 23296 = 208 * 112<br>而112正好是struct segment的大小，所以不转换直接加，单位是struct size</p><p>5b00-5a30 = 0xd0 = 208<br>这样就是对的，所以应该先转换指针类型</p><p>那么尝试1加了(void*)应该方向是对的</p><h2 id="control修改错误"><a href="#control修改错误" class="headerlink" title="control修改错误"></a>control修改错误</h2><p>接上一个bug，改完之后，发现set control owner出现问题，没有set成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[owner=0 v=0 w=0 s=0]</span><br></pre></td></tr></table></figure><p>写内存成功了，在函数内部打印control也是对的，但是结束之后整体print region时，control是空的</p><p>解决：<br>打印发现两次用control时地址不一样。是后面算control起始地址没有改过来，仍是直接算的，没有用定义的宏</p><p>改过来之后顺便检查了一遍，所有计算control地址的位置，都是用宏</p><h2 id="batch间reset-control后segmentation-fault"><a href="#batch间reset-control后segmentation-fault" class="headerlink" title="batch间reset control后segmentation fault"></a>batch间reset control后segmentation fault</h2><p>目前本地测试一轮中的transaction没什么问题，但是tm_end()、调用batcher_cleanup()之后，打印region出错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--------segment1--------</span><br><span class="line">[0] 00000000 | 11111111 [owner=0 v=1 w=0 s=0]</span><br><span class="line">[1] 00000000 | 11111111 [owner=0 v=1 w=0 s=0]</span><br><span class="line">[2] 00000000 | 22222222 [owner=0 v=1 w=0 s=0]</span><br><span class="line">[3] 00000000 | 22222222 [owner=0 v=1 w=0 s=0]</span><br><span class="line">--------segment0--------</span><br><span class="line">zsh: segmentation fault  ./tm.o</span><br></pre></td></tr></table></figure><p>应该是segment2，而不是0</p><h3 id="尝试1-1"><a href="#尝试1-1" class="headerlink" title="尝试1"></a>尝试1</h3><p>在batch_cleanup()中打印了一下segment id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(segment)&#123;</span><br><span class="line">        clean_up_segment(segment);</span><br><span class="line">        segment = segment-&gt;next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>发现第二次是0<br>可能是segment指针的问题<br>但是print_region()里面也有这个循环，没有问题，那边是这样写的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(segment != NULL)&#123;</span><br><span class="line">        print_segment(segment);</span><br><span class="line">        segment = segment-&gt;next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总不能是!=NULL的问题吧<br>试了一下，果然不是</p><h3 id="尝试2"><a href="#尝试2" class="headerlink" title="尝试2"></a>尝试2</h3><p>在batcher_cleanup()的循环里加了强制类型转换，好了一次，再测又不行了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">segment = (struct segment*)(segment-&gt;next);</span><br></pre></td></tr></table></figure><h3 id="尝试3（内存分配）"><a href="#尝试3（内存分配）" class="headerlink" title="尝试3（内存分配）"></a>尝试3（内存分配）</h3><p>打印region和segment的地址都是对的，但是为什么读出来东西就不对呢？</p><p>仔细看了下两块segment的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--------segment1-------- addr=0x7f9bc9c05a30</span><br><span class="line">[0] 00000000 | 11111111 [owner=1 v=0 w=1 s=1]</span><br><span class="line">[1] 00000000 | 11111111 [owner=1 v=0 w=1 s=1]</span><br><span class="line">[2] 00000000 | 22222222 [owner=1 v=0 w=1 s=1]</span><br><span class="line">[3] 00000000 | 22222222 [owner=1 v=0 w=1 s=1]</span><br><span class="line">--------segment2-------- addr=0x7f9bc9c05b30</span><br></pre></td></tr></table></figure><p>a30和b30这才隔了256，肯定会撞吧！难道是一开始分配就有问题？</p><p>初始化时的代码是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment</span>* <span class="title">segment</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> total_size = <span class="keyword">sizeof</span>(struct segment) + size*<span class="number">3</span> + size/align*<span class="keyword">sizeof</span>(<span class="keyword">atomic_uint_least64_t</span>);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(posix_memalign((<span class="keyword">void</span>**)&amp;segment, align, total_size) != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create_segment failed. cannot align memory.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看了下reference代码，先malloc的region，后面才posix_memalign的segment</p><p>改成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> total_size = <span class="keyword">sizeof</span>(struct segment) + size*<span class="number">3</span> + size/align*<span class="keyword">sizeof</span>(<span class="keyword">atomic_uint_least64_t</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">segment</span>* <span class="title">segment</span> =</span> (struct segment*) <span class="built_in">malloc</span>(total_size);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(posix_memalign((<span class="keyword">void</span>**)&amp;segment, align, total_size) != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create_segment failed. cannot align memory.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 成功！</p><p> 现在的地址是<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--------segment1-------- addr=0x7fde98405b20</span><br><span class="line">[0] 00000000 | 11111111 [owner=0 v=1 w=0 s=0]</span><br><span class="line">[1] 00000000 | 11111111 [owner=0 v=1 w=0 s=0]</span><br><span class="line">[2] 00000000 | 22222222 [owner=0 v=1 w=0 s=0]</span><br><span class="line">[3] 00000000 | 22222222 [owner=0 v=1 w=0 s=0]</span><br><span class="line">--------segment2-------- addr=0x7fde98405d10</span><br><span class="line">[0] 00000000 | 00000000 [owner=0 v=0 w=0 s=0]</span><br><span class="line">[1] 00000000 | 00000000 [owner=0 v=0 w=0 s=0]</span><br><span class="line">[2] 00000000 | 00000000 [owner=0 v=0 w=0 s=0]</span><br><span class="line">[3] 00000000 | 00000000 [owner=0 v=0 w=0 s=0]</span><br></pre></td></tr></table></figure><br>d10-b20 = 0x1f0 = 496</p><h2 id="阶段一测试"><a href="#阶段一测试" class="headerlink" title="阶段一测试"></a>阶段一测试</h2><p>丢进虚拟机跑grading<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-06 PM11.54.31.jpg"                      width=600                ><br>用时太久，正常。但是没有segmentation fault了，应该read write操作也没什么问题了，第一步完成！耶！</p><p>停掉了一些print，减少不必要的时间浪费，测TM相关函数</p><h2 id="malloc错误"><a href="#malloc错误" class="headerlink" title="malloc错误"></a>malloc错误</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[batcher_cleanup] region addr=0x7f1bc8000b20</span><br><span class="line">[batcher_cleanup] clean segment 1, addr=0x7f1bc8001530</span><br><span class="line">grading: malloc.c:2401: sysmalloc: Assertion `(old_top == initial_top (av) &amp;&amp; old_size == 0) || ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp; prev_inuse (old_top) &amp;&amp; ((unsigned long) old_end &amp; (pagesize - 1)) == 0)&#x27; failed.</span><br><span class="line">Makefile:40: recipe for target &#x27;run&#x27; failed</span><br></pre></td></tr></table></figure><p>像是个和内存分配有关的bug</p><blockquote><p>Why do I get a C malloc assertion failure?<br>检查clean_up_segment里的循环</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;segment-&gt;size; i++)</span><br></pre></td></tr></table></figure><p>终止条件写成了segment-&gt;size，应该是size/align<br>解决！</p><h2 id="时间太长"><a href="#时间太长" class="headerlink" title="时间太长"></a>时间太长</h2><p>现在grading输出是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[write]tx_id=1 seg_id=1 index=63 size=8</span><br><span class="line">[write]tx_id=1 seg_id=1 index=64 size=8</span><br><span class="line">[write]tx_id=1 seg_id=1 index=65 size=8</span><br><span class="line">[write]tx_id=1 seg_id=1 index=66 size=8</span><br><span class="line">[tm_end] id=1</span><br><span class="line"></span><br><span class="line">[batcher_cleanup]region addr=0x7f3a18000b20</span><br><span class="line">transaction created. id=2 addr=0x7f3a18001e30</span><br><span class="line">[read]tx_id=2 seg_id=1 index=3 size=8</span><br><span class="line">⎪ *** EXCEPTION ***</span><br><span class="line">⎩ Transactional library takes too long to process the transactions</span><br></pre></td></tr></table></figure><p>可能是用时太长，也可能是read有问题，先检查后者</p><p>单独打了一下read的输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[read align]tx_id=2 seg_id=1 index=64</span><br><span class="line">[read align]tx_id=2 seg_id=1 index=65</span><br><span class="line">[read align]tx_id=2 seg_id=1 index=66</span><br><span class="line">⎪ *** EXCEPTION ***</span><br><span class="line">⎩ Transactional library takes too long to process the transactions</span><br></pre></td></tr></table></figure><p>可以跑，那应该就是用时太长的问题，而不是逻辑问题<br>那么接下来就可以开始改并发相关的代码了</p><h1 id="虚假的阶段二"><a href="#虚假的阶段二" class="headerlink" title="虚假的阶段二"></a>虚假的阶段二</h1><p>前面基本测试了TM的read、write、alloc功能，现在把全局锁换成batcher</p><h2 id="时间太长-1"><a href="#时间太长-1" class="headerlink" title="时间太长"></a>时间太长</h2><p>现在的问题是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">⎪ *** EXCEPTION ***</span><br><span class="line">⎩ Transactional library takes too long to process the transactions</span><br><span class="line">Makefile:40: recipe for target &#x27;run&#x27; failed</span><br></pre></td></tr></table></figure><h3 id="尝试1-2"><a href="#尝试1-2" class="headerlink" title="尝试1"></a>尝试1</h3><p>把参数调小了还是很慢<br>看了下具体输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">transaction created. id=32 addr=0x7f35dc00d3d0 log_size=100</span><br><span class="line">[enter] current blocking length=1</span><br><span class="line">[read]tx_id=32 seg_id=1 index=3 size=8</span><br><span class="line">transaction created. id=33 addr=0x7f35dc00da40 log_size=100</span><br><span class="line">[enter] current blocking length=1</span><br></pre></td></tr></table></figure><p>似乎batcher的enter有问题，blocking length不对</p><p>…<br>一开始初始化把1写成0了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> const_zero = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> const_one = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="尝试2（逻辑错误）"><a href="#尝试2（逻辑错误）" class="headerlink" title="尝试2（逻辑错误）"></a>尝试2（逻辑错误）</h3><p>改batcher、换回锁，总是第一个transaction可以跑到batcher cleanup，第二批就不行，也许是中间清理有问题<br>但是本地测试并打印region，应该没问题</p><p>在虚拟机里加入了具体的R/W输出，发现第二轮的read卡住了<br>继续查发现read没问题，但是read之后write就写不进去了<br>发现是逻辑问题：写的时候，如果还没写过，会尝试gain_owner，但是如果自己已经读过了，需要判断owner是自己</p><p>但是虚拟机里跑还是不对，第一次read align返回了，但是没有后续了<br>发现是tm_read()最后应该return flag，写成了return false🤪</p><p>现在报错变成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">⎩ Violated isolation or atomicity</span><br></pre></td></tr></table></figure><p>终于可以进行下一步了</p><h1 id="阶段一’"><a href="#阶段一’" class="headerlink" title="阶段一’"></a>阶段一’</h1><h2 id="Violated-isolation-or-atomicity"><a href="#Violated-isolation-or-atomicity" class="headerlink" title="Violated isolation or atomicity"></a>Violated isolation or atomicity</h2><p>现在还是直接加锁，atomicity有问题只能是逻辑问题，一夜回到阶段一，又得开始找read、write、alloc的bug</p><p>多次测试，报错有2种，一个是violate atomicity，另一个是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[tm_begin 2]</span><br><span class="line">[tm_end 2]</span><br><span class="line">[tm_begin 3]</span><br><span class="line">[tm_end 3]</span><br><span class="line">[tm_begin 4]</span><br><span class="line">[tm_end 4]</span><br><span class="line">⎪ *** EXCEPTION ***</span><br><span class="line">⎩ Transactional library takes too long to process the transactions</span><br></pre></td></tr></table></figure><h3 id="尝试1-3"><a href="#尝试1-3" class="headerlink" title="尝试1"></a>尝试1</h3><p>怀疑是segment的问题，因为本地没怎么测alloc、free<br>但是加了输出，发现并没有调过这两个函数</p><h3 id="尝试2-1"><a href="#尝试2-1" class="headerlink" title="尝试2"></a>尝试2</h3><p>奇怪了，看输出没什么问题，到底是哪卡住了？<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-09 AM10.17.59.jpg"                      width=600                ><br>另一种情况是，可以继续跑，跑到最后violate atomicity</p><p>定位到一个bug！先read再write没有写write_flag！<br>但是对这里影响不大</p><h3 id="尝试3（逻辑错误）"><a href="#尝试3（逻辑错误）" class="headerlink" title="尝试3（逻辑错误）"></a>尝试3（逻辑错误）</h3><p>定位到yigebug！先write再read，读的是旧值！这个问题比较严重<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-09 AM10.48.06.jpg"                      width=600                ></p><p>现在的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read the writable copy into target</span></span><br><span class="line">read_readable_copy(target, segment, index);</span><br></pre></td></tr></table></figure><p> 这明显调的函数都和注释写的意思不一样啊🤪</p><h2 id="时间太长-2"><a href="#时间太长-2" class="headerlink" title="时间太长"></a>时间太长</h2><p> 现在的报错都是时间太长，会不会是其它线程被堵太久了？</p><p>把线程减到1个，大部分还是时间太长，有一个跑完了！感动！<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-09 AM11.03.47.jpg"                      width=600                ></p><p>把Slow trigger factor从8调到1024，都跑完了！感动！<br>也就是说，单线程的时候，read write没问题了！（测试里好像没有alloc free？）</p><p>改到2个线程，也可以跑！呜呜呜呜呜</p><p>一波未平一波又起，此时虚拟机出现了bug<br>罢了，做饭去</p><p>下午。<br>把grading的参数全部调回默认，除了slow_factor设成1024<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-09 PM2.43.00.jpg"                      width=600                ><br>对了对了！可以开始写batcher了！</p><h1 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h1><p>开始测batcher，这次要一步、一步、一步来</p><h2 id="Too-long"><a href="#Too-long" class="headerlink" title="Too long"></a>Too long</h2><p>开四个线程时，有时会卡住<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-10 PM4.45.21.jpg"                      width=600                ><br>感觉是某个transaction时间太长导致的</p><p>发现问题！如果有操作abort了，用户不会调tm_end</p><p>在read write失败时调leave()，解决</p><h2 id="没有core文件"><a href="#没有core文件" class="headerlink" title="没有core文件"></a>没有core文件</h2><p>想用coredump debug，运行显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make: *** [run] Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure><p>但是没有core文件</p><p>最后在↓的最后一个回答找到解决<br><a class="link"   href="https://askubuntu.com/questions/966407/where-do-i-find-the-core-dump-in-ubuntu-16-04lts" >Where do I find the core dump in ubuntu 16.04LTS?<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>found the core dunp in /var/lib/apport/coredump/</p></blockquote><p>core在不同文件夹，想移到同一个文件夹比较方便，拖的时候permission denied，先改了下权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 coredump/</span><br></pre></td></tr></table></figure><p>然后就可以debug了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb grading core</span><br></pre></td></tr></table></figure><p>发现是leave()的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#0  0x00007f13e809812c in leave ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br><span class="line">[Current thread is 1 (Thread 0x7f13e929c700 (LWP 1903))]</span><br></pre></td></tr></table></figure><p>但是没有显示行号，在编译时加-g（改Makefile）也不行</p><h2 id="Violated-isolation-or-atomicity-1"><a href="#Violated-isolation-or-atomicity-1" class="headerlink" title="Violated isolation or atomicity"></a>Violated isolation or atomicity</h2><p>添加了read log、write log、transaction log，加锁测试通过，改成batcher后报错</p><p>发现1或2个线程时，结果正确，4个线程会出错</p><p>发现竟然是因为开着DEBUG_READ和DEBUG_WRITE，可能是写debug output时同时访问，但是没有做同步控制，导致出错。关掉输出就好了</p><h2 id="Violated-consistency"><a href="#Violated-consistency" class="headerlink" title="Violated consistency"></a>Violated consistency</h2><p>现在大部分时间没问题，有时会出这个错</p><p>重新读了一下consistency的定义。难道是如果process读了一个值，后面这个值被改了，也得abort？但是如果被读过，这个值后面应该不能修改了。</p><h3 id="尝试1-4"><a href="#尝试1-4" class="headerlink" title="尝试1"></a>尝试1</h3><p>也许是因为read align和write align中，有时有多个判断，这些判断单独都是atomic的，但是合在一起就不是了。<br>改了一些逻辑，合并判断和交换，还是不对。</p><h3 id="尝试2-2"><a href="#尝试2-2" class="headerlink" title="尝试2"></a>尝试2</h3><p>在workload.hpp里加了一堆输出，打印具体是哪里出错，发现一个常见问题是check()中counter!=0<br>可是这个counter是什么鬼？</p><figure class="highlight hpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shared&lt;<span class="keyword">size_t</span>&gt; counter&#123;tx, tm.<span class="built_in">get_start</span>()&#125;;</span><br></pre></td></tr></table></figure><p> 找到定义<br> <figure class="highlight hpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">       Shared&lt;<span class="keyword">size_t</span>&gt;         count; <span class="comment">// Number of allocated accounts in this segment</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">/** Binding constructor.</span></span><br><span class="line"><span class="comment">        * @param tx      Associated pending transaction</span></span><br><span class="line"><span class="comment">        * @param address Block base address</span></span><br><span class="line"><span class="comment">       **/</span></span><br><span class="line">       <span class="built_in">AccountSegment</span>(Transaction&amp; tx, <span class="keyword">void</span>* address): count&#123;tx, address&#125;, next&#123;tx, count.<span class="built_in">after</span>()&#125;, parity&#123;tx, next.<span class="built_in">after</span>()&#125;, accounts&#123;tx, parity.<span class="built_in">after</span>()&#125; &#123;&#125;</span><br></pre></td></tr></table></figure><br>好像和transaction数量有关，会不会是最后没有free？<br>并不是。</p><p>1或2个线程的时候没事，3个以上出错，难道是OTHER的问题？<br>又检查了一遍逻辑感觉也没什么毛病</p><h3 id="尝试3"><a href="#尝试3" class="headerlink" title="尝试3"></a>尝试3</h3><p>现有的2个报错分别是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">------WL5------ counter=16</span><br><span class="line">[1011 leave]&#123;979&#125; committed=1 remain=0 blocked=0</span><br><span class="line">[1011 tm_end]</span><br><span class="line">⎩ Violated consistency</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">------WL1------ sum=61</span><br><span class="line">------WL1------ init_balance=10</span><br><span class="line">------WL1------ count=6</span><br><span class="line">Violated isolation or atomicity</span><br></pre></td></tr></table></figure><p>后者似乎导致了前者，需要先解决。<br>一个现象是，每次差的值都是1，而不会更大<br>加到8个线程会出现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">------WL1------ sum=637</span><br><span class="line">------WL1------ init_balance=10</span><br><span class="line">------WL1------ count=64</span><br></pre></td></tr></table></figure><p>总之基本偏差不大，像是哪里有个细节不对，但是到底在哪啊💥</p><p>但是counter最后的的偏差又很大…</p><p>把transaction数量减小之后，只发现Violated consistency，而没有Violated isolation or atomicity，不会是哪里溢出了吧？<br>就10和100的区别，也不至于啊。</p><h3 id="尝试4"><a href="#尝试4" class="headerlink" title="尝试4"></a>尝试4</h3><p>又开始读workload.hpp，这个count应该就是所有segment里面account值的和，加起来应该等于预期。那么这个值错了，其实还是read、write的问题。</p><p>给read、write加锁，还是同样的报错。那么难道是batcher的问题？</p><p>又多打了一点输出，上面Violated isolation or atomicity这个问题都是出现在 Long read-only transaction, summing the balance of each account中，其实也就是在检查实际进行操作的short transaction的结果是否正确。</p><p>再想想，参数小的时候，出错误一，参数大的时候，出一和二，那么还是应该一是更根本的。而一的关键在于counter，最后应该为0。那么这个counter到底是个什么啊？？？</p><h3 id="尝试5（CAS条件）"><a href="#尝试5（CAS条件）" class="headerlink" title="尝试5（CAS条件）"></a>尝试5（CAS条件）</h3><p>仔细读输出，找到了一个bug！！！一下午了，终于见到实际的bug在哪了！！！第一次见到bug这么激动。</p><p>有write之后，竟然又读成功，还改了owner，简直离谱。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-12 PM5.57.15.jpg"                      width=600                ></p><p>多加了一些输出，轻松复现这个bug。都是有2个transaction，A读写位置1、位置2，B在A之后读写位置3、位置2。正确情况应该是B读写位置2失败，但是现在 成功了。</p><p>问题在于read_align()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if the word has not been written in the current epoch then</span></span><br><span class="line"><span class="comment">// add the transaction into the “access set” (if not already in); </span></span><br><span class="line"><span class="comment">// try set owner</span></span><br><span class="line"><span class="keyword">uint_least64_t</span> read_and_set_owner = tr-&gt;id &lt;&lt; <span class="number">32</span> | valid;</span><br><span class="line"><span class="keyword">if</span>(atomic_compare_exchange_strong(cur_control, &amp;load_control, read_and_set_owner))</span><br></pre></td></tr></table></figure><p>比较的expected值不应该是load到的值！而是判断如果owner是自己，应该是的值。</p><h2 id="Reset错误"><a href="#Reset错误" class="headerlink" title="Reset错误"></a>Reset错误</h2><p>改完这个又发现一个bug<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-12 PM7.41.39.jpg"                      width=600                ><br>A写了位置9，之后B也想写位置9但没写成功，最后没有交换valid。<br>也就是说，B先退出，调用clean flag，此时由于B没有成功，直接将control清空了，9写的WRITE_FLAG也没有了。<br>加一个判断，只有自己是owner时才reset，应该可以解决问题。</p><p>现在没有Violated isolation or atomicity的问题了（或者没碰到）。<br>暂时测试可以正常跑完了。</p><h1 id="阶段三"><a href="#阶段三" class="headerlink" title="阶段三"></a>阶段三</h1><p>batcher的功能写对了（但愿），接下来尝试在服务器上跑通（20 threads和10000 transaction per worker）。</p><h2 id="Floating-point-exception"><a href="#Floating-point-exception" class="headerlink" title="Floating point exception"></a>Floating point exception</h2><p>为了避免每次clean segments遍历整个内存，将修改过的地方记了log，但是上服务器log会爆掉。<br>改成了overflow的时候realloc四倍空间</p><p>然后就出现了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make: *** [run] Floating point exception (core dumped)</span><br></pre></td></tr></table></figure><h3 id="尝试1-5"><a href="#尝试1-5" class="headerlink" title="尝试1"></a>尝试1</h3><p>gdb grading core一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[New LWP 2519]</span><br><span class="line">[New LWP 2518]</span><br><span class="line">[New LWP 2509]</span><br><span class="line">Core was generated by `./grading 453 ../reference.so ../338094.so&#x27;.</span><br><span class="line">Program terminated with signal SIGSEGV, Segmentation fault.</span><br><span class="line">#0  0x00007f34bc478f31 in ?? ()</span><br><span class="line">[Current thread is 1 (LWP 2517)]</span><br><span class="line">(gdb) where</span><br><span class="line">#0  0x00007f34bc478f31 in ?? ()</span><br><span class="line">#1  0x0000000000000387 in ?? ()</span><br><span class="line">#2  0x00007f34b8000b20 in ?? ()</span><br><span class="line">#3  0x0000000000000006 in ?? ()</span><br></pre></td></tr></table></figure><p>…说了个寂寞</p><h3 id="尝试2（free之后）"><a href="#尝试2（free之后）" class="headerlink" title="尝试2（free之后）"></a>尝试2（free之后）</h3><p>发现是上次设置的core dump参数在虚拟机重启后没有了，需要重新再来一遍。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited</span><br><span class="line">ulimit -a</span><br></pre></td></tr></table></figure><p>权限也要重设。<br>然后就可以看core dump文件了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Program terminated with signal SIGFPE, Arithmetic exception.</span><br><span class="line">#0  0x00007f8a4a5c30d8 in tm_read ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br><span class="line">[Current thread is 1 (Thread 0x7f8a4b7c6700 (LWP 2112))]</span><br><span class="line">(gdb) where</span><br><span class="line">#0  0x00007f8a4a5c30d8 in tm_read ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br><span class="line">#1  0x00005582a6470496 in TransactionalMemory::read (this=&lt;optimized out&gt;, </span><br><span class="line">    this=&lt;optimized out&gt;, target=0x7f8a4b7c47c0, size=8, </span><br><span class="line">    source=0x7f8a44008210, tx=&lt;optimized out&gt;) at transactional.hpp:231</span><br><span class="line">#2  Transaction::read (target=0x7f8a4b7c47c0, size=8, source=0x7f8a44008210, </span><br><span class="line">    this=0x7f8a4b7c47d0) at transactional.hpp:312</span><br><span class="line">#3  Shared&lt;unsigned long&gt;::read (this=&lt;synthetic pointer&gt;)</span><br><span class="line">    at transactional.hpp:394</span><br><span class="line">#4  Shared&lt;unsigned long&gt;::operator unsigned long (this=&lt;synthetic pointer&gt;)</span><br><span class="line">    at transactional.hpp:398</span><br></pre></td></tr></table></figure><p>竟然是read里面浮点异常？read里面浮点都没有啊哪来的异常？？？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Core was generated by `./grading 453 ../reference.so ../338094.so&#x27;.</span><br><span class="line">Program terminated with signal SIGFPE, Arithmetic exception.</span><br><span class="line">#0  0x00007f7533dfd9c8 in clean_log ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br><span class="line">[Current thread is 1 (Thread 0x7f754080d700 (LWP 3303))]</span><br><span class="line">(gdb) where</span><br><span class="line">#0  0x00007f7533dfd9c8 in clean_log ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br><span class="line">#1  0x00007f7533dfdaae in clean_transaction ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br><span class="line">#2  0x00007f7533dfdb23 in batcher_cleanup ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br><span class="line">#3  0x00007f7533dfdbf8 in leave ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br><span class="line">#4  0x00007f7533dfde2d in tm_end ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br></pre></td></tr></table></figure><p>这次在clean_log()里，还靠谱点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[clean_log] size=8</span><br><span class="line">[clean_log] align=0</span><br></pre></td></tr></table></figure><p>好家伙！真是除0啊！</p><p>打印发现segment id是0，明显是访问到了不该访问的segment，要么是起始地址算错了，要么是遍历错了。</p><p>会不会是clean了已经被free的segment啊？<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-12 PM9.55.00.jpg"                      width=600                ><br>果然！</p><p>所以是因为，read、write的时候写了log，一轮结束的时候根据log里的地址去重设control。但是可能其中有的segment已经被free掉了。</p><p>改成defer到tm_destroy再free segment，成功！<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-12 PM11.17.52.jpg"                                      ></p><h2 id="Segmentation-fault"><a href="#Segmentation-fault" class="headerlink" title="Segmentation fault"></a>Segmentation fault</h2><p>上服务器跑一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ERROR] write log overflow!⎪ *** EXCEPTION ***</span><br><span class="line">⎩ Transactional library takes too long to process the transactions</span><br></pre></td></tr></table></figure><p>log写死512不够。</p><p>试图在虚拟机里复现bug，参数调到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto const nbworkers = 4;</span><br><span class="line">auto const nbtxperwrk    = 160000ul / nbworkers;</span><br><span class="line">auto const nbaccounts    = 32 * nbworkers;</span><br><span class="line">auto const expnbaccounts = 256 * nbworkers;</span><br></pre></td></tr></table></figure><p>时，又出现了Segmentation fault，查看core</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Program terminated with signal SIGSEGV, Segmentation fault.</span><br><span class="line">#0  0x00007fe97e5faa00 in clean_log ()</span><br><span class="line">   from /home/dcl/Desktop/CS453-2021-project-main/338094.so</span><br><span class="line">[Current thread is 1 (Thread 0x7fe97ffff700 (LWP 1476))]</span><br></pre></td></tr></table></figure><p>是log的问题</p><p>奇怪的是，打开clean的debug输出后，报错变成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[batcher_cleanup] total=2</span><br><span class="line">[3 clean #write=1 #read=0]</span><br><span class="line">[2 clean #write=129 #read=0]</span><br><span class="line">[batcher_cleanup] total=1</span><br><span class="line">[5 clean #write=0 #read=2]</span><br><span class="line">[batcher_cleanup] total=1</span><br><span class="line">[6 clean #write=0 #read=2]</span><br><span class="line">⎪ *** EXCEPTION ***</span><br><span class="line">⎩ Transactional library takes too long to process the transactions</span><br></pre></td></tr></table></figure><p>先把slow factor调成1024</p><p>发现有时候read log满了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[78516 clean #write=0 #read=512]</span><br><span class="line">[batcher_cleanup] done.</span><br><span class="line">batch round -&gt; 32924</span><br><span class="line">[batcher_cleanup] total=1</span><br><span class="line">[78517 clean #write=0 #read=512]</span><br><span class="line">[batcher_cleanup] done.</span><br><span class="line">batch round -&gt; 32925</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">batch round -&gt; 56620</span><br><span class="line">[77895 tm_begin] is_ro=0</span><br><span class="line">[ERROR] read log overflow! tr_id=77894 is_ro=1</span><br><span class="line">[77896 tm_begin] is_ro=1</span><br><span class="line">[ERROR] read log overflow! tr_id=77893 is_ro=1</span><br><span class="line">[77897 tm_begin] is_ro=1</span><br></pre></td></tr></table></figure><p>不是设置过read only不写log吗？发现代码里没有，可能是前面哪次debug回退删掉了🤪</p><p>重新加入判断：is_ro时不写log、不清理，成功！</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-13 AM11.45.34.jpg"                      width=600                ><p>现在跑↑这个参数可以过了！可喜可贺！</p><h2 id="log-overflow"><a href="#log-overflow" class="headerlink" title="log overflow"></a>log overflow</h2><p>上服务器！</p><p>write log overflow😭</p><p>512，不够<br>1024，不够<br>2048，不够！</p><p>虚拟机调成相同的参数试试。至少有一个好消息，虚拟机的报错现在和服务器一样了！也就是说， 可以直接在虚拟机上测试一下log的大小。</p><p>可是虚拟机2048够了啊？见鬼。</p><p>等等…刚才上服务器改了参数忘记重新打包zip了…2048重新试一次</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-13 PM12.03.39.jpg"                      width=600                ><p>啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊！！！！！！！！！！！！！！！！</p><p>虚拟机1024也能过，要不上服务器再试一次。果不其然！过了！哈哈哈哈哈！</p><h1 id="Milestone"><a href="#Milestone" class="headerlink" title="Milestone"></a>Milestone</h1><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-13 PM12.16.39.jpg"                      width=600                ><p>太感动了！</p><p>第一次过，绿色，竟然有1.6！活过来了！</p><p>从11/28开始写这个版本，断断续续写到今天12/13，差不多两周，终于，及格了😭😭😭<br>（虽然中间还写了个DA project submission3，DA可真是太友善了，我爱Java）</p><h1 id="阶段四"><a href="#阶段四" class="headerlink" title="阶段四"></a>阶段四</h1><p>尝试改进，提高性能。</p><p>-&gt; <a href="https://coconutnutx.github.io/2021/12/16/ca-condition/">CA project 状态分析&amp;debug</a></p><h2 id="BoundedOverrun"><a href="#BoundedOverrun" class="headerlink" title="BoundedOverrun"></a>BoundedOverrun</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terminate called after throwing an instance of &#x27;Exception::BoundedOverrun&#x27;</span><br></pre></td></tr></table></figure><p>发现是优化逻辑后read_only transaction没有free</p><h1 id="Memcheck"><a href="#Memcheck" class="headerlink" title="Memcheck"></a>Memcheck</h1><p>下面主要是用Valgrind检查内存泄漏时的问题。</p><p>解决上面的问题后还有泄露：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">==2068== 32 bytes in 1 blocks are still reachable in loss record 1 of 2</span><br><span class="line">==2068==    at 0x4C33B25: calloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">==2068==    by 0x4E3F7F4: _dlerror_run (dlerror.c:140)</span><br><span class="line">==2068==    by 0x4E3F050: dlopen@@GLIBC_2.2.5 (dlopen.c:87)</span><br><span class="line">==2068==    by 0x10DEE7: TransactionalLibrary::TransactionalLibrary(char const*) (in /home/dcl/Desktop/CS453-2021-project-main/grading/grading)</span><br><span class="line">==2068==    by 0x10B25C: main (in /home/dcl/Desktop/CS453-2021-project-main/grading/grading)</span><br><span class="line">==2068== </span><br><span class="line">==2068== 2,448 bytes in 51 blocks are definitely lost in loss record 2 of 2</span><br><span class="line">==2068==    at 0x4C31B0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">==2068==    by 0x859A0D9: ???</span><br><span class="line">==2068==    by 0x10E12D: Transaction::Transaction(TransactionalMemory const&amp;, Transaction::Mode) (in /home/dcl/Desktop/CS453-2021-project-main/grading/grading)</span><br><span class="line">==2068==    by 0x10F425: auto transactional&lt;WorkloadBank::long_tx(unsigned long&amp;) const::&#123;lambda(Transaction&amp;)#1&#125;&gt;(TransactionalMemory const&amp;, Transaction::Mode, WorkloadBank::long_tx(unsigned long&amp;) const::&#123;lambda(Transaction&amp;)#1&#125;&amp;&amp;) [clone .constprop.125] (in /home/dcl/Desktop/CS453-2021-project-main/grading/grading)</span><br><span class="line">==2068==    by 0x110A7A: WorkloadBank::run(unsigned long, unsigned long) const (in /home/dcl/Desktop/CS453-2021-project-main/grading/grading)</span><br><span class="line">==2068==    by 0x10D376: measure(Workload&amp;, unsigned int, unsigned int, unsigned long, unsigned long, unsigned long, unsigned long)::&#123;lambda(unsigned int)#1&#125;::operator()(unsigned int) const (in /home/dcl/Desktop/CS453-2021-project-main/grading/grading)</span><br><span class="line">==2068==    by 0x531E6DE: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.25)</span><br><span class="line">==2068==    by 0x50496DA: start_thread (pthread_create.c:463)</span><br><span class="line">==2068==    by 0x5CC171E: clone (clone.S:95)</span><br></pre></td></tr></table></figure><p>应该是read only在read失败时，不会调用tm_end，所以应该就地free。</p><p>果然。迅速解决！耶！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;惨痛经验&quot;&gt;&lt;a href=&quot;#惨痛经验&quot; class=&quot;headerlink&quot; title=&quot;惨痛经验&quot;&gt;&lt;/a&gt;惨痛经验&lt;/h1&gt;&lt;h2 id=&quot;Start-easy&quot;&gt;&lt;a href=&quot;#Start-easy&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Debug" scheme="https://coconutnutx.github.io/categories/Debug/"/>
    
    
      <category term="concurrent_algorithm" scheme="https://coconutnutx.github.io/tags/concurrent-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>DA project 2 validation tool</title>
    <link href="https://coconutnutx.github.io/2021/11/30/validate/"/>
    <id>https://coconutnutx.github.io/2021/11/30/validate/</id>
    <published>2021-11-30T08:40:52.000Z</published>
    <updated>2021-11-30T08:40:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h1><p>‼️ Dependency bug fixed. (10/12)</p><p>‼️ 不测试FIFO</p><p>‼️ 最多9个线程（若要测10+可修改拼接文件名代码）</p><hr><p>为了测试submission2(Localized Causal Broadcast)的输出写了个简陋工具，仅<strong>有限情况</strong>下<strong>测试</strong>用<br>仅！供！参！考！不！保！证！对！</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>如，process 1依赖2、3，和4、5没关系，先找出所有process输出中关于1、2、3的消息，然后统计1 broadcast每条消息时的vector clock，以及其它process deliver每条消息时的vector clock，后者的&gt;=前者。1的输出可以比其它多，此时多的不考虑，只比较前面的部分。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>基本和给的validate_fifo.py差不多<br>把代码、config、output放在同一个文件夹内（即stress.py的所有输出，有多余的没关系）<br>带参数–proc_num运行</p><h2 id="流程示例"><a href="#流程示例" class="headerlink" title="流程示例"></a>流程示例</h2><ol><li>cd到tools</li><li>把validate_lcausal.py放到tools中</li><li>run stress<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python stress.py -r ../template_java/run.sh -t lcausal -l output -p 4 -m 100</span><br><span class="line"></span><br><span class="line">// VM</span><br><span class="line">python3 stress.py -r ../template_java/run.sh -t lcausal -l output -p 4 -m 100</span><br></pre></td></tr></table></figure><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-11-30 AM9.51.22.jpg"                      width='400px'                ></li><li>run validate<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python validate_lcausal.py --proc_num 4</span><br><span class="line"></span><br><span class="line">// VM</span><br><span class="line">python3 validate_lcausal.py --proc_num 4</span><br></pre></td></tr></table></figure><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-12-01 PM3.03.46.jpg"                      width='600px'                ></li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">config_path = <span class="string">&#x27;./output/config&#x27;</span></span><br><span class="line">output_path = <span class="string">&#x27;./output/proc0&#x27;</span>   <span class="comment"># append id.output later, id&lt;=9</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_config</span>():</span></span><br><span class="line">    f = <span class="built_in">open</span>(config_path,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">    data = f.readlines()</span><br><span class="line">    m = <span class="number">0</span></span><br><span class="line">    <span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> data:</span><br><span class="line">        splited = line.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">            m = <span class="built_in">int</span>(splited[<span class="number">0</span>]) <span class="comment"># how many messages each process should broadcast</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        sender = <span class="built_in">int</span>(splited[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(splited)):</span><br><span class="line">            <span class="built_in">dict</span>.setdefault(sender,[]).append(<span class="built_in">int</span>(splited[i])) <span class="comment"># dependency (including sender itself)</span></span><br><span class="line">        count+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dict</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># find all &#x27;d sender seq&#x27; in output_id, where sender is in depent set</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDependentList</span>(<span class="params"><span class="built_in">id</span>, dset</span>):</span></span><br><span class="line">    cur_output_path = output_path+<span class="built_in">str</span>(<span class="built_in">id</span>)+<span class="string">&#x27;.output&#x27;</span></span><br><span class="line">    f = <span class="built_in">open</span>(cur_output_path,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">    data = f.readlines()</span><br><span class="line">    </span><br><span class="line">    sequence = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> data:</span><br><span class="line">        splited = line.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> splited[<span class="number">0</span>] == <span class="string">&quot;d&quot;</span>: <span class="comment"># only consider diliver</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(splited[<span class="number">1</span>]) <span class="keyword">in</span> dset: <span class="comment"># only consider sender in depent set</span></span><br><span class="line">                sequence.append(line)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(<span class="built_in">id</span>),<span class="string">&#x27;#msg:&#x27;</span>,<span class="built_in">len</span>(sequence))</span><br><span class="line">    <span class="keyword">return</span> sequence</span><br><span class="line"></span><br><span class="line"><span class="comment"># find all &#x27;b seq&#x27; and relevent delivered message in output_id, where sender is in depent set</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDependentListOfCreator</span>(<span class="params"><span class="built_in">id</span>, dset</span>):</span></span><br><span class="line">    cur_output_path = output_path+<span class="built_in">str</span>(<span class="built_in">id</span>)+<span class="string">&#x27;.output&#x27;</span></span><br><span class="line">    f = <span class="built_in">open</span>(cur_output_path,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">    data = f.readlines()</span><br><span class="line">    </span><br><span class="line">    sequence = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> data:</span><br><span class="line">        splited = line.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> splited[<span class="number">0</span>] == <span class="string">&quot;b&quot;</span>:</span><br><span class="line">            sequence.append(line)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(splited[<span class="number">1</span>]) <span class="keyword">in</span> dset:</span><br><span class="line">                sequence.append(line)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(<span class="built_in">id</span>),<span class="string">&#x27;#msg:&#x27;</span>,<span class="built_in">len</span>(sequence))</span><br><span class="line">    <span class="keyword">return</span> sequence</span><br><span class="line">    </span><br><span class="line"><span class="comment"># get vector clock associated with each message created by id from sequence</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getVectorClock</span>(<span class="params">sequence, <span class="built_in">id</span>, proc_num</span>):</span></span><br><span class="line">    clock = []</span><br><span class="line">    msg_clock_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(proc_num+<span class="number">1</span>):</span><br><span class="line">        clock.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> msg <span class="keyword">in</span> sequence:</span><br><span class="line">        splited = msg.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        sender = <span class="built_in">int</span>(splited[<span class="number">1</span>])</span><br><span class="line">        clock[sender]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> sender==<span class="built_in">id</span>:</span><br><span class="line">            msg_clock_list.append(clock.copy())</span><br><span class="line">    <span class="keyword">return</span> msg_clock_list</span><br><span class="line"></span><br><span class="line"><span class="comment"># get vector clock associated with each message broadcasted by id from sequence</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getVectorClockOfCreator</span>(<span class="params">sequence, <span class="built_in">id</span>, proc_num</span>):</span></span><br><span class="line">    clock = []</span><br><span class="line">    msg_clock_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(proc_num+<span class="number">1</span>):</span><br><span class="line">        clock.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> msg <span class="keyword">in</span> sequence:</span><br><span class="line">        splited = msg.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        sender = <span class="built_in">int</span>(splited[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> splited[<span class="number">0</span>]==<span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            clock[sender]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg_clock_list.append(clock.copy())</span><br><span class="line">    <span class="keyword">return</span> msg_clock_list</span><br><span class="line">    </span><br><span class="line"><span class="comment"># check if dependency of id is satisfied in all other process</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkProcessId</span>(<span class="params"><span class="built_in">id</span>, dset</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;checking process&#x27;</span>, <span class="built_in">str</span>(<span class="built_in">id</span>), <span class="string">&#x27;,depend on&#x27;</span>, dset)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># sequence of currrent process</span></span><br><span class="line">    ref_sequence = getDependentListOfCreator(<span class="built_in">id</span>, dset)</span><br><span class="line">    ref_clock = getVectorClockOfCreator(ref_sequence, <span class="built_in">id</span>, proc_num)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>,<span class="string">&#x27;#clock:&#x27;</span>,<span class="built_in">len</span>(ref_clock))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(proc_num):</span><br><span class="line">        cur_id = i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> cur_id != <span class="built_in">id</span>:</span><br><span class="line">            <span class="comment"># sequence of other process</span></span><br><span class="line">            sequence = getDependentList(cur_id, dset)</span><br><span class="line">            <span class="comment"># get vector clock</span></span><br><span class="line">            clock = getVectorClock(sequence, <span class="built_in">id</span>, proc_num)</span><br><span class="line">            <span class="built_in">print</span>(cur_id,<span class="string">&#x27;#clock:&#x27;</span>,<span class="built_in">len</span>(clock))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># number should be less of equal</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(clock)&gt;<span class="built_in">len</span>(ref_clock):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Number exceeds!&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># output should be the same with ref_sequence</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(clock)):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(proc_num+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> ref_clock[i][j] &gt; clock[i][j]:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&#x27;Clock not match!&#x27;</span>)</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&#x27;ref_clock:&#x27;</span>,ref_clock[i])</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&#x27;clock    :&#x27;</span>,clock[i])</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># check output of all processes</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkProcess</span>(<span class="params">proc_num</span>):</span></span><br><span class="line">    depend = read_config()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;dependency:&#x27;</span>,depend,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(proc_num):</span><br><span class="line">        <span class="built_in">id</span> = i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> checkProcessId(<span class="built_in">id</span>, depend[<span class="built_in">id</span>])==<span class="literal">False</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;validate process&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>),<span class="string">&#x27;OK\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line"></span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--proc_num&quot;</span>,</span><br><span class="line">        required=<span class="literal">True</span>,</span><br><span class="line">        dest=<span class="string">&quot;proc_num&quot;</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;Total number of processes&quot;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    results = parser.parse_args()</span><br><span class="line">    </span><br><span class="line">    proc_num = <span class="built_in">int</span>(results.proc_num)</span><br><span class="line">    <span class="keyword">if</span> checkProcess(proc_num):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Validation OK&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Validation failed!&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="关于dependency"><a href="#关于dependency" class="headerlink" title="关于dependency"></a>关于dependency</h1><blockquote><p>We say that a process <code>x</code> is affected by a process <code>z</code> if all the messages which process <code>z</code> broadcasts and which process <code>x</code> delivers become dependencies for all future messages broadcast by process <code>x</code>.</p></blockquote><p>个人理解是，如果</p><ul><li>p1 b 1</li><li>p2 d 1 1</li><li>p1 d 2 1</li><li>p1 d 3 1</li><li>p1 b 2<br>此时p1的dependency是[1 1 1]，p2在d 1 2时需要有这些dependency<br>加入broadcast或deliver每条消息时对应的clock</li><li>p1 b 1 [0 0 0]</li><li>p2 d 1 1 [0 0 0]</li><li>p1 d 2 1</li><li>p1 d 3 1</li><li>p1 b 2 [1 1 1]</li><li>p2 d 3 1</li><li>p2 d 2 1</li><li>p2 d 1 2 [1 1 1]<br>统计时，对reference需要统计broadcast时的clock，而其它需统计deliver时的clock</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Update&quot;&gt;&lt;a href=&quot;#Update&quot; class=&quot;headerlink&quot; title=&quot;Update&quot;&gt;&lt;/a&gt;Update&lt;/h1&gt;&lt;p&gt;‼️ Dependency bug fixed. (10/12)&lt;/p&gt;
&lt;p&gt;‼️ 不测试FIFO&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="distributed_algorithm" scheme="https://coconutnutx.github.io/tags/distributed-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>CA project 思路笔记</title>
    <link href="https://coconutnutx.github.io/2021/11/28/ca-project/"/>
    <id>https://coconutnutx.github.io/2021/11/28/ca-project/</id>
    <published>2021-11-28T13:33:12.000Z</published>
    <updated>2021-11-28T13:33:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>看Project description里给的Dual-versioned transactional memory的一些记录</p><h1 id="关于access-set"><a href="#关于access-set" class="headerlink" title="关于access set"></a>关于access set</h1><h2 id="情况分析"><a href="#情况分析" class="headerlink" title="情况分析"></a>情况分析</h2><p>假设当前A是readable copy，B是writable copy，某一个位置可能出现的一些情况：</p><ol><li>小明读，成功，加入set<ol><li>张三读，成功，加入set<ol><li>小明写，发现张三也在set，失败 <font color="red">只要set里有别人，就不能写了</font></li></ol></li><li>张三写，发现小明已经在set，失败 <font color="red">只要set里有别人，就不能写了</font></li><li>小明写，set里只有自己，成功<ol><li>小明读，发现已经被写过了，自己在set里，成功，读B</li><li>张三读，发现已经被写过了，自己不在set里，失败</li></ol></li></ol></li></ol><h2 id="什么时候可以加入？"><a href="#什么时候可以加入？" class="headerlink" title="什么时候可以加入？"></a>什么时候可以加入？</h2><ol><li>读成功的时候<br> 什么时候可以读？<ol><li>没人写过，随便读，读A</li><li>自己写过，可以读，读B <font color="red">如果是别人写的，自己不可能在set里，不能读</font></li></ol></li><li>写成功的时候<br> 什么时候可以写？<ol><li>没人写过，且set里没别人 <font color="red">只可能有一个人是通过写加入set的</font></li><li>自己写过</li></ol></li></ol><p>从而保证：</p><ol><li>只可能有一个人写</li><li>写过的地方只有写的人能读</li><li>没写过的地方都可以读</li></ol><h2 id="set可以只记第一个"><a href="#set可以只记第一个" class="headerlink" title="set可以只记第一个"></a>set可以只记第一个</h2><p>set里可以只记录第一个加入set的人，因为：</p><ol><li>如果第一个加入set是通过写加入的<ol><li>后面可以通过set判断自己写过，可以继续读写</li><li>其他人发现写过，且不是自己写的，读写都不可以</li></ol></li><li>如果第一个加入set是通过读加入的，<ol><li>别人不能写，因为虽然没人写过，但set里已经有人了</li><li>别人可以读</li><li>自己可以写，自己写过之后，别人也不可以读了<br>这个第一个加入set的，可以视为所有者</li></ol></li></ol><p>🧐project description里面说不要implement an actual set，那么按这个逻辑，只存一个值应该就足够了</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>也就是说，一个位置是否可以读写有以下几种状态：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-11-28 PM2.36.51.jpg"                                     ></p><p>且1状态中，如果没有其他人读过，占有者可写。如果有人读过，则不可写了。</p><p>以上都是针对读写事务，只读事务可以直接读，不影响</p><p>更新<a href="https://coconutnutx.github.io/2021/12/16/ca-condition/">CA project 状态分析</a></p><h2 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h2><p>Q：可能有写成功的，但后续操作失败，如何处理？<br>A：这样的TX不会到commit()，而只有在commit()中可以更改valid copy，因此下一轮中有效的仍是旧的值</p><h1 id="关于batcher"><a href="#关于batcher" class="headerlink" title="关于batcher"></a>关于batcher</h1><p>什么时候调？</p><pre><code>1. 事务开始，调enter() -&gt; 即在tm_begin()中2. 最后一个操作结束时，调leave() -&gt; 即在tm_end()中</code></pre><h2 id="情况分析-1"><a href="#情况分析-1" class="headerlink" title="情况分析"></a>情况分析</h2><ol><li>初始时，remaining=0</li><li>第一个人enter()，remaining变成1</li><li>后面的人enter()，都被挂到blocked</li><li>第一个人leave()，remaining变成0</li><li>counter+1  <font color="red">相当于进入下一轮</font><ul><li>remaining重设为blocked的长度</li><li>叫醒所有blocked里的线程</li><li>清空blocked</li></ul></li><li>此时上一轮中被blocked的线程，在这一轮中一起开始工作。当有新线程调enter()，又会被挂到blocked里，等待下一轮</li></ol><h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>Q：为什么commit()中交换valid copy要推迟到两轮交替的间隙进行？<br>A：保证atomicity</p><p>Q：get_epoch()什么时候用到？是干什么用的？<br>A：优化的时候用</p><h1 id="关于tx-t"><a href="#关于tx-t" class="headerlink" title="关于tx_t"></a>关于tx_t</h1><p>一个事务需要记录的东西：</p><ul><li>boolean 是否成功 <font color="red">如果已经失败了，后面读写的时候可以直接返回</font></li><li>boolean 是否只读 <font color="red">读的时候可以直接读</font></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看Project description里给的Dual-versioned transactional memory的一些记录&lt;/p&gt;
&lt;h1 id=&quot;关于access-set&quot;&gt;&lt;a href=&quot;#关于access-set&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="concurrent_algorithm" scheme="https://coconutnutx.github.io/tags/concurrent-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>更改主题记录</title>
    <link href="https://coconutnutx.github.io/2021/11/16/theme/"/>
    <id>https://coconutnutx.github.io/2021/11/16/theme/</id>
    <published>2021-11-16T11:01:22.000Z</published>
    <updated>2021-11-16T11:01:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直用的<a class="link"   href="https://github.com/Shen-Yu/hexo-theme-ayer" >Ayer<i class="fas fa-external-link-alt"></i></a>主题，突然发现搜索不能用，debug了一早上解决不了，决定干脆换个主题</p><p>尝试过三个主题后<br><a class="link"   href="https://github.com/lh1me/hexo-theme-aomori" >Aomori<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/SukkaW/hexo-theme-suka" >suka<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/XPoet/hexo-theme-keep" >keep<i class="fas fa-external-link-alt"></i></a></p><p>决定用keep<br>太优雅了，搜索也没有bug，妙</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前一直用的&lt;a class=&quot;link&quot;   href=&quot;https://github.com/Shen-Yu/hexo-theme-ayer&quot; &gt;Ayer&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;主题，突然发现搜索不能用，d
      
    
    </summary>
    
    
      <category term="Memo" scheme="https://coconutnutx.github.io/categories/Memo/"/>
    
    
      <category term="tool" scheme="https://coconutnutx.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>sync example note2：memory order</title>
    <link href="https://coconutnutx.github.io/2021/11/13/concurrent2/"/>
    <id>https://coconutnutx.github.io/2021/11/13/concurrent2/</id>
    <published>2021-11-13T09:26:37.000Z</published>
    <updated>2021-11-13T09:26:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>Producer consumer example</p><p>There might be conflict on buffer[], but consumed_until and produced_until prevent that (if used correctly).</p><p>So, only need to make sure consumed_until and produced_until accessed correctly under concurrency.</p><h1 id="Using-locks"><a href="#Using-locks" class="headerlink" title="Using locks"></a>Using locks</h1><p>In each round of produce()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  lock_acquire(&amp;lock);</span><br><span class="line">  <span class="keyword">if</span> (consumed_until + BUFFER_SIZE &gt; r) <span class="keyword">break</span>;</span><br><span class="line">  lock_release(&amp;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">produced[r] = ...</span><br><span class="line">buffer[r % BUFFER_SIZE] = produced[r];</span><br><span class="line">produced_until++;</span><br><span class="line">lock_release(&amp;lock);</span><br></pre></td></tr></table></figure><p>Two locks:</p><ol><li>check if can produce: conflict on consumed_until</li><li>conflict on produced_until</li></ol><p>In each round of consume()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  lock_acquire(&amp;lock);</span><br><span class="line">  <span class="keyword">if</span> (produced_until &gt; r) <span class="keyword">break</span>;</span><br><span class="line">  lock_release(&amp;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumed[r] = buffer[r % BUFFER_SIZE];</span><br><span class="line">consumed_until++;</span><br><span class="line">lock_release(&amp;lock);</span><br></pre></td></tr></table></figure><p>Two locks:</p><ol><li>check if can consume: conflict on produced_until</li><li>conflict on consumed_until</li></ol><h1 id="Using-atomic-vairables"><a href="#Using-atomic-vairables" class="headerlink" title="Using atomic vairables"></a>Using atomic vairables</h1><p>In produce, two locks can be modified:</p><ol><li><p>check if can produce: conflict on consumed_until</p><p>no ordering constraints -&gt; memory_order_relaxed</p></li><li><p>conflict on produced_until</p><p>store produced_until should happen after all operations -&gt; load-store + store-store = release</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// The memory order can be relaxed as we don&#x27;t read anything &quot;produced&quot; by the consumer.</span></span><br><span class="line">  <span class="keyword">int</span> local_cu = atomic_load_explicit(&amp;consumed_until, memory_order_relaxed);</span><br><span class="line">  <span class="keyword">if</span> (local_cu + BUFFER_SIZE &gt; r) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">produced[r] = ...</span><br><span class="line">buffer[r % BUFFER_SIZE] = produced[r];</span><br><span class="line"><span class="comment">// We want to increment &quot;produced_until&quot; after the buffer has been written.</span></span><br><span class="line"><span class="comment">// By using memory_order_release, we prevent the STOREs on buffer from being</span></span><br><span class="line"><span class="comment">// reordered after the atomic operation.</span></span><br><span class="line">atomic_fetch_add_explicit(&amp;produced_until, <span class="number">1</span>, memory_order_release);</span><br></pre></td></tr></table></figure><p>In consume, two locks can be modified:</p><ol><li><p>check if can consume: conflict on produced_until</p><p>load produced_until should happen before all operations -&gt; load-load + load-store = acquire</p></li><li><p>conflict on consumed_until</p><p>store consumed_until should happen after all operations -&gt; load-store + store-store = release</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// We don&#x27;t want to access the buffer before checking the atomic variable.</span></span><br><span class="line">  <span class="comment">// The memory_order_acquire prevents this reordering.</span></span><br><span class="line">  <span class="keyword">int</span> local_pu = atomic_load_explicit(&amp;produced_until, memory_order_acquire);</span><br><span class="line">  <span class="keyword">if</span> (local_pu &gt; r) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumed[r] = buffer[r % BUFFER_SIZE];</span><br><span class="line">atomic_fetch_add_explicit(&amp;consumed_until, <span class="number">1</span>, memory_order_release);</span><br></pre></td></tr></table></figure><h1 id="Memory-barriers"><a href="#Memory-barriers" class="headerlink" title="Memory barriers"></a>Memory barriers</h1><blockquote><p><a class="link"   href="https://en.cppreference.com/w/cpp/atomic/memory_order" >std::memory_order<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://www.modernescpp.com/index.php/fences-as-memory-barriers" >Fences are Memory Barriers<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://www.youtube.com/watch?v=qlkMbxUbKfw&ab_channel=CodeBlacksmith" >Memory Barriers - Learn Modern C++<i class="fas fa-external-link-alt"></i></a></p></blockquote><ul><li><p>memory_order_relaxed: no ordering constraints</p></li><li><p>memory_order_consume</p></li><li><p>memory_order_acquire: load-load + load-store</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-11-13 AM10.59.57.jpg"                                     ></li><li><p>memory_order_release: load-store + store-store</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-11-13 AM11.00.42.jpg"                                     ></li><li><p>memory_order_acq_rel</p></li><li><p>memory_order_seq_cst</p></li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-11-13 AM10.55.43.jpg"                                     ><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-11-13 AM10.57.03.jpg"                                     >]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Producer consumer example&lt;/p&gt;
&lt;p&gt;There might be conflict on buffer[], but consumed_until and produced_until prevent that (if used correct
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="concurrent_algorithm" scheme="https://coconutnutx.github.io/tags/concurrent-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>sync example note1</title>
    <link href="https://coconutnutx.github.io/2021/11/13/concurrent/"/>
    <id>https://coconutnutx.github.io/2021/11/13/concurrent/</id>
    <published>2021-11-13T08:53:44.000Z</published>
    <updated>2021-11-13T08:53:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>Cync example for C concurrent programing</p><h1 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RUNS (4096 * 256)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREADS 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">count</span><span class="params">(<span class="keyword">void</span>* null)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;New thread created\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// declare an array of 4 threads</span></span><br><span class="line">  <span class="keyword">pthread_t</span> handlers[THREADS];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">intptr_t</span> i = <span class="number">0</span>; i &lt; THREADS; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> res = pthread_create(&amp;handlers[i], <span class="literal">NULL</span>, count, <span class="literal">NULL</span>);</span><br><span class="line">    assert(!res);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> res = pthread_join(handlers[i], <span class="literal">NULL</span>);</span><br><span class="line">    assert(!res);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (counter != RUNS * THREADS) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Didn&#x27;t count so well. :/, found %d\n&quot;</span>, counter);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Counted up to %d.\n&quot;</span>, counter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;lock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">count</span><span class="params">(<span class="keyword">void</span>* null)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; RUNS; r++) &#123;</span><br><span class="line">    lock_acquire(&amp;lock);</span><br><span class="line">    counter++;</span><br><span class="line">    lock_release(&amp;lock);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Better version: use lock_wait(&amp;lock) and lock_wake_up(&amp;lock) to prevent bucy wait, but rely on a notification.</p><h1 id="Atomic-variable"><a href="#Atomic-variable" class="headerlink" title="Atomic  variable"></a>Atomic  variable</h1><p>Atomic variables (~atomic registers) do not enforce atomic operation blocks.</p><p>Need to use atomic operation.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">atomic_int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">count</span><span class="params">(<span class="keyword">void</span>* null)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; RUNS; r++) &#123;</span><br><span class="line">    atomic_fetch_add(&amp;counter, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Another example</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> expected = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (atomic_compare_exchange_strong(&amp;leader[r], &amp;expected, tid)) &#123;</span><br><span class="line">atomic_fetch_add(&amp;nb_leaders[r], <span class="number">1</span>); <span class="comment">// used to check correctness</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h1><p>当有include .h时，报错</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang: error: linker command failed with <span class="built_in">exit</span> code <span class="number">1</span></span><br></pre></td></tr></table></figure><p>可以在Terminal</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc election2.c lock.c -o ekection2.o</span><br><span class="line">./election2.o</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Cync example for C concurrent programing&lt;/p&gt;
&lt;h1 id=&quot;Threads&quot;&gt;&lt;a href=&quot;#Threads&quot; class=&quot;headerlink&quot; title=&quot;Threads&quot;&gt;&lt;/a&gt;Threads&lt;/h1&gt;&lt;figu
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="concurrent_algorithm" scheme="https://coconutnutx.github.io/tags/concurrent-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Summary on basic register reductions</title>
    <link href="https://coconutnutx.github.io/2021/10/31/register/"/>
    <id>https://coconutnutx.github.io/2021/10/31/register/</id>
    <published>2021-10-31T17:01:49.000Z</published>
    <updated>2021-10-31T17:01:49.000Z</updated>
    
    <content type="html"><![CDATA[<img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-10-31 PM5.58.54.jpg"                                     >]]></content>
    
    <summary type="html">
    
      
      
        &lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/2021/screencaptur
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="distributed_algorithm" scheme="https://coconutnutx.github.io/tags/distributed-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>CountSketch Matrix</title>
    <link href="https://coconutnutx.github.io/2021/10/27/countsketch/"/>
    <id>https://coconutnutx.github.io/2021/10/27/countsketch/</id>
    <published>2021-10-27T20:58:59.000Z</published>
    <updated>2021-10-27T20:58:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>Drew a simple example to help understanding what I learned in class.</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/2021-10-27-225725.png"                                     ><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/2021-10-27-225726.png"                                     >]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Drew a simple example to help understanding what I learned in class.&lt;/p&gt;
&lt;img  
                     lazyload
                     src=&quot;/
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="sublinear_algorithm" scheme="https://coconutnutx.github.io/tags/sublinear-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>DA project0 test record</title>
    <link href="https://coconutnutx.github.io/2021/10/19/DA-project-test/"/>
    <id>https://coconutnutx.github.io/2021/10/19/DA-project-test/</id>
    <published>2021-10-19T16:28:01.000Z</published>
    <updated>2021-10-19T16:28:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>Project0要求实现Perfect Link，给了测试用的tc.py用来修改网络情况，stress.py模拟发消息。（Distributed Algorithms 2021-2022 Project Validation.pdf）</p><p>想测一下试试。</p><p>注：以下几个测试都没有改tc.py的参数，即↓</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-10-19 PM6.43.30.jpg"                                     ><h1 id="Round-1"><a href="#Round-1" class="headerlink" title="Round 1"></a>Round 1</h1><p>参数如图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">testConfig = &#123;</span><br><span class="line">        <span class="string">&#x27;concurrency&#x27;</span> : <span class="number">8</span>, <span class="comment"># How many threads are interferring with the running processes</span></span><br><span class="line">        <span class="string">&#x27;attempts&#x27;</span> : <span class="number">8</span>, <span class="comment"># How many interferring attempts each threads does</span></span><br><span class="line">        <span class="string">&#x27;attemptsDistribution&#x27;</span> : &#123; <span class="comment"># Probability with which an interferring thread will</span></span><br><span class="line">            <span class="string">&#x27;STOP&#x27;</span>: <span class="number">0.48</span>,          <span class="comment"># select an interferring action (make sure they add up to 1)</span></span><br><span class="line">            <span class="string">&#x27;CONT&#x27;</span>: <span class="number">0.48</span>,</span><br><span class="line">            <span class="string">&#x27;TERM&#x27;</span>:<span class="number">0.04</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 stress.py -r ../template_java/run.sh -t perfect -l output -p <span class="number">10</span> -m <span class="number">10</span></span><br></pre></td></tr></table></figure><p>testConfig在stress.py最后，这里全是默认，10个process，每个发10条消息（config中只有一行 10 1）</p><p>理论上来说，应该是2-9号都要给1号发10条，总共90条</p><p>但是出来的数据不完全是90</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-10-19 PM6.46.31.jpg"                                     ><p>（这里统计输出写了个简单工具，见最后）</p><p>根据后面测试的结果推测，问题在testConfig这里。concurrency和attempts数值都是8，也就是有8个捣乱线程各干预8次。STOP和CONT只是暂停和继续，不会干扰最后的结果。但是这里还有0.04的概率会发TERM，直接把正在干活的process杀了。所以最后有的只发了79、80</p><h1 id="Round-2"><a href="#Round-2" class="headerlink" title="Round 2"></a>Round 2</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;concurrency&#x27;</span> : <span class="number">16</span></span><br><span class="line"><span class="string">&#x27;attempts&#x27;</span> : <span class="number">16</span></span><br><span class="line"><span class="string">&#x27;attemptsDistribution&#x27;</span> : </span><br><span class="line">            <span class="string">&#x27;STOP&#x27;</span>: <span class="number">0.48</span>,</span><br><span class="line">            <span class="string">&#x27;CONT&#x27;</span>: <span class="number">0.48</span>,</span><br><span class="line">            <span class="string">&#x27;TERM&#x27;</span>:<span class="number">0.04</span></span><br><span class="line"></span><br><span class="line">-p <span class="number">20</span> -m <span class="number">20</span></span><br></pre></td></tr></table></figure><p>试了几次这个参数，情况差不多。应该有19*20=380条，但是结果分别是：267、299、360、319</p><h1 id="突然"><a href="#突然" class="headerlink" title="突然"></a>突然</h1><p>经另一位当值的昆虫馆管理员提醒，测试进程数是有上限的</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-10-19 PM6.08.42.jpg"                                     ><p>对不起我的CPU🙇‍♂️</p><p>（但是这里到底是在说9 100是上限，还是举个例子说如果9 100，让跑25分钟？？？）</p><h1 id="Round-3"><a href="#Round-3" class="headerlink" title="Round 3"></a>Round 3</h1><p>于是就把p和m直接设成9和100</p><p>意识到TERM可能会对correctness有影响，这里把TERM也调成了0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;concurrency&#x27;</span> : <span class="number">8</span></span><br><span class="line"><span class="string">&#x27;attempts&#x27;</span> : <span class="number">8</span></span><br><span class="line"><span class="string">&#x27;attemptsDistribution&#x27;</span> : </span><br><span class="line">            <span class="string">&#x27;STOP&#x27;</span>: <span class="number">0.5</span>,</span><br><span class="line">            <span class="string">&#x27;CONT&#x27;</span>: <span class="number">0.5</span>,</span><br><span class="line">            <span class="string">&#x27;TERM&#x27;</span>:<span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">-p <span class="number">9</span> -m <span class="number">100</span></span><br></pre></td></tr></table></figure><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-10-19 PM7.06.12.jpg"                                     ><p>输出没毛病</p><h1 id="Round-4"><a href="#Round-4" class="headerlink" title="Round 4"></a>Round 4</h1><p>然后把TERM改回去</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;concurrency&#x27;</span> : <span class="number">8</span></span><br><span class="line"><span class="string">&#x27;attempts&#x27;</span> : <span class="number">8</span></span><br><span class="line"><span class="string">&#x27;attemptsDistribution&#x27;</span> : </span><br><span class="line">            <span class="string">&#x27;STOP&#x27;</span>: <span class="number">0.48</span>,</span><br><span class="line">            <span class="string">&#x27;CONT&#x27;</span>: <span class="number">0.48</span>,</span><br><span class="line">            <span class="string">&#x27;TERM&#x27;</span>:<span class="number">0.04</span></span><br><span class="line"></span><br><span class="line">-p <span class="number">9</span> -m <span class="number">100</span></span><br></pre></td></tr></table></figure><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-10-19 PM7.07.10.jpg"                                     ><p>左边是运行中部分输出</p><p>可以发现有的process被SIGTERM杀掉了，第一次SIGTERM多一些，最后收到的少一些。第二次最后才有一个SIGTERM，此时已经发完了</p><p>符合预期</p><h1 id="Tool"><a href="#Tool" class="headerlink" title="Tool"></a>Tool</h1><p>由于输出长得实在没眼看，不好debug，写了个工具统计一下</p><p>这两放一个目录下：</p><ul><li>count.py</li><li>output.txt</li></ul><p>output.txt是stress.py的输出（只是process 1的output，全是deliver没有broadcast的，长这样↓）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">d 2 81</span><br><span class="line">d 2 87</span><br><span class="line">d 2 85</span><br><span class="line">d 6 48</span><br><span class="line">d 6 58</span><br><span class="line">d 6 86</span><br><span class="line">d 6 90</span><br><span class="line">d 6 93</span><br><span class="line">d 6 95</span><br><span class="line">d 6 99</span><br><span class="line">d 6 94</span><br><span class="line">d 2 11</span><br><span class="line">d 2 61</span><br><span class="line">d 2 92</span><br><span class="line">d 2 2</span><br><span class="line">d 2 9</span><br><span class="line">d 6 54</span><br><span class="line">d 2 21</span><br><span class="line">d 2 14</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>count.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">data = f.readlines()</span><br><span class="line"></span><br><span class="line"><span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> data:</span><br><span class="line">splited = line.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">sender = <span class="built_in">int</span>(splited[<span class="number">1</span>])</span><br><span class="line">seq = <span class="built_in">int</span>(splited[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">dict</span>.setdefault(sender,[]).append(seq)</span><br><span class="line">count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nTotal number of senders: &quot;</span> , <span class="built_in">len</span>(<span class="built_in">dict</span>), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Total number of messages: &quot;</span>,  count, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Details (S: sender id; T: total message received, Q: seq)\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">keys = []</span><br><span class="line"><span class="keyword">for</span> sender <span class="keyword">in</span> <span class="built_in">dict</span>.keys():</span><br><span class="line">keys.append(<span class="built_in">int</span>(sender))</span><br><span class="line">keys.sort()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> sender <span class="keyword">in</span> keys:</span><br><span class="line"><span class="built_in">dict</span>[sender].sort()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;S:&quot;</span>, <span class="built_in">format</span>(sender,<span class="string">&quot;&lt;4&quot;</span>), <span class="string">&quot; T:&quot;</span>, <span class="built_in">format</span>(<span class="built_in">len</span>(<span class="built_in">dict</span>[sender]),<span class="string">&quot;&lt;5&quot;</span>), <span class="string">&quot; Q:&quot;</span>, <span class="built_in">dict</span>[sender])</span><br><span class="line"><span class="comment"># print(&quot;S:&quot;, format(sender,&quot;&lt;4&quot;), &quot; T:&quot;, format(len(dict[sender]),&quot;&lt;5&quot;))</span></span><br></pre></td></tr></table></figure><p>后面输出多了，可以把具体的SEQ删掉掉，前面少的时候可以看看有没有重复</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Project0要求实现Perfect Link，给了测试用的tc.py用来修改网络情况，stress.py模拟发消息。（Distributed Algorithms 2021-2022 Project Validation.pdf）&lt;/p&gt;
&lt;p&gt;想测一下试试。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Memo" scheme="https://coconutnutx.github.io/categories/Memo/"/>
    
    
      <category term="distributed_algorithm" scheme="https://coconutnutx.github.io/tags/distributed-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>记录anki卡片</title>
    <link href="https://coconutnutx.github.io/2021/04/21/anki/"/>
    <id>https://coconutnutx.github.io/2021/04/21/anki/</id>
    <published>2021-04-21T09:45:17.000Z</published>
    <updated>2021-04-21T09:45:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>打算用anki背法语单词，用Fast Word Query加发音</p><p>字段：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-04-21 AM11.48.55.jpg"                      width="400px"                ><p>卡片：</p><p>正面模板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;/br&gt;</span><br><span class="line">&lt;center&gt;</span><br><span class="line">&lt;div class=&quot;background&quot;&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;word&#125;&#125;&lt;/div&gt;&lt;/br&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/center&gt;</span><br></pre></td></tr></table></figure><p>背面模板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;center&gt;</span><br><span class="line">&lt;div class=&quot;background&quot;&gt;</span><br><span class="line">&#123;&#123;FrontSide&#125;&#125;</span><br><span class="line">&lt;hr id=answer&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;pronunciation&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;explanation&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;example&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/center&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;var initVoice = function () &#123;</span><br><span class="line">    var player = document.getElementById(&#x27;dictVoice&#x27;);</span><br><span class="line">    document.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">        var target = e.target;</span><br><span class="line">        if (target.hasAttribute(&#x27;role&#x27;) &amp;&amp; target.getAttribute(&#x27;role&#x27;).indexOf(&#x27;dict_audio_js&#x27;) &gt;= 0) &#123;</span><br><span class="line">            var url = target.getAttribute(&#x27;data-rel&#x27;);</span><br><span class="line">            player.setAttribute(&#x27;src&#x27;, url);</span><br><span class="line">            player.volume = 1;</span><br><span class="line">            player.play();</span><br><span class="line">            e.preventDefault();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, false);</span><br><span class="line">&#125;;</span><br><span class="line">initVoice();&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>Fast Word Query配置：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-04-21 AM11.47.38.jpg"                                     ><p>试了一下法语助手只能查到发音，没有解释，于是解释用了有道</p><p>此时效果：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-04-21 AM11.51.40.jpg"                                     ><p>翻面自动发音，例句的语音也可以点</p><p>但有个问题是，查到的例句是白色，背景也是白色</p><p>选中example框，在编辑html中找到了这几个div的class，卡片中改样式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.card &#123;</span><br><span class="line">font-family: arial;</span><br><span class="line">font-size: 20px;</span><br><span class="line">&#125;</span><br><span class="line">.background&#123;</span><br><span class="line">max-width: 800px;</span><br><span class="line">&#125;</span><br><span class="line">.mcols-layout&#123;</span><br><span class="line"> background-color:#333335</span><br><span class="line">&#125;</span><br><span class="line">.trans-container&#123;</span><br><span class="line">background-color: #333335;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搞定~</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-04-21 PM12.22.46.jpg"                                     ><hr><p>又加了个pre字段，可以放le la之类的，显示时在word之前 </p><p>查的时候忽略（在Fast Word Query中Ignore掉），仍只查word，避免查不到解释</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;打算用anki背法语单词，用Fast Word Query加发音&lt;/p&gt;
&lt;p&gt;字段：&lt;/p&gt;
&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
     
      
    
    </summary>
    
    
      <category term="Memo" scheme="https://coconutnutx.github.io/categories/Memo/"/>
    
    
      <category term="tool" scheme="https://coconutnutx.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>Unity Debug WebGL播放视频</title>
    <link href="https://coconutnutx.github.io/2021/04/02/unity-debug/"/>
    <id>https://coconutnutx.github.io/2021/04/02/unity-debug/</id>
    <published>2021-04-02T07:53:07.000Z</published>
    <updated>2021-04-02T07:53:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>Unity内运行时播放视频没问题，导出后用火狐打开就放不了，看控制台报错是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">已拦截跨源请求：同源策略禁止读取位于 file:///Users/.../unity/Backups/WebV0.3/sharedassets0.resource 的远程资源。（原因：CORS 请求不是 http）。</span><br></pre></td></tr></table></figure><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><ol><li><p>WebGL只能通过URL播放视频</p><blockquote><p><a class="link"   href="https://blog.csdn.net/wuyt2008/article/details/107592492?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161752087116780265448826%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161752087116780265448826&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~times_rank-10-107592492.first_rank_v2_pc_rank_v29&utm_term=unity+webgl+%E8%A7%86%E9%A2%91%E9%BB%91%E5%B1%8F" >Unity2019在WebGL下播放视频<i class="fas fa-external-link-alt"></i></a></p></blockquote></li><li><p>火狐浏览器设置允许跨域</p><p>security.fileuri.strict_origin_policy改false</p><blockquote><p><a class="link"   href="https://blog.csdn.net/qq_28867949/article/details/99890103?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&spm=1001.2101.3001.4242" >Firefox火狐浏览器访问本地文件-提示跨域问题<i class="fas fa-external-link-alt"></i></a></p></blockquote></li><li><p>火狐浏览器设置允许播放视频</p><blockquote><p><a class="link"   href="https://blog.csdn.net/qq_34243277/article/details/114398872?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&spm=1001.2101.3001.4242" >Unity2018发布webgl视频无法播放<i class="fas fa-external-link-alt"></i></a></p></blockquote></li></ol><h1 id="各种失败尝试记录"><a href="#各种失败尝试记录" class="headerlink" title="各种失败尝试记录"></a>各种失败尝试记录</h1><p>1.</p><blockquote><p><a class="link"   href="https://blog.kongregate.com/unity-html5-cors-and-you/" >https://blog.kongregate.com/unity-html5-cors-and-you/<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>写了问题原因，但是没看到针对Unity怎么解决</p><p>2.</p><blockquote><p><a class="link"   href="https://www.jianshu.com/p/78904381ba32" >https://www.jianshu.com/p/78904381ba32<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>说把privacy.file_unique_origin改成false，但是它已经是false了</p><p>3.</p><p>发现Unity中Video Player的视频源有视频剪辑和URL两种方式</p><p>之前用的是视频剪辑，直接把mp4文件拖进去</p><p>改用URL试试，从浏览中找到同一个文件，测试也可以播放。试了一个网络上的mp4的URL，测试也可以</p><p>那或许可以尝试把mp4上传，然后用URL访问</p><blockquote><p><a class="link"   href="https://blog.csdn.net/weixin_33912453/article/details/94087306?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.baidujs&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.baidujs" >https://blog.csdn.net/weixin_33912453/article/details/94087306?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.baidujs&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.baidujs<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>试试这个用爱奇艺开放平台的</p><p>发现注册应用必须有url</p><p>4.</p><p>再找一下有没有视频托管网站</p><p><a class="link"   href="https://www.zhihu.com/question/23036186/answer/1716470191" >https://www.zhihu.com/question/23036186/answer/1716470191<i class="fas fa-external-link-alt"></i></a></p><p>找了一个酷播云，视频要审核，等会再看（似乎不能直接拿到URL，可能要凉）</p><p><a class="link"   href="http://www.stonepoll.com/helpcenter/hc/kb/article/fcc34c50-301a-822a-df8c-e690f5af5bb5/" >http://www.stonepoll.com/helpcenter/hc/kb/article/fcc34c50-301a-822a-df8c-e690f5af5bb5/<i class="fas fa-external-link-alt"></i></a></p><p>腾讯云要买服务，算了先</p><p>又传了一个优酷的，等会看审核</p><p>得，拿不到mp4的URL</p><p>5.</p><p>还是从浏览器入手吧，试试允许跨域</p><p><a class="link"   href="https://blog.csdn.net/nju_zjy/article/details/108870385" >https://blog.csdn.net/nju_zjy/article/details/108870385<i class="fas fa-external-link-alt"></i></a></p><p>参考这个，装一个火狐插件</p><p>没用</p><p>多试了几个插件，都没用</p><p>6.</p><p>有找到一个调浏览器设置的</p><p><a class="link"   href="https://blog.csdn.net/qq_28867949/article/details/99890103?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&amp;spm=1001.2101.3001.4242" >https://blog.csdn.net/qq_28867949/article/details/99890103?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&amp;spm=1001.2101.3001.4242<i class="fas fa-external-link-alt"></i></a></p><p>把security.fileuri.strict_origin_policy改成false</p><p>【重启后不报错了！】</p><p>但是视频还是播放不了</p><p>7.</p><p><a class="link"   href="https://blog.csdn.net/qq_38229886/article/details/103139228?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-2&amp;spm=1001.2101.3001.4242" >https://blog.csdn.net/qq_38229886/article/details/103139228?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-2&amp;spm=1001.2101.3001.4242<i class="fas fa-external-link-alt"></i></a></p><p>WebGL不支持mp4？！…</p><p>转成ogv。没用</p><p>8.</p><p>找了一个在线的mp4地址，本地ok</p><p>导出WebGL运行，不报错，播放不了</p><p>9.</p><p><a class="link"   href="https://blog.csdn.net/weixin_43779625/article/details/103410836" >https://blog.csdn.net/weixin_43779625/article/details/103410836<i class="fas fa-external-link-alt"></i></a></p><p>改用Render Texture的方式（以前是材质覆盖）</p><p>不行（甚至本地都显示不了视频，只有声音）</p><p>10.</p><p><a class="link"   href="https://blog.csdn.net/JLX_Sir/article/details/82684491?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.baidujs&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.baidujs" >https://blog.csdn.net/JLX_Sir/article/details/82684491?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.baidujs&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.baidujs<i class="fas fa-external-link-alt"></i></a></p><p>说WebGL不支持高分辨率</p><p>试试在检查器里设置转码 1/4分辨率，比特率模式低，空间质量低</p><p>导出，不行</p><p>11.</p><p><a class="link"   href="https://blog.csdn.net/qq_34243277/article/details/114398872?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&amp;spm=1001.2101.3001.4242" >https://blog.csdn.net/qq_34243277/article/details/114398872?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&amp;spm=1001.2101.3001.4242<i class="fas fa-external-link-alt"></i></a></p><p>火狐还有阻止音视频的默认设置？？关掉</p><p>mp4和ogv都不行</p><p>12.</p><p><a class="link"   href="https://blog.csdn.net/s1314_JHC/article/details/80618252" >https://blog.csdn.net/s1314_JHC/article/details/80618252<i class="fas fa-external-link-alt"></i></a></p><p>还有说是WebGL不支持MovieTexture的，用插件</p><p>导出后是黑的，疯狂报错</p><p>13.</p><p><a class="link"   href="https://blog.csdn.net/wuyt2008/article/details/107592492?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161752087116780265448826%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=161752087116780265448826&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~times_rank-10-107592492.first_rank_v2_pc_rank_v29&amp;utm_term=unity+webgl+%E8%A7%86%E9%A2%91%E9%BB%91%E5%B1%8F" >https://blog.csdn.net/wuyt2008/article/details/107592492?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161752087116780265448826%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=161752087116780265448826&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~times_rank-10-107592492.first_rank_v2_pc_rank_v29&amp;utm_term=unity+webgl+%E8%A7%86%E9%A2%91%E9%BB%91%E5%B1%8F<i class="fas fa-external-link-alt"></i></a></p><p>这个说WebGL只能通过url播放</p><p>现在调过火狐的设置了，再试试url吧</p><p>!!!!!!!!!!!!成功了😭!!!!!!!!!!!!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Unity内运行时播放视频没问题，导出后用火狐打开就放不了，看控制台报错是&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/sp
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="unity" scheme="https://coconutnutx.github.io/tags/unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity Project 版本记录</title>
    <link href="https://coconutnutx.github.io/2021/03/21/unity-project-memo/"/>
    <id>https://coconutnutx.github.io/2021/03/21/unity-project-memo/</id>
    <published>2021-03-21T16:35:47.000Z</published>
    <updated>2021-03-21T16:35:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="02-16-V0-1"><a href="#02-16-V0-1" class="headerlink" title="02.16 V0.1"></a>02.16 V0.1</h1><h2 id="新增基础移动操作"><a href="#新增基础移动操作" class="headerlink" title="新增基础移动操作"></a>新增基础移动操作</h2><ul><li><p>点击寻路</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/Feb-16-2021 18-29-31.gif"                                     ></li><li><p>靠近显示介绍</p></li><li><p>鼠标滚动前后平移</p></li><li><p>键盘前后左右平移</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/Feb-16-2021 18-30-32.gif"                                     ></li><li><p>鼠标拖拽旋转视角</p></li></ul><h1 id="02-19-V0-1-1"><a href="#02-19-V0-1-1" class="headerlink" title="02.19 V0.1.1"></a>02.19 V0.1.1</h1><h2 id="新增介绍牌"><a href="#新增介绍牌" class="headerlink" title="新增介绍牌"></a>新增介绍牌</h2><ul><li><p>删除靠近显示介绍</p></li><li><p>介绍牌鼠标移入高亮</p></li><li><p>点击介绍牌寻路</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/Feb-19-2021 17-25-59.gif"                                     ><ul><li>寻路中任意操作打断</li><li>到达目的地后转向介绍牌</li></ul></li></ul><h2 id="新增导游栏"><a href="#新增导游栏" class="headerlink" title="新增导游栏"></a>新增导游栏</h2><ul><li><p>点击中间按钮寻路</p></li><li><p>点击左右按钮更新导游栏并寻路</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/Feb-19-2021 17-26-58.gif"                                     ><ul><li>最左/最右时按钮不可用</li></ul></li></ul><h2 id="新增菜单栏"><a href="#新增菜单栏" class="headerlink" title="新增菜单栏"></a>新增菜单栏</h2><ul><li>点击帮助按钮弹出介绍</li></ul><h1 id="03-09-V0-1-2"><a href="#03-09-V0-1-2" class="headerlink" title="03.09 V0.1.2"></a>03.09 V0.1.2</h1><h2 id="新增介绍"><a href="#新增介绍" class="headerlink" title="新增介绍"></a>新增介绍</h2><ul><li><p>点击导航栏中按钮，显示简介</p><ul><li>文字超出时显示滚动条</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/Mar-09-2021 17-34-17.gif"                                     ><ul><li>点击查看大图打开新页面</li></ul></li></ul><h1 id="03-11-V0-2"><a href="#03-11-V0-2" class="headerlink" title="03.11 V0.2"></a>03.11 V0.2</h1><h2 id="重建展厅"><a href="#重建展厅" class="headerlink" title="重建展厅"></a>重建展厅</h2><ul><li><p>初始放入隋到五代的8张画</p></li><li><p>调整介绍牌样式</p></li><li><p>加入天花板和灯</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/Mar-11-2021 16-54-44.gif"                                     ></li></ul><h1 id="03-16-V0-2-1"><a href="#03-16-V0-2-1" class="headerlink" title="03.16 V0.2.1"></a>03.16 V0.2.1</h1><h2 id="加入帮助按钮"><a href="#加入帮助按钮" class="headerlink" title="加入帮助按钮"></a>加入帮助按钮</h2><ul><li><p>点击显示操作说明</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/Mar-16-2021 11-50-45.gif"                                     ></li></ul><h2 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h2><ul><li>点击查看大图时，在新窗口打开页面</li><li>调整点击寻路粒子效果</li></ul><h1 id="03-20-V0-2-2"><a href="#03-20-V0-2-2" class="headerlink" title="03.20 V0.2.2"></a>03.20 V0.2.2</h1><h2 id="HallA搭建基本完成"><a href="#HallA搭建基本完成" class="headerlink" title="HallA搭建基本完成"></a>HallA搭建基本完成</h2><ul><li><p>共28张画作</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/Mar-21-2021 22-30-25.gif"                                     ></li><li><p>设置座椅、绿植、花瓶等</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/Mar-21-2021 22-32-51.gif"                                     ></li></ul><h1 id="03-25-V0-2-3"><a href="#03-25-V0-2-3" class="headerlink" title="03.25 V0.2.3"></a>03.25 V0.2.3</h1><ul><li><p>修改导航栏高亮效果</p></li><li><p>新增装饰效果</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/Mar-26-2021 10-03-52.gif"                                     ></li></ul><h2 id="新增音乐"><a href="#新增音乐" class="headerlink" title="新增音乐"></a>新增音乐</h2><ul><li>移动时添加脚步音效</li><li>千里江山图走廊中添加流水音效</li></ul><h1 id="03-31-V0-2-4"><a href="#03-31-V0-2-4" class="headerlink" title="03.31 V0.2.4"></a>03.31 V0.2.4</h1><p>修改UI</p><ul><li><p>修改导航栏图标为文字，避免左右箭头与移动方向不一致影响体验</p></li><li><p>新增上下左右移动按钮</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/Apr-02-2021 09-24-45.gif"                                     ></li><li><p>导航栏初始显示0展览介绍，此时只有下一幅按钮可点击</p></li></ul><p>修改展厅</p><ul><li>新增展览介绍，默认进入场景时面向展览介绍，点下一幅来到第一幅画作</li><li>调整朝代介绍位置，使导航到画作时能完整浏览</li><li>新增出口</li><li>新增方向指示牌，将部分地上的花瓶移动到指示牌平台上</li></ul><p>修改导航模块</p><ul><li>点击画作也可导航</li></ul><h1 id="04-02-V0-3"><a href="#04-02-V0-3" class="headerlink" title="04.02 V0.3"></a>04.02 V0.3</h1><p>新增影厅</p><ul><li><p>开始和暂停视频</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/Apr-02-2021 09-18-14.gif"                                     ></li></ul><p>导航栏新增展开按钮</p><ul><li>点击展开去影厅和回起点按钮</li><li>去影厅导航到影厅</li><li>会起点导航到展厅介绍</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;02-16-V0-1&quot;&gt;&lt;a href=&quot;#02-16-V0-1&quot; class=&quot;headerlink&quot; title=&quot;02.16 V0.1&quot;&gt;&lt;/a&gt;02.16 V0.1&lt;/h1&gt;&lt;h2 id=&quot;新增基础移动操作&quot;&gt;&lt;a href=&quot;#新增基础移动操作&quot; cla
      
    
    </summary>
    
    
      <category term="Memo" scheme="https://coconutnutx.github.io/categories/Memo/"/>
    
    
      <category term="unity" scheme="https://coconutnutx.github.io/tags/unity/"/>
    
  </entry>
  
  <entry>
    <title>Project V0.2 Record</title>
    <link href="https://coconutnutx.github.io/2021/03/16/unity/"/>
    <id>https://coconutnutx.github.io/2021/03/16/unity/</id>
    <published>2021-03-16T09:15:39.000Z</published>
    <updated>2021-03-16T09:15:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>重新搭建了场景，unity中运行没问题</p><h1 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h1><p>构建后遇到一些bug</p><h2 id="按钮文字缺失"><a href="#按钮文字缺失" class="headerlink" title="按钮文字缺失"></a>按钮文字缺失</h2><p>构建mac版本后，按钮上的文字消失了，但是其它地方（详情、场景中）都正常</p><p>发现原本的按钮使用了TextMeshPro，但是没有必要，改成了用Text的</p><p>代码也修改成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// [SerializeField] private TextMeshProUGUI guideText = null;</span><br><span class="line">    [SerializeField] private Text guideText = null;</span><br></pre></td></tr></table></figure><p>重新构建，就没有问题了</p><p>顺便上一版中第一次点开详情没有文字的bug也消失了</p><h2 id="unityFramework-is-not-defined"><a href="#unityFramework-is-not-defined" class="headerlink" title="unityFramework is not defined"></a>unityFramework is not defined</h2><p>构建webgl版本后，firefox浏览器加载时进度条卡在80%左右，控制台报错</p><p>Uncaught ReferenceError: unityFramework is not defined</p><p>（但是发布到itch.io后可以正常显示）</p><p><a class="link"   href="https://forum.unity.com/threads/uncaught-referenceerror-unityframework-is-not-defined-at-htmlscriptelement-script-onload-webgl.803967/" >https://forum.unity.com/threads/uncaught-referenceerror-unityframework-is-not-defined-at-htmlscriptelement-script-onload-webgl.803967/<i class="fas fa-external-link-alt"></i></a></p><p>参考↑中一个回答：Try to disable compression</p><p>解决😄</p><p>之前看教程的时候应该是调过这个参数的，这次搞忘了</p><h1 id="V0-2-1"><a href="#V0-2-1" class="headerlink" title="V0.2.1"></a>V0.2.1</h1><h2 id="新标签页打开网页"><a href="#新标签页打开网页" class="headerlink" title="新标签页打开网页"></a>新标签页打开网页</h2><p>mac版本中，点查看大图会打开浏览器新页面</p><p>webgl版本中，点查看大图会直接在当前页跳转</p><p>想改成新标签页</p><p>参考<a class="link"   href="https://stackoverflow.com/questions/62348214/how-to-open-a-link-on-a-new-tab-using-webgl-c-through-unity" >https://stackoverflow.com/questions/62348214/how-to-open-a-link-on-a-new-tab-using-webgl-c-through-unity<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>using .jslib file</p><p>Assets/plugins/plugin.jslib</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var plugin = &#123;</span><br><span class="line">    OpenNewTab : function(url)</span><br><span class="line">    &#123;</span><br><span class="line">        url = Pointer_stringify(url);</span><br><span class="line">        window.open(url,&#x27;_blank&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">mergeInto(LibraryManager.library, plugin);</span><br></pre></td></tr></table></figure><p>Your C# script</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line">public class OpenURL : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    [DllImport(&quot;__Internal&quot;)]</span><br><span class="line">    private static extern void OpenNewTab(string url);</span><br><span class="line"></span><br><span class="line">    public void openIt(string url)</span><br><span class="line">    &#123;</span><br><span class="line">#if !UNITY_EDITOR &amp;&amp; UNITY_WEBGL</span><br><span class="line">             OpenNewTab(url);</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        if (Input.GetKeyDown(KeyCode.Return))</span><br><span class="line">        &#123;</span><br><span class="line">            openIt(&quot;www.wateverurluwant.com&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>firefox和itch.io测试均可~</p><h2 id="帮助按钮"><a href="#帮助按钮" class="headerlink" title="帮助按钮"></a>帮助按钮</h2><p>还需要把帮助按钮加回来</p><p>并且默认首次打开程序时弹出显示</p><h1 id="V0-2-2"><a href="#V0-2-2" class="headerlink" title="V0.2.2"></a>V0.2.2</h1><h2 id="图片模糊问题"><a href="#图片模糊问题" class="headerlink" title="图片模糊问题"></a>图片模糊问题</h2><p>把所有图片加进去了</p><p>发现千里江山图导入之后很模糊</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-03-18 PM2.38.54.jpg"                                     ><p>发现可以调最大尺寸，就清晰了</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/screencapture2021-03-18 PM2.41.11.jpg"                                     ><hr><p>测试发布的时候V0.2.2，build里面data文件有235.4MB，itch.io无法加载</p><p>将图片全体降了一个清晰度，变成114MB，可以加载了，但还是很大</p><p>将5种花删成2种，变成104.7MB</p><p>把波浪长椅换成和其它地方一样的竹椅，墙外的竹子叶子全删到最少，变成102.1MB</p><p>墙外竹子全删掉，变成91.3MB</p><p>V0.2.1的时候是42.3MB，看来还是画最占空间</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;重新搭建了场景，unity中运行没问题&lt;/p&gt;
&lt;h1 id=&quot;Debug&quot;&gt;&lt;a href=&quot;#Debug&quot; class=&quot;headerlink&quot; title=&quot;Debug&quot;&gt;&lt;/a&gt;Debug&lt;/h1&gt;&lt;p&gt;构建后遇到一些bug&lt;/p&gt;
&lt;h2 id=&quot;按钮文字缺失&quot;&gt;
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="unity" scheme="https://coconutnutx.github.io/tags/unity/"/>
    
  </entry>
  
  <entry>
    <title>Project V0.1.2 Record</title>
    <link href="https://coconutnutx.github.io/2021/03/09/unity/"/>
    <id>https://coconutnutx.github.io/2021/03/09/unity/</id>
    <published>2021-03-09T16:15:34.000Z</published>
    <updated>2021-03-09T16:15:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="描述部分"><a href="#描述部分" class="headerlink" title="描述部分"></a>描述部分</h1><p>给导航栏加了一个按钮，点击显示描述</p><p>以及一个查看大图的按钮，打开一个新页面</p><h1 id="查看大图"><a href="#查看大图" class="headerlink" title="查看大图"></a>查看大图</h1><p>关于图画细节的浏览，设想过几种方案：</p><ul><li><p>在Unity内放大图，通过移动人物或滚动图片来查看细节</p><p>但是移动的操作会比较复杂，和现有的控制冲突</p><p>滚动图片的话，各张图的大小差别太大，也不好放</p><p>还有一个是图片的版权问题，下载大图放在工程里感觉还是不太好</p></li><li><p>内嵌网页</p><p>寻找了一些实现方式，但是都比较局限，没有官方的解决方案</p></li><li><p>打开新页面</p><p>简单粗暴，虽然要跳出一下，但是专业的网站看图也好操作</p></li></ul><p>于是暂且就这样了</p><h1 id="图画信息和展板管理"><a href="#图画信息和展板管理" class="headerlink" title="图画信息和展板管理"></a>图画信息和展板管理</h1><p>以前是直接把文字信息放在展板的Object上</p><p>但是随着以后展厅的引入，会很麻烦</p><p>于是将主要信息存到了csv里，并且新增了一个单例的ArtManager，用于管理所有的文本信息和模型中展板的引用。其它Board以及GuideBar中要用到这些信息时，直接通过ArtManager获得。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class ArtManager : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public static ArtManager instance;</span><br><span class="line"></span><br><span class="line">    // reference to each board in each hall</span><br><span class="line">    [SerializeField] private Board[] boardsInHall0 = null;</span><br><span class="line">    [SerializeField] private Board[] boardsInHall1 = null;</span><br><span class="line"></span><br><span class="line">    // number of halls</span><br><span class="line">    private int numOfHalls = 2;</span><br><span class="line"></span><br><span class="line">    // store art info in each hall</span><br><span class="line">    private Dictionary&lt;int, ArtInfo&gt;[] artInfoStore;</span><br><span class="line"></span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        if(instance != null)&#123;</span><br><span class="line">            GameObject.Destroy(this.gameObject);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        instance = this;</span><br><span class="line"></span><br><span class="line">        // load art info</span><br><span class="line">        artInfoStore = new Dictionary&lt;int, ArtInfo&gt;[numOfHalls];</span><br><span class="line">        for(int i=0; i&lt;artInfoStore.Length; i++)&#123;</span><br><span class="line">            artInfoStore[i] = new Dictionary&lt;int, ArtInfo&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        ArtInfoLoader.LoadArtInfo(artInfoStore);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ---------- Functions for Board &amp; GuidBar ----------</span><br><span class="line">    public ArtInfo GetArtInfo(int hall, int index)&#123;</span><br><span class="line">        return artInfoStore[hall][index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ---------- Functions for GuideBar ----------</span><br><span class="line">    public string getGuideMenuText(int hall, int index)&#123;</span><br><span class="line">        return artInfoStore[hall][index].title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getBoardNumInHall(int hall)&#123;</span><br><span class="line">        return artInfoStore[hall].Count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Vector3[] getDestination(int hall, int index)&#123;</span><br><span class="line">        Vector3[] ret = null;</span><br><span class="line"></span><br><span class="line">        if(hall == 0)&#123;</span><br><span class="line">            ret = boardsInHall0[index - 1].GetDesitination(); // index begin with 1</span><br><span class="line">        &#125;else if(hall == 1)&#123;</span><br><span class="line">            ret = boardsInHall1[index - 1].GetDesitination();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里不同展厅的展板分了不同的数组，因为二维数组没法在Unity里拖引用，只好退而求其次了</p><p>还有一个细节是，画的index都是从1开始，这个也统一在ArtManager中处理了，其它类中就不用管了</p><h1 id="生成构建Debug"><a href="#生成构建Debug" class="headerlink" title="生成构建Debug"></a>生成构建Debug</h1><p>生成WebGL后，部分文字显示不全</p><p>查到一种解决方式：把颜色空间改成Linear，有错误提示，然后又把自动API取消勾选了。Graphics API变成了WebGL2.0。没用</p><p>popup和按钮中的中文都没有了，难道是字体的问题？</p><p>改了字体，重新生成，可以显示</p><p>但是，每次第一次打开总是没有？要先点过一次左或者右，后续才有显示。也许是加载顺序的问题？</p><p>调了几次顺序，还是不行</p><p>不仅是文字显示，有时刚开始滚动条也没有，后面慢慢解决吧</p><p>MARK 未解决的Bug：</p><p>新加载后，第一次点更多，无文字</p><p>点一次左/右后，有文字，但无法显示滚动条</p><p>重新点开更多，有滚动条</p><h1 id="寻路转向Debug"><a href="#寻路转向Debug" class="headerlink" title="寻路转向Debug"></a>寻路转向Debug</h1><p>有的时候寻路到了终点不会自动转向</p><p>发现设置GuideStatus为Ready后，有时Agent的remainingDistance仍是0（也许是有延迟），于是就直接到了stop状态</p><p>于是改成在Update()中修改状态，当前为Ready且remainingDistance!=0，状态改为On</p><p>当前为On且remainingDistance==0，设置转向，状态改为Static</p><p>但是这样又出现一个问题，即在原地点击寻路，状态无法变成On</p><p>于是在SetNewDestination()中先做一次判断，如果当前位置已经是目的位置，直接将状态设置成On</p><p>之前Ready和On状态是为了处理鼠标点击的一些问题，目前关于鼠标：</p><ul><li>途中 OK</li><li>原地（已经到达，测试转向）<ul><li>导航栏 OK</li><li>展板<ul><li>快点【被打断】</li><li>慢点 OK</li></ul></li></ul></li></ul><p>就很迷惑，先这样吧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;描述部分&quot;&gt;&lt;a href=&quot;#描述部分&quot; class=&quot;headerlink&quot; title=&quot;描述部分&quot;&gt;&lt;/a&gt;描述部分&lt;/h1&gt;&lt;p&gt;给导航栏加了一个按钮，点击显示描述&lt;/p&gt;
&lt;p&gt;以及一个查看大图的按钮，打开一个新页面&lt;/p&gt;
&lt;h1 id=&quot;查看大图&quot;
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="unity" scheme="https://coconutnutx.github.io/tags/unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity Note - Project11 Wave2</title>
    <link href="https://coconutnutx.github.io/2021/03/08/unity/"/>
    <id>https://coconutnutx.github.io/2021/03/08/unity/</id>
    <published>2021-03-08T11:03:50.000Z</published>
    <updated>2021-03-08T11:03:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>按照上次的设想：</p><ul><li><p>PerlinNoise生成波浪</p><blockquote><p><a class="link"   href="https://docs.unity3d.com/cn/current/ScriptReference/Mathf.PerlinNoise.html" >https://docs.unity3d.com/cn/current/ScriptReference/Mathf.PerlinNoise.html<i class="fas fa-external-link-alt"></i></a></p></blockquote></li><li><p>用Mesh绘制</p></li><li><p>随时间更新</p></li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/Mar-08-2021 12-02-11.gif"                                     ><p>效果还不错</p><p>加了几个，调下参数</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2021/Mar-08-2021 12-35-32.gif"                                     ><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class WaveCreator : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    [SerializeField] private int waveLength = 100; // length of wave</span><br><span class="line">    [SerializeField] private float segLen = 0.2f; // length of each segment</span><br><span class="line">    [SerializeField] private float samplingInterval = 20f;</span><br><span class="line">    [SerializeField] private float maxHeight = 10f;</span><br><span class="line"></span><br><span class="line">    [SerializeField] private string colorHex = &quot;#45b787&quot;;</span><br><span class="line">    [SerializeField] private float colorAlpha = 0.8f;</span><br><span class="line"></span><br><span class="line">    private Color waveColor;</span><br><span class="line">    private float seedX = 0;</span><br><span class="line">    private float seedY = 0;</span><br><span class="line">    </span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        // generate random seed</span><br><span class="line">        seedX = Random.value * 100f;</span><br><span class="line">        seedY = Random.value * 100f;</span><br><span class="line"></span><br><span class="line">        // set material</span><br><span class="line">        GetComponent&lt;MeshRenderer&gt;().material = InitMaterial();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Update() &#123;</span><br><span class="line">        float[] arr = GenerateNoiseArray(waveLength);</span><br><span class="line">        DrawWave(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private float[] GenerateNoiseArray(int len)&#123;</span><br><span class="line">        // generate wave height array</span><br><span class="line">        float[] arr = new float[len];</span><br><span class="line">        for(int i=0; i&lt;arr.Length; i++)&#123;</span><br><span class="line">            float x = (i + seedX + Time.time) / samplingInterval;</span><br><span class="line">            float y = (i + seedY) / samplingInterval;</span><br><span class="line">            // noise between 0.0 and 1.0</span><br><span class="line">            arr[i] = Mathf.PerlinNoise(x, y) * maxHeight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void DrawWave(float[] arr)&#123;</span><br><span class="line">        int n = arr.Length;</span><br><span class="line"></span><br><span class="line">        Vector3[] vertices = new Vector3[2*n];</span><br><span class="line">        List&lt;int&gt; triangleList = new List&lt;int&gt;();</span><br><span class="line"></span><br><span class="line">        // add vertices</span><br><span class="line">        for(int i=0; i&lt;n; i++)&#123;</span><br><span class="line">            vertices[2*i] = new Vector3(segLen*(i+1), 0, 0);</span><br><span class="line">            vertices[2*i + 1] = new Vector3(segLen*(i+1), arr[i], 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // add triangles</span><br><span class="line">        for(int i=0;i&lt;n-1;i++)&#123;</span><br><span class="line">            // clockwise order</span><br><span class="line">            triangleList.Add(2*i);</span><br><span class="line">            triangleList.Add(2*i + 1);</span><br><span class="line">            triangleList.Add(2*i + 2);</span><br><span class="line"></span><br><span class="line">            triangleList.Add(2*i + 2);</span><br><span class="line">            triangleList.Add(2*i + 1);</span><br><span class="line">            triangleList.Add(2*i + 3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int[] triangles = triangleList.ToArray();</span><br><span class="line"></span><br><span class="line">        // get mesh</span><br><span class="line">        Mesh mesh = GetComponent&lt;MeshFilter&gt;().mesh;</span><br><span class="line"></span><br><span class="line">        // clear original mesh</span><br><span class="line">        mesh.Clear();</span><br><span class="line"></span><br><span class="line">        // set new vertices</span><br><span class="line">        mesh.vertices = vertices;</span><br><span class="line"></span><br><span class="line">        // set new triangles</span><br><span class="line">        mesh.triangles = triangles;</span><br><span class="line"></span><br><span class="line">        // calculate mesh</span><br><span class="line">        mesh.RecalculateNormals();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Material InitMaterial()&#123;</span><br><span class="line">        Material material = new Material(Shader.Find(&quot;Standard&quot;));</span><br><span class="line"></span><br><span class="line">        // set rendering mode</span><br><span class="line">        SetFade(material);</span><br><span class="line"></span><br><span class="line">        // set color</span><br><span class="line">        ColorUtility.TryParseHtmlString(colorHex, out waveColor);</span><br><span class="line">        waveColor.a = colorAlpha;</span><br><span class="line">        material.SetColor(&quot;_Color&quot;, waveColor);</span><br><span class="line"></span><br><span class="line">        return material;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void SetFade(Material material)&#123;</span><br><span class="line">        // set rendering mode to fade to show alpha</span><br><span class="line">        material.SetInt(&quot;_SrcBlend&quot;, (int)UnityEngine.Rendering.BlendMode.SrcAlpha);</span><br><span class="line">        material.SetInt(&quot;_DstBlend&quot;, (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);</span><br><span class="line">        material.SetInt(&quot;_ZWrite&quot;, 0);</span><br><span class="line">        material.DisableKeyword(&quot;_ALPHATEST_ON&quot;);</span><br><span class="line">        material.EnableKeyword(&quot;_ALPHABLEND_ON&quot;);</span><br><span class="line">        material.DisableKeyword(&quot;_ALPHAPREMULTIPLY_ON&quot;);</span><br><span class="line">        material.renderQueue = 3000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;按照上次的设想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;PerlinNoise生成波浪&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&quot;link&quot;   href=&quot;https://docs.unity3d.com/cn/current/ScriptReference/
      
    
    </summary>
    
    
      <category term="Note" scheme="https://coconutnutx.github.io/categories/Note/"/>
    
    
      <category term="unity" scheme="https://coconutnutx.github.io/tags/unity/"/>
    
  </entry>
  
</feed>
